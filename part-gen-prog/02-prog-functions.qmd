# Using Functions and Libraries {#sec-calculator}

In addition to variables, **functions** are extremely important in programming. 
Functions allow you to repeat a series of steps using different information and get the result.
In a way, a function is to a variable as a verb is to a noun - functions are a concise way of performing an action. 

## {{< fa bullseye >}} Objectives

- Understand how functions are used in R and python
- Understand how to install packages in R and python
- Understand how to load packages in R and python
- Use pipes to restructure code so that it is more readable


## Mathematical Operators
Let's first start with a special class of functions that you're probably familiar with from your math classes - mathematical operators. 

Here are a few of the most important ones:

| Operation        | R symbol | Python symbol |
|------------------|----------|---------------|
| Addition         | `+`      | `+`           |
| Subtraction      | `-`      | `-`           |
| Multiplication   | `*`      | `*`           |
| Division         | `/`      | `/`           |
| Integer Division | `%/%`    | `//`          |
| Modular Division | `%%`     | `%`           |
| Exponentiation   | `^`      | `**`          |

These operands are all for scalar operations (operations on a single number) - vectorized versions, such as matrix multiplication, are somewhat more complicated (and different between R and python).

::: callout-caution
### Example: Integer and Modular Division

Integer division is the whole number answer to A/B, and modular division is the fractional remainder when A/B.

Let's demonstrate with the problem 14/3, which evaluates to `r 14/3` when division is used, but has integer part 4 and remainder 2.

::: panel-tabset
### R {.unnumbered}

`14 %/% 3` in R would be 4, and `14 %% 3` in R would be 2.

```{r}
14 %/% 3
14 %% 3
```

### Python {.unnumbered}

```{python}
14 // 3
14 % 3
```
:::

:::

## Order of Operations

Both R and Python operate under the same mathematical rules of precedence that you learned in school. You may have learned the acronym PEMDAS, which stands for Parentheses, Exponents, Multiplication/Division, and Addition/Subtraction. That is, when examining a set of mathematical operations, we evaluate parentheses first, then exponents, and then we do multiplication/division, and finally, we add and subtract.

::: panel-tabset
### R {.unnumbered}

```{r}
(1+1)^(5-2) 
1 + 2^3 * 4 
3*1^3 
```

### Python {.unnumbered}

```{python}
(1+1)**(5-2)
1 + 2**3*4
3*1**3
```
:::

## Simple String Operations

Python has some additional operators that work on strings. 
In R, you will have to use functions to perform these operations, as R does not have string operators.

::: callout-demo
::: panel-tabset
### Python {.unnumbered}

In Python, `+` will **concatenate** (stick together) two strings.
Multiplying a string by an integer will repeat the string the specified number of times.

```{python}
"first " + "second"
"hello " * 3
```

### R {.unnumbered}

In R, to concatenate things, we need to use functions: `paste` or `paste0`:

```{r}
paste("first", "second", sep = " ")
paste("first", "second", collapse = " ")
paste(c("first", "second"), sep = " ") # sep only works w/ 2 objects passed in
paste(c("first", "second"), collapse = " ") # collapse works on vectors

paste(c("a", "b", "c", "d"), 
      c("first", "second", "third", "fourth"), 
      sep = "-", collapse = " ")
# sep is used to collapse parameters, then collapse is used to collapse vectors

paste0(c("a", "b", "c"))
paste0("a", "b", "c") # equivalent to paste(..., sep = "")
```

You don't need to understand the details of this code at this point in the class, but it is useful to know how to combine strings in both languages.
:::
:::

## Using Functions

**Functions** are sets of instructions that take **arguments** and **return** values. Strictly speaking, mathematical operators (like those above) are a special type of functions -- but we aren't going to get into that now.

We're also not going to talk about how to create our own functions just yet. Instead, I'm going to show you how to *use* functions.

::: callout-warning
### Cheat Sheets!

It may be helpful at this point to print out the [R reference card](../files/Short-refcard.pdf)[^01-prog-intro-3] and the [Python reference card](../files/Python3_reference_cheat_sheet.pdf)[^01-prog-intro-4]. These cheat sheets contain useful functions for a variety of tasks in each language.

:::

[^01-prog-intro-3]: From https://cran.r-project.org/doc/contrib/Short-refcard.pdf

[^01-prog-intro-4]: From http://sixthresearcher.com/wp-content/uploads/2016/12/Python3_reference_cheat_sheet.pdf

**Methods** are a special type of function that operate on a specific variable type. In Python, methods are applied using the syntax `variable.method_name()`. So, you can get the length of a string variable `my_string` using `my_string.length()`.

R has methods too, but they are invoked differently. In R, you would get the length of a string variable using `length(my_string)`.

Right now, it is not really necessary to know too much more about functions than this: you can invoke a function by passing in arguments, and the function will do a task and return the value.

::: callout-tip
### Your Turn {.unnumbered .tryitout}

::: panel-tabset
#### Problem

Try out some of the functions mentioned on the R and Python cheatsheets.

Can you figure out how to define a list or vector of numbers? If so, can you use a function to calculate the maximum value?

Can you find the R functions that will allow you to repeat a string variable multiple times or concatenate two strings? Can you do this task in Python?

#### R Solution
```{r}
# Define a vector of numbers
x <- c(1, 2, 3, 4, 5)

# Calculate the maximum
max(x)

# function to repeat a variable multiple times
rep("test", 3)
# Concatenate strings, using "ing... " as the separator
paste(rep("test", 3), collapse = "ing... ")
```

#### Python Solution
```{python}
# Define a list of numbers
x = [1, 2, 3, 4, 5]

# Calculate the maximum
max(x)

# Repeat a string multiple times
x = ("test", )*3 # String multiplication 
                 # have to use a tuple () to get separate items
# Then use 'yyy'.join(x) to paste items of x together with yyy as separators
'ing... '.join(x)
```

:::
:::

## Overpowerd Calculators

Now that you're familiar with how to use functions, if not how to define them, you are capable of using R or python as a very fancy calculator. Obviously, both languages can do many more interesting things, which we'll get to, but let's see if we can make R and Python do some very basic stuff that hopefully isn't too foreign to you.

::: callout-caution
### Example: Triangle Side Length

![A right triangle with sides a, b, and hypotenuse c labeled.](../images/gen-prog/right-triangle.png)

Consider this triangle. I've measured the sides in an image editor and determined that $a = 212$ pixels, $b = 345$ pixels, and $c = 406$ pixels. I suspect, however, that my measurements aren't quite right - for one thing, I tried to measure in the center of the line, but it wasn't easy on the diagonal.

Let's assume that my measurements for $a$ and $b$ are accurate and calculate how far off my estimate was for side $c$.

::: panel-tabset
#### R
```{r}
# Define variables for the 3 sides of the triangle
a <- 212
b <- 345
c_meas <- 406
c_actual <- sqrt(a^2 + b^2)

# Calculate difference between measured and actual
# relative to actual 
# and make it a percentage
pct_error <- (c_meas - c_actual)/c_actual * 100
pct_error
```

#### Python
```{python}
# To get the sqrt function, we have to import the math package
import math

# Define variables for the 3 sides of the triangle
a = 212
b = 345
c_meas = 406
c_actual = math.sqrt(a**2 + b**2)

# Calculate difference between measured and actual
# relative to actual 
# and make it a percentage
pct_error = (c_meas - c_actual)/c_actual * 100
pct_error
```
:::

Interesting, I wasn't as inaccurate as I thought!
:::

::: callout-tip
### Your Turn

Of course, if you remember trigonometry, we don't have to work with right triangles. 
Let's see if we can use trigonometric functions to do the same task with an oblique triangle.

::: panel-tabset
#### Problem

Just in case you've forgotten your Trig, the Law of Cosines says that $$c^2 = a^2 + b^2 - 2 a b \cos(C),$$ where $C$ is the angle between sides $a$ and $b$.

![An oblique triangle with sides labeled a, b, and c, and angles labeled as A, B, C with capital letter opposite the lowercase side.](../images/gen-prog/not-right-triangle.png)

I measure side $a = 291$ pixels, side $b = 414$ pixels, and the angle between $a$ and $b$ to be $67.6^\circ$. What will I likely get for the length of side $c$ in pixels?

Remember to check whether R and python compute trig functions using radians or degrees! As a reminder, $\pi$ radians = $180^\circ$.

#### R solution
```{r}
# Define variables for the 3 sides of the triangle
a <- 291
b <- 414
c_angle <- 67.6
c_actual <- sqrt(a^2 + b^2 - 2*a*b*cos(c_angle/180*pi))
c_actual
```

I measured the length of side $c$ as 407 pixels.

#### Python solution
```{python}
# To get the sqrt and cos functions, we have to import the math package
import math

# Define variables for the 3 sides of the triangle
a = 291
b = 414
c_angle = 67.6
c_actual = math.sqrt(a**2 + b**2 - 2*a*b*math.cos(c_angle/180*math.pi))
c_actual
```

I measured the length of side $c$ as 407 pixels.

:::
:::

Congratulations, if you used a TI-83 in high school to do this sort of stuff, you're now just about as proficient with R and python as you were with that!

## Pipes {.unnumbered}

Pipes are useful items for moving things from one place to another. In programming, and in particular, in data programming, pipes are operators that let us move data around. 
In R, we have two primary pipes that are similar (you may see both used if you google for code online). 
Any R version after 4.1 has a built-in pipe, `|>`; the `tidyverse` libraries use a pipe from the `magrittr` package, `%>%`.

For right now, it's ok to think of the two pipes as essentially the same (but you can read about the differences @machlisUseNewPipe2021).

Fundamentally, a pipe allows you to take a function `b()` and apply it to `x`, like `b(x)`, but write it as `x |> b()` or `x %>% b()`. 
This is particularly useful in cases where there are multiple sequential analysis steps, because where in regular notation you have to read the functions from the inside out to understand the sequential steps, with pipes, you have a clear step-by-step list of the order of operations.

In Python, there is a `pipe` function in the Pandas library that works using `.pipe(function)` notation @shadowtalkerAnswerFunctionalPipes2015. 
From what I've seen reading code online, however, pipes are less commonly used in Python code than they are in R code. 
That's ok - languages have different conventions, and it is usually best to adopt the convention of the language you're working in so that your code can be read, run, and maintained by others more easily.

::: callout-tip
### Try it out
::: panel-tabset
#### Problem

Generate 100 draws from a standard normal distribution and calculate the mean. 

In R, simulate from a normal distribution with `rnorm`. 
In python, use `np.random.normal` - you'll have to `import numpy as np` first.


Use 3 approaches:
1. Store the data in a variable, then calculate the mean of the variable
2. Calculate the mean of the data by nesting the two functions (e.g. `mean(generate_normal(100))` in pseudocode)
3. Calculate the mean of the data using the pipe (e.g. `generate_normal(100) |> mean()`)

**Consider**: What are the advantages and disadvantages of each approach? Would your answer change if there were more steps/functions required to get to the right answer?


#### R solution

```{r pipe-intro}
data <- rnorm(100)
mean(data)

mean(rnorm(100))

library(magrittr) # load the pipe %>%

rnorm(100) %>%
  mean()

rnorm(100) |> mean()
```

#### Python solution
In python, task 3 isn't really possible, because of the way Python function chaining works, but task 2 is basically the equivalent.

```{python pipe-not-necessary-py, collapse = T}
import numpy as np
import pandas as pd

nums = pd.Series(np.random.normal(size = 100))
nums.mean()

np.random.normal(size=100).mean()
```

The conclusion here is that it's far easier to not use the pipe in python because the `.function` notation that python uses mimics the step-by-step approach of pipes in R even without using the actual pipe function. 
When you use data frames instead of Series, you *might* start using the pipe, but only in some circumstances - with user-defined functions, instead of **methods**. 
Methods are functions that are attached to a data type (technically, a class) and only work if they are defined for that class - for instance, `.mean()` is defined for both Pandas series and numpy arrays.

:::
:::

## Libraries



<!-- ## References  {#sec-using-functions-refs} -->

