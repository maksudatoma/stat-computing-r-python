[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Statistical Computing using R and Python",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Statistical Computing using R and Python",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThe cover of this book is an amalgam of different images by the lovely @allison_horst, which are released under the cc-by 4.0 license. I have modified them to remove most of the R package references and arrange them to represent the topics covered in this book.\nLaptop icon used in the tab/logo created by Good Ware - Flaticon\nThroughout this book, I have borrowed liberally from other online tutorials, published books, and blog posts. I have tried to ensure that I link to the source material throughout the book and provide appropriate credit to anyone whose examples I have used, modified, or repurposed. Special thanks to the tutorials provided by Posit/RStudio and the tidyverse project."
  },
  {
    "objectID": "how-to-use.html#content-overload",
    "href": "how-to-use.html#content-overload",
    "title": "How to Use This Book",
    "section": "Content Overload!",
    "text": "Content Overload!\nThis book is designed to demonstrate introductory statistical programming concepts and techniques. It is intended as a substitute for hours and hours of video lectures - watching someone code and talk about code is not usually the best way to learn how to code. It’s far better to learn how to code by … coding.\nI hope that you will work through this book week by week over the semester. I have included comics, snark, gifs, YouTube videos, extra resources, and more: my goal is to make this a collection of the best information I can find on statistical programming.\nIn most cases, this book includes way more information than you need. Everyone comes into this class with a different level of computing experience, so I’ve attempted to make this book comprehensive. Unfortunately, that means some people will be bored and some will be overwhelmed. Use this book in the way that works best for you - skip over the stuff you know already, ignore the stuff that seems too complex until you understand the basics. Come back to the scary stuff later and see if it makes more sense to you."
  },
  {
    "objectID": "how-to-use.html#book-format-guide",
    "href": "how-to-use.html#book-format-guide",
    "title": "How to Use This Book",
    "section": "Book Format Guide",
    "text": "Book Format Guide\nI’ve made an effort to use some specific formatting and enable certain features that make this book a useful tool for this class.\n\nButtons/Links\nThe book contains a number of features which should help you navigate, use, improve, and respond to the textbook.\n\n\n\nTextbook features, menus, and interactive options\n\n\n\n\nSpecial Sections\n\n\n\n\n\n\nWarnings\n\n\n\nThese sections contain things you may want to look out for: common errors, mistakes, and unfortunate situations that may arise when programming.\n\n\n\n\n\n\n\n\nDemonstrations\n\n\n\nThese sections demonstrate how the code being discussed is used (in a simple way).\n\n\n\n\n\n\n\n\nExamples\n\n\n\nThese sections contain illustrations of the concepts discussed in the chapter. Don’t skip them, even though they may be long!\n\n\n\n\n\n\n\n\nTry it out\n\n\n\nThese sections contain activities you should do to reinforce the things you’ve just read. You will be much more successful if you read the material, review the example, and then try to write your own code. Most of the time, these sections will have a specific format:\n\nProblemR SolutionPython Solution\n\n\nThe problem will be in the first tab for you to start with\n\n\nA solution will be provided in R, potentially with an explanation.\n\n\nA solution will be provided in Python as well.\n\n\n\nIn some cases, the problem will be more open-ended and may not adhere to this format, but most try it out sections in this book will have solutions provided. I highly recommend that you attempt to solve the problem yourself before you look at the solutions - this is the best way to learn. Passively reading code does not result in information retention.\n\n\n\n\n\n\n\n\nEssential Reading\n\n\n\nThese sections may direct you to additional reading material that is essential for understanding the topic. For instance, I will sometimes link to other online textbooks rather than try to rehash the content myself when someone else has done it better.\n\n\n\n\n\n\n\n\nLearn More\n\n\n\nThese sections will direct you to additional resources that may be helpful to consult as you learn about a topic. You do not have to use these sections unless you are 1) bored, or 2) hopelessly lost. They’re provided to help but are not expected reading (Unlike the essential reading sections in red).\n\n\n\n\n\n\n\n\nNotes\n\n\n\nThese generic sections contain information I may want to call attention to, but that isn’t necessarily urgent or a common error trap.\n\n\n\n\n\n\n\n\nAdvanced\n\n\n\nThese sections are intended to apply to more advanced courses. If you are taking an introductory course, feel free to skip that content for now.\n\n\n\nExpandable Sections\n\n\nThese are expandable sections, with additional information when you click on the line\n\nThis additional information may be information that is helpful but not essential, or it may be that an example just takes a LOT of space and I want to make sure you can skim the book without having to scroll through a ton of output.\n\n\n\n\n\n\n\nAnother type of expandable note\n\n\n\n\n\nAnswers or punchlines may be hidden in this type of expandable section as well."
  },
  {
    "objectID": "part-tools/00-tools-intro.html",
    "href": "part-tools/00-tools-intro.html",
    "title": "Part I: Tools",
    "section": "",
    "text": "This part of the textbook provides an overview of the different tools we will be using: R, python, quarto, markdown, pandoc, consoles, and so on. It can be a bit confusing at first, especially if you’re not familiar with how your computer works, where files are stored, and different ways to tell your computer what to do.\nChapter 1 gives you some important background material about how a computer functions.\nChapter 2 tells you exactly what software you need to install for the rest of this textbook.\nChapter 3 discusses the different ways we can talk to R and python, and the pros and cons of each."
  },
  {
    "objectID": "part-tools/01-computer-basics.html#objectives",
    "href": "part-tools/01-computer-basics.html#objectives",
    "title": "1  Computer Basics",
    "section": "1.1 Objectives",
    "text": "1.1 Objectives\n\nKnow the meaning of computer hardware and operating system terms such as hard drive, memory, CPU, OS/operating system, file system, directory, and system paths\nUnderstand the basics of how the above concepts relate to each other and contribute to how a computer works\nUnderstand the file system mental model for computers"
  },
  {
    "objectID": "part-tools/01-computer-basics.html#hardware",
    "href": "part-tools/01-computer-basics.html#hardware",
    "title": "1  Computer Basics",
    "section": "1.2 Hardware",
    "text": "1.2 Hardware\nHere is a short 3-minute video on the basic hardware that makes up your computer. It is focused on desktops, but the same components (with the exception of the optical drive) are commonly found in cell phones, smart watches, and laptops.\n\n\n\n\nWhen programming, it is usually helpful to understand the distinction between RAM and disk storage (hard drives). We also need to know at least a little bit about processors (so that we know when we’ve asked our processor to do too much). Most of the other details aren’t necessary (for now).\n\n\nChapter 1 of Python for Everybody - Computer hardware architecture"
  },
  {
    "objectID": "part-tools/01-computer-basics.html#operating-systems",
    "href": "part-tools/01-computer-basics.html#operating-systems",
    "title": "1  Computer Basics",
    "section": "1.3 Operating Systems",
    "text": "1.3 Operating Systems\nOperating systems, such as Windows, MacOS, or Linux, are a sophisticated program that allows CPUs to keep track of multiple programs and tasks and execute them at the same time."
  },
  {
    "objectID": "part-tools/01-computer-basics.html#file-systems",
    "href": "part-tools/01-computer-basics.html#file-systems",
    "title": "1  Computer Basics",
    "section": "1.4 File Systems",
    "text": "1.4 File Systems\n\nFor this class, it will probably be important to distinguish between local file storage (C:/ drive , /user/your-name/ , or /home/your-name/ ) and network/virtual file systems, such as OneDrive and iCloud. Over time, it has become harder to ensure that you are working on a local machine, but working “in the cloud” can cause odd errors when programming and in particular when working with version control systems1.\nYou want to save your files in this class to your physical hard drive. This will save you a lot of troubleshooting time.\n\nEvidently, there has been a bit of generational shift as computers have evolved: the “file system” metaphor itself is outdated because no one uses physical files anymore. This article [1] is an interesting discussion of the problem: it makes the argument that with modern search capabilities, most people use their computers as a laundry hamper instead of as a nice, organized filing cabinet.\nRegardless of how you tend to organize your personal files, it is probably helpful to understand the basics of what is meant by a computer file system – a way to organize data stored on a hard drive. Since data is always stored as 0’s and 1’s, it’s important to have some way to figure out what type of data is stored in a specific location, and how to interpret it.\n\n\n\n\nThat’s not enough, though - we also need to know how computers remember the location of what is stored where. Specifically, we need to understand file paths.\n\n\n\n\nWhen you write a program, you may have to reference external files - data stored in a .csv file, for instance, or a picture. Best practice is to create a file structure that contains everything you need to run your entire project in a single file folder (you can, and sometimes should, have sub-folders).\nFor now, it is enough to know how to find files using file paths, and how to refer to a file using a relative file path from your base folder. In this situation, your “base folder” is known as your working directory - the place your program thinks of as home."
  },
  {
    "objectID": "part-tools/01-computer-basics.html#system-paths",
    "href": "part-tools/01-computer-basics.html#system-paths",
    "title": "1  Computer Basics",
    "section": "1.5 System Paths",
    "text": "1.5 System Paths\nWhen you install software, it is saved in a specific location on your computer, like C:/Program Files/ on , /Applications/ on , or /usr/local/bin/ on . For the most part, you don’t need to keep track of where programs are installed, because the install process (usually) automatically creates icons on your desktop or in your start menu, and you find your programs there.\nUnfortunately, that isn’t sufficient when you’re programming, because you may need to know where a program is in order to reference that program – for instance, if you need to pop open a browser window as part of your program, you’re (most likely) going to have to tell your computer where that browser executable file lives.\nTo simplify this process, operating systems have what’s known as a “system path” or “user path” - a list of folders containing important places to look for executable and other important files. You may, at some point, have to edit your system path to add a new folder to it, making the executable files within that folder more easily available.\n\n\n\n\n\n\nHow To Modify System Paths\n\n\n\n\n\nHow to set system paths (general)\nOperating-system specific instructions cobbled together from a variety of different sources:\n\n On Windows\n On Mac\n On Linux\n\n\n\n\nIf you run across an error that says something along the lines of\n\ncould not locate xxx.exe\nThe system cannot find the path specified\nCommand Not Found\n\nyou might start thinking about whether your system path is set correctly for what you’re trying to do.\nIf you want to locate where an executable is found (in this example, we’ll use git), you can run where git on windows, or which git on OSX/Linux.\nSome programs, like RStudio, have places where you can set the locations of common dependencies. If you go to Tools > Global Options > Git/SVN, you can set the path to git."
  },
  {
    "objectID": "part-tools/01-computer-basics.html#part-tools-01-refs",
    "href": "part-tools/01-computer-basics.html#part-tools-01-refs",
    "title": "1  Computer Basics",
    "section": "1.6 References",
    "text": "1.6 References\n\n\n\n\n[1] D. Robitzski, “Gen z kids apparently don’t understand how file systems work. Futurism,” Sep. 24, 2021. [Online]. Available: https://futurism.com/the-byte/gen-z-kids-file-systems. [Accessed: Jan. 09, 2023]"
  },
  {
    "objectID": "part-tools/02-setting-up-computer.html#objectives",
    "href": "part-tools/02-setting-up-computer.html#objectives",
    "title": "2  Setting Up Your Computer",
    "section": "\n2.1 Objectives",
    "text": "2.1 Objectives\n\nSet up RStudio, R, Quarto, and python\nBe able to run demo code in R and python"
  },
  {
    "objectID": "part-tools/02-setting-up-computer.html#installation-process",
    "href": "part-tools/02-setting-up-computer.html#installation-process",
    "title": "2  Setting Up Your Computer",
    "section": "\n2.2 Installation Process",
    "text": "2.2 Installation Process\nIn this section, I will provide you with links to set up various programs on your own machine. If you have trouble with these instructions or encounter an error, post on the class message board or contact me for help.\n\n\nDownload and run the R installer for your operating system from CRAN:\n\nWindows: https://cran.rstudio.com/bin/windows/base/\nMac: https://cran.rstudio.com/bin/macosx/\nLinux: https://cran.rstudio.com/bin/linux/ (pick your distribution)\n\nIf you are on Windows, you should also install the Rtools4 package; this will ensure you get fewer warnings later when installing packages.\nMore detailed instructions for Windows are available here\n\n\nDownload and install the latest version of python 3\n\nThen, install Jupyter using the instructions here\nAdditional instructions for installing Python 3 from Python for Everybody if you have trouble.\n\n\nDownload and install the latest version of RStudio for your operating system. RStudio is a integrated development environment (IDE) for R - it contains a set of tools designed to make writing R code easier.\nDownload and install the latest version of Quarto for your operating system. Quarto is a command-line tool released by RStudio that allows Rstudio to work with python and other R specific tools in a unified way.\n\nThe following steps may be necessary depending on which class you’re in. If you want to be safe, go ahead and complete these steps as well.\n\nInstall git using the instructions here. Consult the troubleshooting guide if you have issues. If that fails, then seek help in office hours.\n\nInstall LaTeX and rmarkdown:\n\nLaunch R, and type the following commands into the console:\n\n\n\n\ninstall.packages(c(\"tinytex\", \"knitr\", \"rmarkdown\", \"quarto\"))\nlibrary(tinytex)\ninstall_tinytex()\n\n\n\n\n\n\n\nYour turn\n\n\n\nOpen RStudio on your computer and explore a bit.\n\nCan you find the R console? Type in 2+2 to make sure the result is 4.\nRun the following code in the R console:\n\ninstall.packages(\n  c(\"tidyverse\", \"rmarkdown\", \"knitr\", \"quarto\")\n)\n\nCan you find the text editor?\n\nCreate a new quarto document (File -> New File -> Quarto Document).\nPaste in the contents of this document.\nCompile the document (Ctrl/Cmd + Shift + K) and use the Viewer pane to see the result.\nIf this all worked, you have RStudio, Quarto, R, and Python set up correctly on your machine."
  },
  {
    "objectID": "part-tools/03-scripts-notebooks.html#objectives",
    "href": "part-tools/03-scripts-notebooks.html#objectives",
    "title": "3  Scripts and Notebooks",
    "section": "\n3.1 Objectives",
    "text": "3.1 Objectives\n\nUnderstand the different modes that can be used to interact with a programming language\nIdentify which mode and language is being used given a screenshot or other contextual information\nSelect the appropriate mode (interactive, script, notebook) for a given task given considerations such as target audience, human intervention, and need to repeat the analysis."
  },
  {
    "objectID": "part-tools/03-scripts-notebooks.html#a-short-history-of-talking-to-computers",
    "href": "part-tools/03-scripts-notebooks.html#a-short-history-of-talking-to-computers",
    "title": "3  Scripts and Notebooks",
    "section": "\n3.2 A Short History of Talking to Computers",
    "text": "3.2 A Short History of Talking to Computers\nThe fundamental goal of this chapter is to learn how to talk to R and Python. In the very beginning, people told computers what to do using punch cards [1]. This required that you have every step of your program and data planned out in advance - you’d submit your punch cards to the computer, and then come back 24-72 hours later to find out you’d gotten two cards out of order. Dropping a tray of punch cards was … problematic.\nThankfully, we’re mostly free of the days where being a bit clumsy could erase a semester of hard work. As things grew more evolved and we got actual monitors and (eventually) graphical interfaces, we started using interactive terminals (interactive mode) to boss computers around.\n\n\n\n\n\n\nYour Turn - Interactive Mode\n\n\n\n\n\nR\nPython\n\n\n\nOpen RStudio and navigate to the Console tab. You can issue commands directly to R by typing something in at the > prompt.\nTry typing in 2+2 and hit enter.\n\n\nOpen RStudio and navigate to the Terminal tab. This is your computer’s ‘terminal’ - where you tell the computer what to do.\nFirst, we have to tell it what language we’d like to work in - by default, it’s going to work in  Batch (Windows),  Zsh (Mac), or  Bash (Linux). Luckily, we can avoid these and tell the computer we want to work in python by typing in python3 or python (depending on how your computer is set up). This will launch an interactive python session (ipython).\nYou should get a prompt that looks like this: >>>\nType in 2+2 and hit enter.\n\n\n\n\n\nInteractive mode is useful for quick, one-off analyses, but if you need to repeat an analysis (or remember what you did), interactive mode is just awful. Once you close the program, the commands (and results) are gone. This is particularly inconvenient when you need to run the same task multiple times. For example, each day I may want to pull the weather forecast and observed weather values from the national weather service using the same commands. I don’t want to manually re-type them each day!\nTo somewhat address this issue, most computing languages allow you to provide a sequence of commands in a text file known as a script. Scripts are typically meant to run on their own - they may perform computations, format data and save it, scrape data from the web… the possibilities are endless, but they are typically meant to run without the person running the script having to read all of the commands.\n\n\n\n\n\n\nYour Turn - Script Mode\n\n\n\n\nDownload scripts.zip and unzip the file.\nOpen a system terminal in the directory where you unzipped the files.\n\n\n\n Windows\n Mac\n Linux\n\n\n\nOpen the folder. Type cmd into the location bar at the top of the window and hit enter. The command prompt will open in the desired location.\n\n\nOpen a finder window and navigate to the folder you want to use. If you don’t have a path bar at the bottom of the finder window, choose View > Show Path Bar. Control-click the folder in the path bar and choose Open in Terminal.\n\n\nOpen the folder in your file browser. Select the path to the folder in the path bar and copy it to the clipboard. Launch a terminal and type cd, and then paste the copied path. Hit enter. (There may be more efficient ways to do this, but these instructions work for most window managers).\n\n\n\n\nNow, let’s try out script mode in R and Python!\n\n\n\nR\nPython\n\n\n\nThis assumes that the R binary has been added to your system path. If these instructions don’t work, please ask for help or visit office hours.\nIn the terminal, type Rscript words.R dickens-oliver-twist.txt\nYou should get some output that looks like this:\nuser@computer:~/scripts$ Rscript words.R dickens-oliver-twist.txt \ntext\n the  and        to   of    a  his   in   he  was \n8854 4902 4558 3767 3763 3569 2272 2224 1931 1684\n\n\nThis assumes that the python binary has been added to your system path. If these instructions don’t work, please ask for help or visit office hours.\nIn the terminal, type python3 words.py and hit Enter. You will be prompted for the file name. Enter dickens-oliver-twist.txt and hit Enter again.\nYou should get some output that looks like this:\nuser@computer:~/scripts$ python3 words.py \nEnter file:dickens-oliver-twist.txt\nthe 8854\n\n\n\n\n\nScripts, and compiled programs generated from scripts, are responsible for much of what you interact with on a computer or cell phone day-to-day. When the goal is to process a file or complete a task in exactly the same way each time, a script is the right choice for the job.\nHowever, when working with data, we sometimes prefer to combine scripts with interactive mode - that is, we use a script file to keep track of which commands we run, but we run the script interactively. About 60% of my day-to-day computing is done using R or python scripts that are run interactively.\n\n\n\n\n\n\nYour Turn - Interactive Scripts\n\n\n\nIf you haven’t already, download scripts.zip and unzip the file.\nOpen RStudio and use RStudio to complete the following tasks.\n\n\nR\nPython\n\n\n\n\nUse RStudio to open the words-noinput.R file in the scripts folder you downloaded and unzipped.\nWhat do you notice about the appearance of the file? Is there an icon in the tab to tell you what type of file it is? Are some words in the file highlighted?\nCopy the path to the scripts folder.\nOS Specific Instructions:  Windows,  Mac,  Linux\nIn the Console, type in setwd(\"<paste path here>\"), where you paste your file path from step 3 between the quotes. Hit enter.\nIn the words-noinput.R file, hit the “source” button in the top right. Do you get the same output that you got from running the file as a script from the terminal? Why do you think that is?\nClick on the last line of the file and hit Run (or Ctrl/Cmd + Enter). Do you get the output now?\nClick on the first line of the file and hit Run (or Ctrl/Cmd + Enter). This runs a single line of the file. Use this to run each line of the file in turn. What could you learn from doing this?\n\n\n\n\nUse RStudio or your preferred python editor to open the words-noinput.py file in the scripts folder you downloaded and unzipped.\nWhat do you notice about the appearance of the file? Is there an icon in the tab to tell you what type of file it is? Are some words in the file highlighted?\nCopy the path to the scripts folder.\nOS Specific Instructions:  Windows,  Mac,  Linux\nIn the Console, type in setwd(\"<paste path here>\"), where you paste your file path from step 3 between the quotes. Hit enter.\nIn the words-noinput.py file, hit the “source” button in the top right. Do you get the same output that you got from running the file as a script from the terminal? What changes?\nClick on the first line of the file and hit Run (or Ctrl/Cmd + Enter). This runs a single line of the file. Use this to run each line of the file in turn. What do you learn from doing this?\n\n\n\n\n\n\nUsing scripts interactively allows us to see what is happening in the script step-by-step, and to examine the results during the program’s evaluation. This can be beneficial when applying a script to a new dataset, because it allows us to change things on the fly while still keeping the same basic order of operations."
  },
  {
    "objectID": "part-tools/03-scripts-notebooks.html#writing-code-for-people",
    "href": "part-tools/03-scripts-notebooks.html#writing-code-for-people",
    "title": "3  Scripts and Notebooks",
    "section": "\n3.3 Writing Code for People",
    "text": "3.3 Writing Code for People\nOne problem with scripts and interactive modes of using programming languages is that we’re spending most of our time writing code for computers to read – which doesn’t necessarily imply that our code is easy for humans to read.\nThere are two solutions to this problem, and I encourage you to make liberal use of both of them (together).\n\n3.3.1 Code Comments\nA comment is a part of computer code which is intended only for people to read. It is not evaluated or run by the computing language.\nTo “comment out” a single line of code in R or python, put a # (pound sign/hashtag) just before the part of the code you do not want to be evaluated.\n\n\n\n\n\n\nExample: Comments\n\n\n\n\n\nR\nPython\n\n\n\n\n2 + 2 + 3\n\n[1] 7\n\n2 + 2 # + 3\n\n[1] 4\n\n# This line is entirely commented out\n\n\n\n\n2 + 2 + 3\n\n7\n\n2 + 2 # + 3\n# This line is entirely commented out\n\n4\n\n\n\n\n\n\n\nMany computing languages, such as Java, C/C++, and JavaScript have mechanisms to comment out an entire paragraph. Neither R nor Python has so-called “block comments” - instead, you can use keyboard shortcuts in RStudio to comment out an entire chunk of code (or text) using Ctrl/Cmd-Shift-C.\n\n3.3.2 Literate Programming - Notebooks and more!\nWhile code comments add human-readable text to code, scripts with comments are still primarily formatted for the computer’s convenience. However, most of the time spent on any given document is spent by people, not by computers. We often write parallel documents - user manuals, academic papers, tutorials, etc. which explain the purpose of our code and how to use it, but this can get clumsy over time, and requires updating multiple documents (sometimes in multiple places), which often leads to the documentation getting out-of-sync from the code.\nTo solve this problem, Donald Knuth invented the concept of literate programming: interspersing text and code in the same document using structured text to indicate which lines are code and which lines are intended for human consumption.\nThis textbook is written using a literate format - quarto markdown - which allows me to include code chunks in R, python, and other languages, alongside the text, pictures, and other formatting necessary to create a textbook.\n\n3.3.2.1 Quarto\nOne type of literate programming document is a quarto markdown document.\nWe will use quarto markdown documents for most of the components of this class because they allow you to answer assignment questions, write reports with figures and tables generated from data, and provide code all in the same file.\nWhile literate documents aren’t ideal for jobs where a computer is doing things unobserved (such as pulling data from a web page every hour), they are extremely useful in situations where it is desireable to have both code and an explanation of what the code is doing and what the results of that code are in the same document.\n\n\n\n\n\n\nYour turn: Quarto Markdown\n\n\n\nIn RStudio, create a new quarto markdown document: File > New File > Quarto Document. Give your document a title and an author, and select HTML as the output.\nCopy the following text into your document and hit the “Render” button at the top of the file.\nThis defines an R code chunk. The results will be included in the compiled HTML file.\n\n```{r}\n2 + 2 \n```\n\nThis defines a python code chunk. The results will be included in the compiled HTML file.\n\n```{python}\n2 + 2\n```\n\n# This is a header\n\n## This is a subheader\n\nI can add paragraphs of text, as well as other structured text such as lists:\n\n1. First thing\n2. Second thing\n  - nested list\n  - nested list item 2\n3. Third thing\n\nI can even include images and [links](https://www.oldest.org/entertainment/memes/)\n\n![Goodwin's law is almost as old as the internet itself.](https://www.oldest.org/wp-content/uploads/2017/10/Godwins-Law.jpg)\n\n\nMarkdown is a format designed to be readable and to allow document creators to focus on content rather than style.\n\nA Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. – John Gruber\n\nYou can read more about pandoc markdown (and quarto markdown, which is a specific type of pandoc markdown) here [2].\nMarkdown documents are compiled into their final form (usually, HTML, PDF, Docx) in multiple stages: 1. All code chunks are run and the results are saved and inserted into the markdown document.\nRmd/qmd -> md\n\nThe markdown document is converted into its final format using pandoc, a program that is designed to ensure you can generate almost any document format. This may involve conversion to an intermediate file (e.g. .tex files for PDF documents).\n\nAn error in your code will likely cause a failure at stage 1 of the process. An error in the formatting of your document, or missing pictures, and miscellaneous other problems may cause errors in stage 2.\n\n\n\n\n\n\nHistory\n\n\n\nQuarto markdown is the newest version of a long history of literate document writing in R. A previous version, Rmarkdown, had to be compiled using R; quarto can be compiled using R or python or the terminal directly.\nPrior to Rmarkdown, the R community used knitr and Sweave to integrate R code with LaTeX documents (another type of markup document that has a steep learning curve and is harder to read).\n\n\n\n3.3.2.2 Jupyter\nWhere quarto comes primarily out of the R community and those who are agnostic whether R or Python is preferable for data science related computing, Jupyter is essentially an equivalent notebook technology that comes from the python side of the world.\nQuarto supports using the jupyter engine for chunk compilation, but jupyter notebooks have some (rather technical) features that make them less desirable for an introductory computing class [3].\n\n\n\n\n\n\nLearn More about Notebooks\n\n\n\nThere are some excellent opinions surrounding the use of notebooks in data analysis:\n\n\nWhy I Don’t Like Notebooks” by Joel Grus at JupyterCon 2018\n\nThe First Notebook War by Yihui Xie (response to Joel’s talk).\n\nYihui Xie is the person responsible for knitr and Rmarkdown and was involved in the development of quarto."
  },
  {
    "objectID": "part-tools/03-scripts-notebooks.html#part-tools-03-refs",
    "href": "part-tools/03-scripts-notebooks.html#part-tools-03-refs",
    "title": "3  Scripts and Notebooks",
    "section": "\n3.4 References",
    "text": "3.4 References\n\n\n\n\n[1] \n\n“Punched card input/output.” Jan. 08, 2023 [Online]. Available: https://en.wikipedia.org/w/index.php?title=Punched_card_input/output&oldid=1132250858\n\n\n\n[2] \nPosit PBC, “Quarto - markdown basics,” 2023. [Online]. Available: https://quarto.org/docs/authoring/markdown-basics.html. [Accessed: Jan. 09, 2023]\n\n\n[3] \nY. Xie, “The first notebook war,” Sep. 10, 2018. [Online]. Available: https://yihui.org/en/2018/09/notebook-war/. [Accessed: Jan. 09, 2023]"
  },
  {
    "objectID": "part-tools/04-Rstudio-interface.html#objectives",
    "href": "part-tools/04-Rstudio-interface.html#objectives",
    "title": "4  RStudio’s Interface",
    "section": "4.1 Objectives",
    "text": "4.1 Objectives\n\nLocate different panes of RStudio\nUse cues such as buttons and icons to identify what type of file is open and what language is being interpreted"
  },
  {
    "objectID": "part-tools/04-Rstudio-interface.html#overview",
    "href": "part-tools/04-Rstudio-interface.html#overview",
    "title": "4  RStudio’s Interface",
    "section": "4.2 Overview",
    "text": "4.2 Overview\n An RStudio window is by default divided into 4 panes, each of which may contain several tabs. You can reconfigure the locations of these tabs based on your preferences by selecting the toolbar button with 4 squares (just left of the Addins dropdown menu).\nIn the default configuration, - The top left is the editor pane, where you will write code and other content. - The bottom left is the console pane, which contains your R/python interactive consoles as well as a system terminal and location for checking the status of background jobs. - The top right contains the environment and history tabs (among others) - The top left contains the files and help tabs (among others)\nYou do not need to know what all of these tabs do right now. For the moment, it’s enough to get a sense of the basics - where to write code (top left), where to look for results (bottom left), where to get help (bottom right), and where to monitor what R/python are doing (top right)."
  },
  {
    "objectID": "part-tools/04-Rstudio-interface.html#the-editorfile-pane-top-left",
    "href": "part-tools/04-Rstudio-interface.html#the-editorfile-pane-top-left",
    "title": "4  RStudio’s Interface",
    "section": "4.3 The Editor/File Pane (Top Left)",
    "text": "4.3 The Editor/File Pane (Top Left)\nThe buttons and layout within this pane change based on the type of file you have open.\n\nR scriptPython scriptQuarto markdownText file\n\n\n\n\n\nThe logo on the script file indicates the file type. When an R file is open, there are Run and Source buttons on the top which allow you to run selected lines of code (Run) or source (run) the entire file. Code line numbers are provided on the left (this is a handy way to see where in the code the errors occur), and you can see line:character numbers at the bottom left. At the bottom right, there is another indicator of what type of file Rstudio thinks this is.\n\n\n\n\n\n\n\nThe logo on the script file indicates the file type. When a python file is open, there are Run and Source buttons on the top which allow you to run selected lines of code (Run) or source (run) the entire file. Code line numbers are provided on the left (this is a handy way to see where in the code the errors occur), and you can see line:character numbers at the bottom left. At the bottom right, there is another indicator of what type of file Rstudio thinks this is.\n\n\n\n\n\n\n\nThe logo on the script file indicates the file type. When a quarto markdown file is open, there is a render button at the top which allows you to compile the file to see its “pretty”, non-markup form. In the same toolbar, there are buttons to add a code chunk as well as to run a selcted line of code or chunk of code. You can toggle between source (shown) and visual mode to see a more word-like rendering of the quarto markdown file. Code line numbers are provided on the left (this is a handy way to see where in the code the errors occur), and you can see line:character numbers at the bottom left. At the bottom right, there is another indicator of what type of file Rstudio thinks this is.\n\n\n\n\n\n\n\nThe logo on the text file indicates the file type. When a text file (or other unknown file extension) is open, there are very few buttons in the editor window. Code line numbers are provided on the left (this is a handy way to see where in the code the errors occur), and you can see line:character numbers at the bottom left. At the bottom right, there is another indicator of what type of file Rstudio thinks this is."
  },
  {
    "objectID": "part-tools/04-Rstudio-interface.html#the-console-pane-bottom-left",
    "href": "part-tools/04-Rstudio-interface.html#the-console-pane-bottom-left",
    "title": "4  RStudio’s Interface",
    "section": "4.4 The Console Pane (Bottom Left)",
    "text": "4.4 The Console Pane (Bottom Left)\nLet’s compare what the console pane looks like when we run a line of R code compared to a line of python code. The differences will help you figure out whether you need to exit out of Python to run R code and may help you debug some errors.\n\nPythonR\n\n\n\n\n\nWhen running python code from a script file, the console will show you that you are running in python by the logo at the top of the console pane. You will initially see lines indicating that you’re running R, and then you’ll see the lines highlighted in red which show R running the code in python – this is what converts the console from R to python. The command you ran will appear after >>>, and the results will appear immediately below. A >>> waits for a new command - to get back to R, you will need to type exit (as instructed by the red text). In the environment pane, you cna see another indicator that you’re viewing the python environment, with an object named ‘r’ that will allow you to move data back and forth between the two languages if you want to do so.\n\n\n\n\n\n\n\nWhen running R code from a script file, the console will show you that you are running in R by the logo at the top of the console pane. You will initially see lines indicating that you’re running R (they’re missing here because this isn’t the first command I ran in this session). The command you ran will appear after >, and the results will appear immediately below, with boxed numbers in front of each sequential line. A > waits for a new command . In the environment pane, you may see a new value pop up named .Last.value - this is part of user settings and you can stop it from appearing if you want to."
  },
  {
    "objectID": "part-tools/04-Rstudio-interface.html#the-top-right-pane",
    "href": "part-tools/04-Rstudio-interface.html#the-top-right-pane",
    "title": "4  RStudio’s Interface",
    "section": "4.5 The Top Right Pane",
    "text": "4.5 The Top Right Pane\nThis pane contains a set of tabs that change based on your project and what you have enabled. If you’re using git with an Rstudio project, then this tab will show your git repository. If you’re working with an Rstudio project that has multiple files, such as a book or a website, then the pane will also have a Build tab that will build all of your project files.\nFor now, though, let’s assume you’re not in an Rstudio project and you just want to know what the heck an Environment pane (or any of the other tabs in here by default) is. We’re going to focus on two of the tabs that are the most relevant to you right now: Environment, and History.\n\n4.5.1 Environment tab\nThe Environment tab shows you any objects which are defined in memory in whatever language you’re currently using (as long as it’s R or python). You’ll see headers like “Data”, “Values”, and “Functions” within this table, and two columns - the name of the thing, and the value of the thing (if it’s a complicated object, you’ll see what type of object it is and possibly how long it is).\n\n\n\nThe environment tab shows you all of the objects in memory that the language you’re working in knows about.\n\n\nIf you’re working in both R and python, you can toggle which language’s environment you’re looking at using the language drop down button on the far left side.\n\n\n4.5.2 History tab\nAnother useful tab in this pane is the History tab, which shows you a running list of every command you’ve ever run. While I strongly encourage you to write your code in a text file in the editor pane, sometimes you deleted a line of code accidentally and want to get it back… and the history tab has you covered (unless you’ve cleared the history out).\n\n\n\nThe history tab shows you a list of all commands you’ve run and allows you to send them to the console or to source (the text editor)."
  },
  {
    "objectID": "part-tools/04-Rstudio-interface.html#the-bottom-right-pane",
    "href": "part-tools/04-Rstudio-interface.html#the-bottom-right-pane",
    "title": "4  RStudio’s Interface",
    "section": "4.6 The Bottom Right Pane",
    "text": "4.6 The Bottom Right Pane\nThis pane also contains a mishmash of tabs that have various uses. Here, we’ll focus on 3: Files, Packages, and Help. But first, to quickly summarize the remaining tabs, the Plots tab shows any plots you’ve generated (which we haven’t done yet), and the Viewer/Presentation tabs show you compiled documents (markdown), interactive graphics, and presentations.\n\n4.6.1 Files tab\n\n\n\nThe files tab shows you the files in your current working directory (by default), though you can navigate through it and find other files as necessary. If you want to return to your working directory, there’s a button for that in the “More” menu. One of the most important pieces of information in this pane is your path - you can construct the file path by using ~/ for home, and then for each folder, adding a slash between. The path to the folder we’re looking at here is thus ~/Projects/Class/stat-computing-r-python/.\n\n\n\n\n4.6.2 Packages tab\nThe packages tab isn’t quite relevant yet, but it will be soon. R and python both work off of packages - extensions to the default language that make it easier to accomplish certain tasks, like reading data from Excel files or drawing pretty charts. This tab shows all of the R packages you have installed on your machine, and which ones are currently loaded.\n\n\n\nYou can get important information from the packages tab, like what packages are loaded, easy access to documentation for each package, and what version of the package is installed.\n\n\nUnfortunately, the packages tab doesn’t cover python packages yet.\n\n\n4.6.3 Help tab\nThe help tab is a wonderful way to get help with how to use an R or python function.\n\n\n\nThe help tab makes it easy to get access to function documentation within Rstudio, so you don’t have to switch windows.\n\n\nBy default, you can search for an R function name in the search window, and documentation for matching functions will appear in the main part of the pane. To get help with python functions, you need to (in the python console) use ?<function name, so I would type in at the >>> prompt ?print to get the equivalent python help file."
  },
  {
    "objectID": "part-tools/05-git-and-github.html#objectives",
    "href": "part-tools/05-git-and-github.html#objectives",
    "title": "5  Version Control with Git",
    "section": "\n5.1 Objectives",
    "text": "5.1 Objectives\n\nInstall git\nCreate a github account\nUnderstand why version control is useful and what problems it can solve\nUnderstand the distinction between git and github, and what each is used for\nUse version control to track changes to a document (git add, commit, push, pull)"
  },
  {
    "objectID": "part-tools/05-git-and-github.html#installation",
    "href": "part-tools/05-git-and-github.html#installation",
    "title": "5  Version Control with Git",
    "section": "\n5.2 Installation",
    "text": "5.2 Installation\n\nInstall git using the instructions here.\n\nConsult the troubleshooting guide if you have issues.\nIf 1-2 fail, seek help in office hours.\n\n\n\n\n\n\n\n Mac Warning\n\n\n\nWith each version upgrade, you may find that git breaks. To fix it, you will have to reinstall Mac command line tools. Once you do this, git will start working again. See [2] for more information.\n\n\n\n5.2.1 Optional: Install a git client\nInstructions\nI don’t personally use a git client other than RStudio, but you may prefer to have a client that allows you to use a point-and-click interface. It’s up to you."
  },
  {
    "objectID": "part-tools/05-git-and-github.html#what-is-version-control",
    "href": "part-tools/05-git-and-github.html#what-is-version-control",
    "title": "5  Version Control with Git",
    "section": "\n5.3 What is Version Control ?",
    "text": "5.3 What is Version Control ?\n\n\n\n\n\n\nNote\n\n\n\nMost of this section is either heavily inspired by Happy Git and Github for the UseR [1] or directly links to that book.\n\n\n\n\n\nGit is a version control system - a structured way for tracking changes to files over the course of a project that may also make it easy to have multiple people working on the same files at the same time.\n\n\nVersion control is the answer to this file naming problem. Image Source “Piled Higher and Deeper” by Jorge Cham www.phdcomics.com\n\n\nGit manages a collection of files in a structured way - rather like “track changes” in Microsoft Word or version history in Dropbox, but much more powerful.\nIf you are working alone, you will benefit from adopting version control because it will remove the need to add _final.R to the end of your file names. However, most of us work in collaboration with other people (or will have to work with others eventually), so one of the goals of this program is to teach you how to use git because it is a useful tool that will make you a better collaborator.\nIn data science programming, we use git for a similar, but slightly different purpose. We use it to keep track of changes not only to code files, but to data files, figures, reports, and other essential bits of information.\nGit itself is nice enough, but where git really becomes amazing is when you combine it with GitHub - an online service that makes it easy to use git across many computers, share information with collaborators, publish to the web, and more. Git is great, but GitHub is … essential. In this class, we’ll be using both git and github, and your homework will be managed with GitHub Classroom.\n\n5.3.1 Git Basics\n\n\nIf that doesn’t fix it, git.txt contains the phone number of a friend of mine who understands git. Just wait through a few minutes of ‘It’s really pretty simple, just think of branches as…’ and eventually you’ll learn the commands that will fix everything. Image by Randall Munroe (XKCD) CC-A-NC-2.5.\n\n\nGit tracks changes to each file that it is told to monitor, and as the files change, you provide short labels describing what the changes were and why they exist (called “commits”). The log of these changes (along with the file history) is called your git commit history.\nWhen writing papers, this means you can cut material out freely, so long as the paper is being tracked by git - you can always go back and get that paragraph you cut out if you need to. You also don’t have to rename files - you can confidently save over your old files, so long as you remember to commit frequently.\n\n\n\n\n\n\nEssential Reading: Git\n\n\n\nThe git material in this chapter is just going to link directly to the book “Happy Git with R” by Jenny Bryan. It’s amazing, amusing, and generally well written. I’m not going to try to do better.\nGo read Chapter 1, if you haven’t already.\n\n\nNow that you have a general idea of how git works and why we might use it, let’s talk a bit about GitHub.\n\n5.3.2 GitHub: Git on the Web\n\n\n\n\n\n\nSet up a GitHub Account Now\n\n\n\nInstructions for setting up a GitHub account.\nBe sure you remember your signup email, username, and password - you will need them later.\n\n\nGit is a program that runs on your machine and keeps track of changes to files that you tell it to monitor. GitHub is a website that hosts people’s git repositories. You can use git without GitHub, but you can’t use GitHub without git.\n\n\n\n\n\n\nGit and Github: Slightly crude (but memorable) analogy\n\n\n\n\n\nGit is to GitHub what Porn is to PornHub. Specifically, GitHub hosts git repositories publicly, while PornHub hosts porn publicly. But it would be silly to equate porn and PornHub, and it’s similarly silly to think of GitHub as the only place you can use git repositories.\n\n\n\nIf you want, you can hook Git up to GitHub, and make a copy of your local git repository that lives in the cloud. Then, if you configure things correctly, your local repository will talk to GitHub without too much trouble. Using Github with Git allows you to easily make a cloud backup of your important code, so that even if your computer suddenly catches on fire, all of your important code files exist somewhere else.\nRemember: any data you don’t have in 3 different places is data you don’t care about.1"
  },
  {
    "objectID": "part-tools/05-git-and-github.html#using-version-control-with-rstudio",
    "href": "part-tools/05-git-and-github.html#using-version-control-with-rstudio",
    "title": "5  Version Control with Git",
    "section": "\n5.4 Using Version Control (with RStudio)",
    "text": "5.4 Using Version Control (with RStudio)\nThe first skill you need to actually practice in this class is using version control. By using version control from the very beginning, you will learn better habits for programming, but you’ll also get access to a platform for collaboration, hosting your work online, keeping track of features and necessary changes, and more.\n\n\n\n\n\n\n\n\n\n\n\nSo, what does your typical git/GitHub workflow look like? I’ll go through this in (roughly) chronological order. This is based off of a relatively high-level understanding of git - I do not have any idea how it works under the hood, but I’m pretty comfortable with the clone/push/pull/commit/add workflows, and I’ve used a few of the more complicated features (branches, pull requests) on occasion.\n\n5.4.1 Introduce yourself to git and set up SSH authentication\nYou need to tell git what your name and email address are, because every “commit” you make will be signed. This needs to be done once on each computer you’re using.\nFollow the instructions here, or run the lines below:\n\n\n\n\n\n\nNote\n\n\n\nThe lines of code below use interactive prompts. Click the copy button in the upper right corner of the box below, and then paste the whole thing into the R console. You will see a line that says “Your full name:” - type your name into the console. Similarly, the next line will ask you for an email address.)\n\n\n\n\nuser_name <- readline(prompt = \"Your full name: \")\nuser_email <- readline(prompt = \"The address associated w your github account: \")\n\ninstall.packages(\"usethis\")\nlibrary(usethis)\n\nuse_git_config(user.name = user_name, user.email = user_email, scope = \"user\")\n\n# Tell git to ignore all files that are OS-dependent and don't have useful data.\ngit_vaccinate() \n\n# Create a ssh key if one doesn't already exist\nif (!file.exists(git2r::ssh_path(\"id_rsa.pub\"))) {\n  # Create an ssh key (with no password - less secure, but simpler)\n  system(\"ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -q -N ''\") \n  # Find the ssh-agent that will keep track of the password\n  system(\"eval $(ssh-agent -s)\")\n  # Add the key\n  system(\"ssh-add ~/.ssh/id_rsa\")\n} \n\nThen, in RStudio, go to Tools > Global Options > Git/SVN. View your public key, and copy it to the clipboard.\nThen, proceed to github. Make sure you’re signed into GitHub. Click on your profile pic in upper right corner and go Settings, then SSH and GPG keys. Click “New SSH key”. Paste your public key in the “Key” box. Give it an informative title. For example, you might use 2022-laptop to record the year and computer. Click “Add SSH key”.\n\n5.4.2 Create a Repository\nRepositories are single-project containers. You may have code, documentation, data, TODO lists, and more associated with a project. If you combine a git repository with an RStudio project, you get a very powerful combination that will make your life much easier, allowing you to focus on writing code instead of figuring out where all of your files are for each different project you start.\nTo create a repository, you can start with your local computer first, or you can start with the online repository first.\n\n\n\n\n\n\nImportant\n\n\n\nBoth methods are relatively simple, but the options you choose depend on which method you’re using, so be careful not to get them confused.\n\n\n\n5.4.2.1 Local repository first\nLet’s suppose you already have a folder on your machine named hello-world-1 (you may want to create this folder now). You’ve created a starter document, say, a text file named README with “hello world” written in it.\nIf you want, you can use the following R code to set this up:\n\ndir <- \"./hello-world-1\"\nif (!dir.exists(dir)) {\n  dir.create(dir)\n}\nfile <- file.path(dir, \"README\")\nif (!file.exists(file)) {\n  writeLines(\"hello world\", con = file)\n}\n\nTo create a local git repository, we can go to the terminal (in Mac/Linux) or the git bash shell (in Windows), navigate to our repository folder (not shown, will be different on each computer), and type in\ngit init\nAlternately, if you prefer a GUI (graphical user interface) approach, that will work too:\n\nOpen Rstudio\nProject (upper right corner) -> New Project -> Existing Directory. Navigate to the directory.\n(In your new project) Tools -> Project options -> Git/SVN -> select git from the dropdown, initialize new repository. RStudio will need to restart.\nNavigate to your new Git tab on the top right.\n\n\n\n\n\nThe next step is to add our file to the repository.\nUsing the command line, you can type in git add README (this tells git to track the file) and then commit your changes (enter them into the record) using git commit -m \"Add readme file\".\nUsing the GUI, you navigate to the git pane, check the box next to the README file, click the Commit button, write a message (“Add readme file”), and click the commit button.\n\n\n\n\nThe final step is to create a corresponding repository on GitHub. Navigate to your GitHub profile and make sure you’re logged in. Create a new repository using the “New” button. Name your repository whatever you want, fill in the description if you want (this can help you later, if you forget what exactly a certain repo was for), and DO NOT add a README, license file, or anything else (if you do, you will have a bad time).\nYou’ll be taken to your empty repository, and git will provide you the lines to paste into your git shell (or terminal) – you can access this within RStudio, as shown below. Paste those lines in, and you’ll be good to go.\n\n\n\n\n\n5.4.2.2 GitHub repository first\nIn the GitHub-first method, you’ll create a repository in GitHub and then clone it to your local machine (clone = create an exact copy locally).\nGUI method:\n\nLog into GitHub and create a new repository\nInitialize your repository with a README\nCopy the repository location by clicking on the “Code” button on the repo homepage\nOpen RStudio -> Project -> New Project -> From version control. Paste your repository URL into the box. Hit enter.\nMake a change to the README file\nClick commit, then push your changes\nCheck that the remote repository (Github) updated\n\n\n\n\n\nCommand line method:\n\nLog into GitHub and create a new repository\nInitialize your repository with a README\nCopy the repository location by clicking on the “Code” button on the repo homepage\nNavigate to the location you want your repository to live on your machine.\nClone the repository by using the git shell or terminal: git clone <your repo url here>. In my case, this looks like git clone git@github.com:stat850-unl/hello-world-2.git\n\nMake a change to your README file and save the change\nCommit your changes: git commit -a -m \"change readme\" (-a = all, that is, any changed file git is already tracking).\nPush your changes to the remote (GitHub) repository and check that the repo has updated: git push\n\n\n\n\n\n\n\n5.4.3 Adding files\ngit add tells git that you want it to track a particular file.\n\n\ngit add diagram: add tells git to add the file to the index of files git monitors.\n\n\nYou don’t need to understand exactly what git is doing on the backend, but it is important to know that the actual contents of the file aren’t logged by git add - you have to commit your changes for the contents to change. git add deals solely with the index of files that git “knows about”, and what it thinks belongs in each commit.\nIf you use the RStudio GUI for your git interface, you generally won’t have to do much with git add; it’s (sort-of, kind-of) equivalent to clicking the check box.\n\n5.4.3.1 What files should I add to git?\nGit is built for tracking text files. It will (begrudgingly) deal with small binary files (e.g. images, PDFs) without complaining too much, but it is NOT meant for storing large files, and GitHub will not allow you to push anything that has a file larger than 100MB2. Larger files can be handled with git-lfs (large file storage), but storing large files online is not something you can get for free.\nIn general, you should only add a file to git if you created it by hand. If you compiled the result, that should not be in the git repository under normal conditions (there are exceptions to this rule – this book is hosted on GitHub, which means I’ve pushed the compiled book to the GitHub repository).\nYou should also be cautious about adding files like .Rprog, .directory, .DS_Store, etc. These files are used by your operating system or by RStudio, and pushing them may cause problems for your collaborators (if you’re collaborating). Tracking changes to these files also doesn’t really do much good.\nI highly recommend that you make a point to only add and commit files which you consciously want to track.\n\n5.4.4 Staging your changes\nIn RStudio, when you check a box next to the file name in the git tab, you are effectively adding the file (if it is not already added) AND staging all of the changes you’ve made to the file. In practice, git add will both add and stage all of the changes to any given file, but it is also useful in some cases to stage only certain lines from a file.\nMore formally, staging is saying “I’d like these changes to be added to the current version, I think”. Before you commit your changes, you have to first stage them. You can think of this like going to the grocery store: you have items in your cart, but you can put them back at any point before checkout. Staging changes is like adding items to your cart; committing those changes is like checking out.\nIndividually staging lines of a file is most useful in situations where you’ve made changes which should be part of multiple commits. To stage individual lines of a file, you can use git add -i at the command line, or you can attempt to use RStudio’s “stage selection” interface. Both will work, though git can’t always separate changes quite as finely as you might want (and as a result, RStudio’s interface sometimes seems unresponsive, even though the underlying issue is with what git can do).\n\n5.4.5 Committing your changes\nA git commit is the equivalent of a log entry - it tells git to record the state of the file, along with a message about what that state means. On the back end, git will save a copy of the file in its current state to its cache.\n\n\nHere, we commit the red line as a change to our file.\n\n\nIn general, you want your commit message to be relatively short, but also informative. The best way to do this is to commit small blocks of changes. Work to commit every time you’ve accomplished a small task. This will do two things:\n\nYou’ll have small, bite-sized changes that are briefly described to serve as a record of what you’ve done (and what still needs doing)\nWhen you mess up (or end up in a merge conflict) you will have a much easier time pinpointing the spot where things went bad, what code was there before, and (because you have nice, descriptive commit messages) how the error occurred.\n\n5.4.6 Pushing and Pulling\nWhen you’re working alone, you generally won’t need to worry about having to update your local copy of the repository (unless you’re using multiple machines). However, statistics is collaborative, and one of the most powerful parts of git is that you can use it to keep track of changes when multiple people are working on the same document.\n\nIf you are working collaboratively and you and your collaborator are working on the same file, git will be able to resolve the change you make SO LONG AS YOU’RE NOT EDITING THE SAME LINE. Git works based on lines of text - it detects when there is a change in any line of a text document.\nFor this reason, I find it makes my life easier to put each sentence on a separate line, so that I can tweak things with fewer merge conflicts. Merge conflicts aren’t a huge deal, but they slow the workflow down, and are best avoided where possible.\n\nPulling describes the process of updating your local copy of the repository (the copy on your computer) with the files that are “in the cloud” (on GitHub). git pull (or using the Pull button in RStudio) will perform this update for you. If you are working with collaborators in real time, it is good practice to pull, commit, and push often, because this vastly reduces the merge conflict potential (and the scope of any conflicts that do pop up).\nPushing describes the process of updating the copy of the repository on another machine (e.g. on GitHub) so that it has the most recent changes you’ve made to your machine.\n\n\n\n\n\ngit push copies the version of the project on your computer to GitHub\n\n\n\n\n\n\ngit pull copies the version of the project on GitHub to your computer\n\n\n\n\nFigure 5.1: Git push and git pull are used to sync your computer with the remote repository (usually hosted on GitHub)\n\n\nIn general, your workflow will be\n\nClone the project or create a new repository\nMake some changes\nStage the changes with git add\nCommit the changes with git commit\nPull any changes from the remote repository\nResolve any merge conflicts\nPush the changes (and merged files) with git push\n\nIf you’re working alone, steps 5 and 6 are not likely to be necessary, but it is good practice to just pull before you push anyways."
  },
  {
    "objectID": "part-tools/05-git-and-github.html#references",
    "href": "part-tools/05-git-and-github.html#references",
    "title": "5  Version Control with Git",
    "section": "\n5.5 References",
    "text": "5.5 References\n\n\n\n\n[1] \nJ. Bryan, J. Hester, and {The Stat 545 TAs}, Happy git and GitHub for the useR. 2021 [Online]. Available: https://happygitwithr.com/. [Accessed: May 09, 2022]\n\n\n[2] \ndustbuster, “Answer to \"git is not working after macOS update (xcrun: Error: Invalid active developer path (/library/developer/CommandLineTools)\". Stack overflow,” Sep. 26, 2018. [Online]. Available: https://stackoverflow.com/a/52522566/2859168. [Accessed: Jan. 13, 2023]"
  },
  {
    "objectID": "part-gen-prog/00-gen-prog.html#what-is-programming",
    "href": "part-gen-prog/00-gen-prog.html#what-is-programming",
    "title": "Part II: General Programming",
    "section": "What is Programming?",
    "text": "What is Programming?\n\nProgramming today is a race between software engineers striving to build bigger and better idiot-proof programs, and the universe trying to produce bigger and better idiots. So far, the universe is winning. - Rick Cook\n\nProgramming is the art of solving a problem by developing a sequence of steps that make up a solution, and then very carefully communicating those steps to the computer. To program, you need to know how to\n\nbreak a problem down into smaller, easily solvable problems\nsolve the small problems\ncommunicate the solution to a computer using a programming language\n\nIn this book, we’ll be using both R and Python, and we’ll be using these languages to solve problems that are related to working with data. At first, we’ll start with smaller, simpler problems that don’t involve data, but by the end, you will hopefully be able to solve some statistical problems using one or both languages.\nIt will be hard at first - you have to learn the vocabulary in both languages in order to be able to put commands into logical “sentences”. The problem solving skills are the same for all programming languages, though, and while those are harder to learn, they’ll last you a lifetime.\nJust as you wouldn’t expect to learn French or Mandarin fluently after taking a single class, you cannot expect to be fluent in R or python once you’ve worked through this book. Fluency takes years of work and practice, and lots of mistakes along the way. You cannot learn a language (programming or otherwise) if you’re worried about making mistakes. Take a minute and put those concerns away somewhere, take a deep breath, and remember the Magic School Bus Motto:\n\n\nFor those who don’t know, the Magic School Bus is a PBS series that aired in the 1990s and was brought back by Netflix in 2017. It taught kids about different principles of science and the natural world."
  },
  {
    "objectID": "part-gen-prog/00-gen-prog.html#programming-vocabulary-hello-world",
    "href": "part-gen-prog/00-gen-prog.html#programming-vocabulary-hello-world",
    "title": "Part II: General Programming",
    "section": "Programming Vocabulary: Hello World",
    "text": "Programming Vocabulary: Hello World\nI particularly like the way that Python for Everybody [1] explains vocabulary:\n\nUnlike human languages, the Python vocabulary is actually pretty small. We call this “vocabulary” the “reserved words”. These are words that have very special meaning to Python. When Python sees these words in a Python program, they have one and only one meaning to Python. Later as you write programs you will make up your own words that have meaning to you called variables. You will have great latitude in choosing your names for your variables, but you cannot use any of Python’s reserved words as a name for a variable.\n\n\nWhen we train a dog, we use special words like “sit”, “stay”, and “fetch”. When you talk to a dog and don’t use any of the reserved words, they just look at you with a quizzical look on their face until you say a reserved word. For example, if you say, “I wish more people would walk to improve their overall health”, what most dogs likely hear is, “blah blah blah walk blah blah blah blah.” That is because “walk” is a reserved word in dog language. Many might suggest that the language between humans and cats has no reserved words.\n\n\nThe reserved words in the language where humans talk to Python include the following:\n\nand       del       global      not       with\nas        elif      if          or        yield\nassert    else      import      pass\nbreak     except    in          raise\nclass     finally   is          return\ncontinue  for       lambda      try\ndef       from      nonlocal    while    \n\nThat is it, and unlike a dog, Python is already completely trained. When you say ‘try’, Python will try every time you say it without fail.\n\n\nWe will learn these reserved words and how they are used in good time, but for now we will focus on the Python equivalent of “speak” (in human-to-dog language). The nice thing about telling Python to speak is that we can even tell it what to say by giving it a message in quotes:\n\n\nprint('Hello world!')\n## Hello world!\n\n\nAnd we have even written our first syntactically correct Python sentence. Our sentence starts with the function print followed by a string of text of our choosing enclosed in single quotes. The strings in the print statements are enclosed in quotes. Single quotes and double quotes do the same thing; most people use single quotes except in cases like this where a single quote (which is also an apostrophe) appears in the string.\n\nR has a slightly smaller set of reserved words:\nif          else     repeat      while        \nfor         in       next        break  \nTRUE        FALSE    NULL        Inf         \nNA_integer_ NA_real_ NA_complex_ NA_character_  \nNaN         NA       function    ...\nIn R, the “Hello World” program looks exactly the same as it does in python.\n\nprint('Hello world!')\n## [1] \"Hello world!\"\n\nIn many situations, R and python will be similar because both languages are based on C. R has a more complicated history [2], because it is also similar to Lisp, but both languages are still very similar to C and run C or C++ code in the background."
  },
  {
    "objectID": "part-gen-prog/00-gen-prog.html#getting-help",
    "href": "part-gen-prog/00-gen-prog.html#getting-help",
    "title": "Part II: General Programming",
    "section": "Getting help",
    "text": "Getting help\nIn both R and python, you can access help with a ? - the order is just slightly different.\nSuppose we want to get help on a for loop in either language.\nIn R, we can run this line of code to get help on for loops.\n\n?`for`\n\nBecause for is a reserved word in R, we have to use backticks (the key above the TAB key) to surround the word for so that R knows we’re talking about the function itself. Most other function help can be accessed using ?function_name. The backtick trick also works for functions that don’t start with letters, like +.\nIn python, we use for? to access the same information.\n\nfor? # help printed in the terminal\n?for # help printed in the help pane\n\n(You will have to run this in interactive mode for it to work in either language)\nw3schools has an excellent python help page that may be useful as well. Searching for help using google also works well, particularly if you know what sites are likely to be helpful, like w3schools and stackoverflow. A similar set of pages exists for R help on basic functions\n\n\n\n\n\n\nLearn More\n\n\n\nA nice explanation of the difference between an interpreter and a compiler. Both Python and R are interpreted languages that are compiled from lower-level languages like C."
  },
  {
    "objectID": "part-gen-prog/00-gen-prog.html#sec-gen-prog-refs",
    "href": "part-gen-prog/00-gen-prog.html#sec-gen-prog-refs",
    "title": "Part II: General Programming",
    "section": "References",
    "text": "References\n\n\n\n\n[1] \nD. C. R. Severance, Python for Everybody: Exploring Data in Python 3. Ann Arbor, MI: CreateSpace Independent Publishing Platform, 2016 [Online]. Available: https://www.py4e.com/html3/\n\n\n\n[2] \nR. Ihaka, “R : Past and future history,” 1998 [Online]. Available: https://www.stat.auckland.ac.nz/~ihaka/downloads/Interface98.pdf"
  },
  {
    "objectID": "part-gen-prog/01-basic-var-types.html#objectives",
    "href": "part-gen-prog/01-basic-var-types.html#objectives",
    "title": "6  Variables and Basic Data Types",
    "section": "\n6.1 Objectives",
    "text": "6.1 Objectives\n\nKnow the basic data types and what their restrictions are\nKnow how to test to see if a variable is a given data type\nUnderstand the basics of implicit and explicit type conversion\nWrite code that assigns values to variables"
  },
  {
    "objectID": "part-gen-prog/01-basic-var-types.html#basic-definitions",
    "href": "part-gen-prog/01-basic-var-types.html#basic-definitions",
    "title": "6  Variables and Basic Data Types",
    "section": "\n6.2 Basic Definitions",
    "text": "6.2 Basic Definitions\nFor a general overview, [1] is an excellent introduction to data types:\n\n\n\n\nLet’s start this section with some basic vocabulary.\n\na value is a basic unit of stuff that a program works with, like 1, 2, \"Hello, World\", and so on.\nvalues have types - 2 is an integer, \"Hello, World\" is a string (it contains a “string” of letters). Strings are in quotation marks to let us know that they are not variable names.\n\nIn most programming languages (including R and python), there are some very basic data types:\n\nlogical or boolean - FALSE/TRUE or 0/1 values. Sometimes, boolean is shortened to bool\ninteger - whole numbers (positive or negative)\n\ndouble or float or numeric- decimal numbers.\n\n\nfloat is short for floating-point value.\n\ndouble is a floating-point value with more precision (“double precision”).1\n\nR uses the name numeric to indicate a decimal value, regardless of precision.\n\n\ncharacter or string - holds text, usually enclosed in quotes.\n\n\n\n\n\n\n\nCapitalization matters!\n\n\n\nIn R, boolean values are TRUE and FALSE, but in Python they are True and False. Capitalization matters a LOT.\nOther things matter too: if we try to write a million, we would write it 1000000 instead of 1,000,000 (in both languages). Commas are used for separating numbers, not for proper spacing and punctuation of numbers. This is a hard thing to get used to but very important – especially when we start reading in data."
  },
  {
    "objectID": "part-gen-prog/01-basic-var-types.html#variables",
    "href": "part-gen-prog/01-basic-var-types.html#variables",
    "title": "6  Variables and Basic Data Types",
    "section": "\n6.3 Variables",
    "text": "6.3 Variables\nProgramming languages use variables - names that refer to values. Think of a variable as a container that holds something - instead of referring to the value, you can refer to the container and you will get whatever is stored inside.\n\n6.3.1 Assignment\nWe assign variables values using the syntax object_name <- value (R) or object_name = value (python). You can read this as “object name gets value” in your head.\nIn R, <- is used for assigning a value to a variable. So x <- \"R is awesome\" is read “x gets ‘R is awesome’” or “x is assigned the value ‘R is awesome’”. Technically, you can also use = to assign things to variables in R, but most style guides consider this to be poor programming practice, so seriously consider defaulting to <-.\nIn Python, = is used for assigning a value to a variable. This tends to be much easier to say out loud, but lacks any indication of directionality.\n\n\nR\nPython\n\n\n\n\nmessage <- \"So long and thanks for all the fish\"\nyear <- 2025\nthe_answer <- 42L\nearth_demolished <- FALSE\n\n\n\n\nmessage = \"So long and thanks for all the fish\"\nyear = 2025\nthe_answer = 42\nearth_demolished = False\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that in R, we assign variables values using the <- operator, where in Python, we assign variables values using the = operator. Technically, = will work for assignment in both languages, but <- is more common than = in R by convention.\n\n\nWe can then use the variables - do numerical computations, evaluate whether a proposition is true or false, and even manipulate the content of strings, all by referencing the variable by name.\n\n6.3.2 Valid Names\n\nThere are only two hard things in Computer Science: cache invalidation and naming things.\n– Phil Karlton\n\nObject names must start with a letter and can only contain letters, numbers, _, and . in R. In Python, object names must start with a letter and can consist of letters, numbers, and _ (that is, . is not a valid character in a Python variable name). While it is technically fine to use uppercase variable names in Python, it’s recommended that you use lowercase names for variables (you’ll see why later).\nWhat happens if we try to create a variable name that isn’t valid?\nIn both languages, starting a variable name with a number will get you an error message that lets you know that something isn’t right - “unexpected symbol” in R and “invalid syntax” in python.\n\n\nR\nPython\n\n\n\n\n1st_thing <- \"check your variable names!\"\n## Error: <text>:1:2: unexpected symbol\n## 1: 1st_thing\n##      ^\n\n\n\n\n1st_thing <- \"check your variable names!\"\n\nNote: Run the above chunk in your python window - the book won’t compile if I set it to evaluate 😥. It generates an error of SyntaxError: invalid syntax (<string>, line 1)\n\nsecond.thing <- \"this isn't valid\"\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'second' is not defined\n\nIn python, trying to have a . in a variable name gets a more interesting error: “ is not defined”. This is because in python, some objects have components and methods that can be accessed with .. We’ll get into this more later, but there is a good reason for python’s restriction about not using . in variable names.\n\n\n\nNaming things is difficult! When you name variables, try to make the names descriptive - what does the variable hold? What are you going to do with it? The more (concise) information you can pack into your variable names, the more readable your code will be.\n\n\n\n\n\n\nLearn More\n\n\n\nWhy is naming things hard? - Blog post by Neil Kakkar\n\n\nThere are a few different conventions for naming things that may be useful:\n\n\nsome_people_use_snake_case, where words are separated by underscores\n\nsomePeopleUseCamelCase, where words are appended but anything after the first word is capitalized (leading to words with humps like a camel).\n\nsome.people.use.periods (in R, obviously this doesn’t work in python)\nA few people mix conventions with variables_thatLookLike.this and they are almost universally hated 👿\n\nAs long as you pick ONE naming convention and don’t mix-and-match, you’ll be fine. It will be easier to remember what you named your variables (or at least guess) and you’ll have fewer moments where you have to go scrolling through your script file looking for a variable you named."
  },
  {
    "objectID": "part-gen-prog/01-basic-var-types.html#types",
    "href": "part-gen-prog/01-basic-var-types.html#types",
    "title": "6  Variables and Basic Data Types",
    "section": "\n6.4 Types",
    "text": "6.4 Types\nYou can use different functions to test whether a variable has a specific type as well:\n\n\nR\nPython\n\n\n\n\nis.logical(FALSE)\nis.integer(2L) # by default, R treats all numbers as numeric/decimal values. \n          # The L indicates that we're talking about an integer. \nis.integer(2)\nis.numeric(2)\nis.character(\"Hello, programmer!\")\nis.function(print)\n## [1] TRUE\n## [1] TRUE\n## [1] FALSE\n## [1] TRUE\n## [1] TRUE\n## [1] TRUE\n\nIn R, you use is.xxx functions, where xxx is the name of the type in question.\n\n\n\nisinstance(False, bool)\nisinstance(2, int)\nisinstance(2, (int, float)) # Test for one of multiple types\nisinstance(3.1415, float)\nisinstance(\"This is python code\", str)\n## True\n## True\n## True\n## True\n## True\n\nIn python, test for types using the isinstance function with an argument containing one or more data types in a tuple ((int, float) is an example of a tuple - a static set of multiple values).\nIf we want to test for whether something is callable (can be used like a function), we have to get slightly more complicated:\n\ncallable(print)\n## True\n\nThis is glossing over some much more technical information about differences between functions and classes (that we haven’t covered) [2].\n\n\n\n\n\n\n\n\n\nExample: Assignment and Testing Types\n\n\n\n\n\nCharacter\nLogical\nInteger\nDouble\nNumeric\n\n\n\n\nx <- \"R is awesome\"\ntypeof(x)\n## [1] \"character\"\nis.character(x)\n## [1] TRUE\nis.logical(x)\n## [1] FALSE\nis.integer(x)\n## [1] FALSE\nis.double(x)\n## [1] FALSE\n\n\nx = \"python is awesome\"\ntype(x)\n## <class 'str'>\nisinstance(x, str)\n## True\nisinstance(x, bool)\n## False\nisinstance(x, int)\n## False\nisinstance(x, float)\n## False\n\n\n\n\nx <- FALSE\ntypeof(x)\n## [1] \"logical\"\nis.character(x)\n## [1] FALSE\nis.logical(x)\n## [1] TRUE\nis.integer(x)\n## [1] FALSE\nis.double(x)\n## [1] FALSE\n\nIn R, is possible to use the shorthand F and T, but be careful with this, because F and T are not reserved, and other information can be stored within them. See this discussion for pros and cons of using F and T as variables vs. shorthand for true and false. 2\n\nx = False\ntype(x)\n## <class 'bool'>\nisinstance(x, str)\n## False\nisinstance(x, bool)\n## True\nisinstance(x, int)\n## True\nisinstance(x, float)\n## False\n\nNote that in python, boolean variables are also integers. If your goal is to test whether something is a T/F value, you may want to e.g. test whether its value is one of 0 or 1, rather than testing whether it is a boolean variable directly, since integers can also function directly as bools in Python.\n\n\n\nx <- 2\ntypeof(x)\n## [1] \"double\"\nis.character(x)\n## [1] FALSE\nis.logical(x)\n## [1] FALSE\nis.integer(x)\n## [1] FALSE\nis.double(x)\n## [1] TRUE\n\nWait, 2 is an integer, right?\n2 is an integer, but in R, values are assumed to be doubles unless specified. So if we want R to treat 2 as an integer, we need to specify that it is an integer specifically.\n\nx <- 2L # The L immediately after the 2 indicates that it is an integer.\ntypeof(x)\n## [1] \"integer\"\nis.character(x)\n## [1] FALSE\nis.logical(x)\n## [1] FALSE\nis.integer(x)\n## [1] TRUE\nis.double(x)\n## [1] FALSE\nis.numeric(x)\n## [1] TRUE\n\n\nx = 2\ntype(x)\n## <class 'int'>\nisinstance(x, str)\n## False\nisinstance(x, bool)\n## False\nisinstance(x, int)\n## True\nisinstance(x, float)\n## False\n\n\n\n\nx <- 2.45\ntypeof(x)\n## [1] \"double\"\nis.character(x)\n## [1] FALSE\nis.logical(x)\n## [1] FALSE\nis.integer(x)\n## [1] FALSE\nis.double(x)\n## [1] TRUE\nis.numeric(x)\n## [1] TRUE\n\n\nx = 2.45\ntype(x)\n## <class 'float'>\nisinstance(x, str)\n## False\nisinstance(x, bool)\n## False\nisinstance(x, int)\n## False\nisinstance(x, float)\n## True\n\n\n\nA fifth common “type”3, numeric is really the union of two types: integer and double, and you may come across it when using str() or mode(), which are similar to typeof() but do not quite do the same thing.\nThe numeric category exists because when doing math, we can add an integer and a double, but adding an integer and a string is … trickier. Testing for numeric variables guarantees that we’ll be able to do math with those variables. is.numeric() and as.numeric() work as you would expect them to work.\nThe general case of this property of a language is called implicit type conversion - that is, R will implicitly (behind the scenes) convert your integer to a double and then add the other double, so that the result is unambiguously a double."
  },
  {
    "objectID": "part-gen-prog/01-basic-var-types.html#sec-type-conversions",
    "href": "part-gen-prog/01-basic-var-types.html#sec-type-conversions",
    "title": "6  Variables and Basic Data Types",
    "section": "\n6.5 Type Conversions",
    "text": "6.5 Type Conversions\nProgramming languages will generally work hard to seamlessly convert variables to different types. So, for instance,\n\n\nR\nPython\n\n\n\n\nTRUE + 2\n## [1] 3\n\n2L + 3.1415\n## [1] 5.1415\n\n\"abcd\" + 3\n## Error in \"abcd\" + 3: non-numeric argument to binary operator\n\n\n\n\nTrue + 2\n## 3\nint(2) + 3.1415\n## 5.141500000000001\n\"abcd\" + 3\n## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: can only concatenate str (not \"int\") to str\n\n\n\n\nThis conversion doesn’t always work - there’s no clear way to make “abcd” into a number we could use in addition. So instead, R or python will issue an error. This error pops up frequently when something went wrong with data import and all of a sudden you just tried to take the mean of a set of string/character variables. Whoops.\nWhen you want to, you can also use as.xxx() to make the type conversion explicit. So, the analogue of the code above, with explicit conversions would be:\n\n\nR\nPython\n\n\n\n\nas.double(TRUE) + 2\n## [1] 3\n\nas.double(2L) + 3.1415\n## [1] 5.1415\n\nas.numeric(\"abcd\") + 3\n## [1] NA\n\n\n\n\nint(True) + 2\n## 3\nfloat(2) + 3.1415\n## 5.141500000000001\nfloat(\"abcd\") + 3\n## Error in py_call_impl(callable, dots$args, dots$keywords): ValueError: could not convert string to float: 'abcd'\nimport pandas as pd # Load pandas library\n## Error in py_call_impl(callable, dots$args, dots$keywords): ModuleNotFoundError: No module named 'pandas'\npd.to_numeric(\"abcd\", errors = 'coerce') + 3\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'pd' is not defined\n\n\n\n\nWhen we make our intent explicit (convert “abcd” to a numeric variable) we get an NA - a missing value - in R. In Python, we get a more descriptive error by default, but we can use the pandas library (which adds some statistical functionality) to get a similar result to the result we get in R.\nThere’s still no easy way to figure out where “abcd” is on a number line, but our math will still have a result - NA + 3 is NA."
  },
  {
    "objectID": "part-gen-prog/01-basic-var-types.html#determining-a-variables-type",
    "href": "part-gen-prog/01-basic-var-types.html#determining-a-variables-type",
    "title": "6  Variables and Basic Data Types",
    "section": "\n6.6 Determining a Variable’s Type",
    "text": "6.6 Determining a Variable’s Type\nIf you don’t know what type a value is, both R and python have functions to help you with that.\n\n\nR\nPython\n\n\n\nIf you are unsure what the type of a variable is, use the typeof() function to find out.\n\nw <- \"a string\"\nx <- 3L\ny <- 3.1415\nz <- FALSE\n\ntypeof(w)\n## [1] \"character\"\ntypeof(x)\n## [1] \"integer\"\ntypeof(y)\n## [1] \"double\"\ntypeof(z)\n## [1] \"logical\"\n\n\n\nIf you are unsure what the type of a variable is, use the type() function to find out.\n\nw = \"a string\"\nx = 3\ny = 3.1415\nz = False\n\ntype(w)\n## <class 'str'>\ntype(x)\n## <class 'int'>\ntype(y)\n## <class 'float'>\ntype(z)\n## <class 'bool'>\n\n\n\n\n\n\n\n\n\n\nTry It Out: Variables and Types\n\n\n\n\n\nR\nPython\nR Solution\nPython Solution\n\n\n\n\nCreate variables string, integer, decimal, and logical, with types that match the relevant variable names.\n\n\nstring <- \ninteger <- \ndecimal <- \nlogical <- \n\n\nCan you get rid of the error that occurs when this chunk is run?\n\n\nlogical + decimal\ninteger + decimal\nstring + integer\n\n\nWhat happens when you add string to string? logical to logical?\n\n\n\n\nCreate variables string, integer, decimal, and logical, with types that match the relevant variable names.\n\n\nstring = \ninteger = \ndecimal = \nlogical = \n\n\nCan you get rid of the error that occurs when this chunk is run?\n\n\nlogical + decimal\ninteger + decimal\nstring + integer\n\n\nWhat happens when you add string to string? logical to logical?\n\n\n\n\nstring <- \"hi, I'm a string\"\ninteger <- 4L\ndecimal <- 5.412\nlogical <- TRUE\n\nlogical + decimal\n## [1] 6.412\ninteger + decimal\n## [1] 9.412\nas.numeric(string) + integer\n## [1] NA\n\n\"abcd\" + \"efgh\"\n## Error in \"abcd\" + \"efgh\": non-numeric argument to binary operator\nTRUE + TRUE\n## [1] 2\n\nIn R, adding a string to a string creates an error (“non-numeric argument to binary operator”). Adding a logical to a logical, e.g. TRUE + TRUE, results in 2, which is a numeric value.\nTo concatenate strings in R (like the default behavior in python), we would use the paste0 function: paste0(\"abcd\", \"efgh\"), which returns abcdefgh.\n\n\n\nimport pandas as pd\n## Error in py_call_impl(callable, dots$args, dots$keywords): ModuleNotFoundError: No module named 'pandas'\nstring = \"hi, I'm a string\"\ninteger = 4\ndecimal = 5.412\nlogical = True\n\nlogical + decimal\n## 6.412\ninteger + decimal\n## 9.411999999999999\npd.to_numeric(string, errors='coerce') + integer\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'pd' is not defined\n\"abcd\" + \"efgh\"\n## 'abcdefgh'\nTrue + True\n## 2\n\nIn Python, when a string is added to another string, the two strings are concatenated. This differs from the result in R, which is a “non-numeric argument to binary operator” error."
  },
  {
    "objectID": "part-gen-prog/01-basic-var-types.html#sec-basic-var-types-refs",
    "href": "part-gen-prog/01-basic-var-types.html#sec-basic-var-types-refs",
    "title": "6  Variables and Basic Data Types",
    "section": "\n6.7 References",
    "text": "6.7 References\n\n\n\n\n[1] \n\nWhy TRUE + TRUE = 2: Data Types. (Feb. 03, 2020) [Online]. Available: https://www.youtube.com/watch?v=6otW6OXjR8c. [Accessed: May 18, 2022]\n\n\n[2] \nRyan, “Answer to \"how do i detect whether a variable is a function?\". Stack overflow,” Mar. 09, 2009. [Online]. Available: https://stackoverflow.com/a/624948/2859168. [Accessed: Jan. 10, 2023]"
  },
  {
    "objectID": "part-gen-prog/02-prog-functions.html#mathematical-operators",
    "href": "part-gen-prog/02-prog-functions.html#mathematical-operators",
    "title": "7  Using Functions",
    "section": "\n7.1 Mathematical Operators",
    "text": "7.1 Mathematical Operators\nLet’s first start with a special class of functions that you’re probably familiar with from your math classes - mathematical operators.\nHere are a few of the most important ones:\n\n\nOperation\nR symbol\nPython symbol\n\n\n\nAddition\n+\n+\n\n\nSubtraction\n-\n-\n\n\nMultiplication\n*\n*\n\n\nDivision\n/\n/\n\n\nInteger Division\n%/%\n//\n\n\nModular Division\n%%\n%\n\n\nExponentiation\n^\n**\n\n\n\nThese operands are all for scalar operations (operations on a single number) - vectorized versions, such as matrix multiplication, are somewhat more complicated (and different between R and python).\n\n\n\n\n\n\nExample: Integer and Modular Division\n\n\n\nInteger division is the whole number answer to A/B, and modular division is the fractional remainder when A/B.\nLet’s demonstrate with the problem 14/3, which evaluates to 4.6666667 when division is used, but has integer part 4 and remainder 2.\n\n\nR\nPython\n\n\n\n14 %/% 3 in R would be 4, and 14 %% 3 in R would be 2.\n\n14 %/% 3\n## [1] 4\n14 %% 3\n## [1] 2\n\n\n\n\n14 // 3\n## 4\n14 % 3\n## 2"
  },
  {
    "objectID": "part-gen-prog/02-prog-functions.html#order-of-operations",
    "href": "part-gen-prog/02-prog-functions.html#order-of-operations",
    "title": "7  Using Functions",
    "section": "\n7.2 Order of Operations",
    "text": "7.2 Order of Operations\nBoth R and Python operate under the same mathematical rules of precedence that you learned in school. You may have learned the acronym PEMDAS, which stands for Parentheses, Exponents, Multiplication/Division, and Addition/Subtraction. That is, when examining a set of mathematical operations, we evaluate parentheses first, then exponents, and then we do multiplication/division, and finally, we add and subtract.\n\n\nR\nPython\n\n\n\n\n(1+1)^(5-2) \n## [1] 8\n1 + 2^3 * 4 \n## [1] 33\n3*1^3 \n## [1] 3\n\n\n\n\n(1+1)**(5-2)\n## 8\n1 + 2**3*4\n## 33\n3*1**3\n## 3"
  },
  {
    "objectID": "part-gen-prog/02-prog-functions.html#simple-string-operations",
    "href": "part-gen-prog/02-prog-functions.html#simple-string-operations",
    "title": "7  Using Functions",
    "section": "\n7.3 Simple String Operations",
    "text": "7.3 Simple String Operations\nPython has some additional operators that work on strings. In R, you will have to use functions to perform these operations, as R does not have string operators.\n\n\n\n\n\n\nDemo\n\n\n\n\n\nPython\nR\n\n\n\nIn Python, + will concatenate (stick together) two strings. Multiplying a string by an integer will repeat the string the specified number of times.\n\n\"first \" + \"second\"\n## 'first second'\n\"hello \" * 3\n## 'hello hello hello '\n\n\n\nIn R, to concatenate things, we need to use functions: paste or paste0:\n\npaste(\"first\", \"second\", sep = \" \")\n## [1] \"first second\"\npaste(\"first\", \"second\", collapse = \" \")\n## [1] \"first second\"\npaste(c(\"first\", \"second\"), sep = \" \") # sep only works w/ 2 objects passed in\n## [1] \"first\"  \"second\"\npaste(c(\"first\", \"second\"), collapse = \" \") # collapse works on vectors\n## [1] \"first second\"\n\npaste(c(\"a\", \"b\", \"c\", \"d\"), \n      c(\"first\", \"second\", \"third\", \"fourth\"), \n      sep = \"-\", collapse = \" \")\n## [1] \"a-first b-second c-third d-fourth\"\n# sep is used to collapse parameters, then collapse is used to collapse vectors\n\npaste0(c(\"a\", \"b\", \"c\"))\n## [1] \"a\" \"b\" \"c\"\npaste0(\"a\", \"b\", \"c\") # equivalent to paste(..., sep = \"\")\n## [1] \"abc\"\n\nYou don’t need to understand the details of this code at this point in the class, but it is useful to know how to combine strings in both languages."
  },
  {
    "objectID": "part-gen-prog/02-prog-functions.html#using-functions",
    "href": "part-gen-prog/02-prog-functions.html#using-functions",
    "title": "7  Using Functions",
    "section": "\n7.4 Using Functions",
    "text": "7.4 Using Functions\nFunctions are sets of instructions that take arguments and return values. Strictly speaking, mathematical operators (like those above) are a special type of functions – but we aren’t going to get into that now.\nWe’re also not going to talk about how to create our own functions just yet. Instead, I’m going to show you how to use functions.\n\n\n\n\n\n\nCheat Sheets!\n\n\n\nIt may be helpful at this point to print out the R reference card1 and the Python reference card2. These cheat sheets contain useful functions for a variety of tasks in each language.\n\n\nMethods are a special type of function that operate on a specific variable type. In Python, methods are applied using the syntax variable.method_name(). So, you can get the length of a string variable my_string using my_string.length().\nR has methods too, but they are invoked differently. In R, you would get the length of a string variable using length(my_string).\nRight now, it is not really necessary to know too much more about functions than this: you can invoke a function by passing in arguments, and the function will do a task and return the value.\n\n\n\n\n\n\nYour Turn\n\n\n\n\n\nProblem\nR Solution\nPython Solution\n\n\n\nTry out some of the functions mentioned on the R and Python cheatsheets.\nCan you figure out how to define a list or vector of numbers? If so, can you use a function to calculate the maximum value?\nCan you find the R functions that will allow you to repeat a string variable multiple times or concatenate two strings? Can you do this task in Python?\n\n\n\n# Define a vector of numbers\nx <- c(1, 2, 3, 4, 5)\n\n# Calculate the maximum\nmax(x)\n## [1] 5\n\n# function to repeat a variable multiple times\nrep(\"test\", 3)\n## [1] \"test\" \"test\" \"test\"\n# Concatenate strings, using \"ing... \" as the separator\npaste(rep(\"test\", 3), collapse = \"ing... \")\n## [1] \"testing... testing... test\"\n\n\n\n\n# Define a list of numbers\nx = [1, 2, 3, 4, 5]\n\n# Calculate the maximum\nmax(x)\n\n# Repeat a string multiple times\n## 5\nx = (\"test\", )*3 # String multiplication \n                 # have to use a tuple () to get separate items\n# Then use 'yyy'.join(x) to paste items of x together with yyy as separators\n'ing... '.join(x)\n## 'testing... testing... test'"
  },
  {
    "objectID": "part-gen-prog/02-prog-functions.html#overpowerd-calculators",
    "href": "part-gen-prog/02-prog-functions.html#overpowerd-calculators",
    "title": "7  Using Functions",
    "section": "\n7.5 Overpowerd Calculators",
    "text": "7.5 Overpowerd Calculators\nNow that you’re familiar with how to use functions, if not how to define them, you are capable of using R or python as a very fancy calculator. Obviously, both languages can do many more interesting things, which we’ll get to, but let’s see if we can make R and Python do some very basic stuff that hopefully isn’t too foreign to you.\n\n\n\n\n\n\nExample: Triangle Side Length\n\n\n\n\n\nA right triangle with sides a, b, and hypotenuse c labeled.\n\n\nConsider this triangle. I’ve measured the sides in an image editor and determined that \\(a = 212\\) pixels, \\(b = 345\\) pixels, and \\(c = 406\\) pixels. I suspect, however, that my measurements aren’t quite right - for one thing, I tried to measure in the center of the line, but it wasn’t easy on the diagonal.\nLet’s assume that my measurements for \\(a\\) and \\(b\\) are accurate and calculate how far off my estimate was for side \\(c\\).\n\n\nR\nPython\n\n\n\n\n# Define variables for the 3 sides of the triangle\na <- 212\nb <- 345\nc_meas <- 406\nc_actual <- sqrt(a^2 + b^2)\n\n# Calculate difference between measured and actual\n# relative to actual \n# and make it a percentage\npct_error <- (c_meas - c_actual)/c_actual * 100\npct_error\n## [1] 0.2640307\n\n\n\n\n# To get the sqrt function, we have to import the math package\nimport math\n\n# Define variables for the 3 sides of the triangle\na = 212\nb = 345\nc_meas = 406\nc_actual = math.sqrt(a**2 + b**2)\n\n# Calculate difference between measured and actual\n# relative to actual \n# and make it a percentage\npct_error = (c_meas - c_actual)/c_actual * 100\npct_error\n## 0.264030681414134\n\n\n\n\nInteresting, I wasn’t as inaccurate as I thought!\n\n\n\n\n\n\n\n\nYour Turn\n\n\n\nOf course, if you remember trigonometry, we don’t have to work with right triangles. Let’s see if we can use trigonometric functions to do the same task with an oblique triangle.\n\n\nProblem\nR solution\nPython solution\n\n\n\nJust in case you’ve forgotten your Trig, the Law of Cosines says that \\[c^2 = a^2 + b^2 - 2 a b \\cos(C),\\] where \\(C\\) is the angle between sides \\(a\\) and \\(b\\).\n\n\nAn oblique triangle with sides labeled a, b, and c, and angles labeled as A, B, C with capital letter opposite the lowercase side.\n\n\nI measure side \\(a = 291\\) pixels, side \\(b = 414\\) pixels, and the angle between \\(a\\) and \\(b\\) to be \\(67.6^\\circ\\). What will I likely get for the length of side \\(c\\) in pixels?\nRemember to check whether R and python compute trig functions using radians or degrees! As a reminder, \\(\\pi\\) radians = \\(180^\\circ\\).\n\n\n\n# Define variables for the 3 sides of the triangle\na <- 291\nb <- 414\nc_angle <- 67.6\nc_actual <- sqrt(a^2 + b^2 - 2*a*b*cos(c_angle/180*pi))\nc_actual\n## [1] 405.2886\n\nI measured the length of side \\(c\\) as 407 pixels.\n\n\n\n# To get the sqrt and cos functions, we have to import the math package\nimport math\n\n# Define variables for the 3 sides of the triangle\na = 291\nb = 414\nc_angle = 67.6\nc_actual = math.sqrt(a**2 + b**2 - 2*a*b*math.cos(c_angle/180*math.pi))\nc_actual\n## 405.28860699402117\n\nI measured the length of side \\(c\\) as 407 pixels.\n\n\n\n\n\nCongratulations, if you used a TI-83 in high school to do this sort of stuff, you’re now just about as proficient with R and python as you were with that!"
  },
  {
    "objectID": "part-gen-prog/03-data-struct.html#objectives",
    "href": "part-gen-prog/03-data-struct.html#objectives",
    "title": "8  Vectors, Matrices, Arrays, and Control Structures",
    "section": "\n8.1 Objectives",
    "text": "8.1 Objectives\n\nUnderstand the differences between lists, vectors, data frames, matrices, and arrays in R and python\nBe able to use location-based indexing in R or python to pull out subsets of a complex data object"
  },
  {
    "objectID": "part-gen-prog/03-data-struct.html#data-structures-overview",
    "href": "part-gen-prog/03-data-struct.html#data-structures-overview",
    "title": "8  Vectors, Matrices, Arrays, and Control Structures",
    "section": "\n8.2 Data Structures Overview",
    "text": "8.2 Data Structures Overview\nIn Chapter 6, we discussed 4 different data types: strings/characters, numeric/double/floats, integers, and logical/booleans. As you might imagine, things are about to get more complicated.\nData structures are more complex arrangements of information, but they are still (usually) created using the same data types we have previously discussed.\n\n\n\nHomogeneous\nHeterogeneous\n\n\n\n1D\nvector\nlist\n\n\n2D\nmatrix\ndata frame\n\n\nN-D\narray\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThose of you who have taken programming classes that were more computer science focused will realize that I am leaving out a lot of information about lower-level structures like pointers. I’m making a deliberate choice to gloss over most of those details in this chapter, because it’s already hard enough to learn 2 languages worth of data structures at a time. In addition, R doesn’t have pointers No Pointers in R, [1], so leaving out this material in python streamlines teaching both two languages, at the cost of overly simplifying some python concepts. If you want to read more about the Python concepts I’m leaving out, check out [2]."
  },
  {
    "objectID": "part-gen-prog/03-data-struct.html#lists",
    "href": "part-gen-prog/03-data-struct.html#lists",
    "title": "8  Vectors, Matrices, Arrays, and Control Structures",
    "section": "\n8.3 Lists",
    "text": "8.3 Lists\nA list is a one-dimensional column of heterogeneous data - the things stored in a list can be of different types.\n\n\nA lego list: the bricks are all different types and colors, but they are still part of the same data structure.\n\n\n\n\nR\nPython\n\n\n\n\nx <- list(\"a\", 3, FALSE)\nx\n## [[1]]\n## [1] \"a\"\n## \n## [[2]]\n## [1] 3\n## \n## [[3]]\n## [1] FALSE\n\n\n\n\nx = [\"a\", 3, False]\nx\n## ['a', 3, False]\n\n\n\n\nThe most important thing to know about lists, for the moment, is how to pull things out of the list. We call that process indexing.\n\n8.3.1 Indexing\nEvery element in a list has an index (a location, indicated by an integer position)1.\n\n\nR concept\nR code\nPython concept\nPython code\n\n\n\nIn R, we count from 1.\n\n\nAn R-indexed lego list, counting from 1 to 5\n\n\n\n\n\nx <- list(\"a\", 3, FALSE)\n\nx[1] # This returns a list\n## [[1]]\n## [1] \"a\"\nx[1:2] # This returns multiple elements in the list\n## [[1]]\n## [1] \"a\"\n## \n## [[2]]\n## [1] 3\n\nx[[1]] # This returns the item\n## [1] \"a\"\nx[[1:2]] # This doesn't work - you can only use [[]] with a single index\n## Error in x[[1:2]]: subscript out of bounds\n\nIn R, list indexing with [] will return a list with the specified elements.\nTo actually retrieve the item in the list, use [[]]. The only downside to [[]] is that you can only access one thing at a time.\n\n\nIn Python, we count from 0.\n\n\nA python-indexed lego list, counting from 0 to 4\n\n\n\n\n\nx = [\"a\", 3, False]\n\nx[0]\n## 'a'\nx[1]\n## 3\nx[0:2]\n## ['a', 3]\n\nIn Python, we can use single brackets to get an object or a list back out, but we have to know how slices work. Essentially, in Python, 0:2 indicates that we want objects 0 and 1, but want to stop at 2 (not including 2). If you use a slice, Python will return a list; if you use a single index, python just returns the value in that location in the list.\n\n\n\nWe’ll talk more about indexing as it relates to vectors, but indexing is a general concept that applies to just about any multi-value object."
  },
  {
    "objectID": "part-gen-prog/03-data-struct.html#vectors",
    "href": "part-gen-prog/03-data-struct.html#vectors",
    "title": "8  Vectors, Matrices, Arrays, and Control Structures",
    "section": "\n8.4 Vectors",
    "text": "8.4 Vectors\nA vector is a one-dimensional column of homogeneous data. Homogeneous means that every element in a vector has the same data type.\nWe can have vectors of any data type and length we want:\n\n\nvectors of different data types\n\n\n\n8.4.1 Indexing by Location\nEach element in a vector has an index - an integer telling you what the item’s position within the vector is. I’m going to demonstrate indices with the string vector\n\n\n\n\n\n\nR\nPython\n\n\n\n1-indexed language\n0-indexed language\n\n\nCount elements as 1, 2, 3, 4, …, N\nCount elements as 0, 1, 2, 3, , …, N-1\n\n\n\n\n\n\n\n\n\nR\nPython Vectors\nPython Series (Pandas)\n\n\n\nIn R, we create vectors with the c() function, which stands for “concatenate” - basically, we stick a bunch of objects into a row.\n\ndigits_pi <- c(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5)\n\n# Access individual entries\ndigits_pi[1]\n## [1] 3\ndigits_pi[2]\n## [1] 1\ndigits_pi[3]\n## [1] 4\n\n# R is 1-indexed - a list of 11 things goes from 1 to 11\ndigits_pi[0]\n## numeric(0)\ndigits_pi[11]\n## [1] 5\n\n# Print out the vector\ndigits_pi\n##  [1] 3 1 4 1 5 9 2 6 5 3 5\n\n\n\nIn python, we create vectors using the array function in the numpy module. To add a python module, we use the syntax import <name> as <nickname>. Many modules have conventional (and very short) nicknames - for numpy, we will use np as the nickname. Any functions we reference in the numpy module will then be called using np.fun_name() so that python knows where to find them.2\n\nimport numpy as np\ndigits_list = [3,1,4,1,5,9,2,6,5,3,5]\ndigits_pi = np.array(digits_list)\n\n# Access individual entries\ndigits_pi[0]\n## 3\ndigits_pi[1]\n## 1\ndigits_pi[2]\n\n# Python is 0 indexed - a list of 11 things goes from 0 to 10\n## 4\ndigits_pi[0]\n## 3\ndigits_pi[11] \n\n# multiplication works on the whole vector at once\n## Error in py_call_impl(callable, dots$args, dots$keywords): IndexError: index 11 is out of bounds for axis 0 with size 11\ndigits_pi * 2\n\n# Print out the vector\n## array([ 6,  2,  8,  2, 10, 18,  4, 12, 10,  6, 10])\nprint(digits_pi)\n## [3 1 4 1 5 9 2 6 5 3 5]\n\n\n\nPython has multiple things that look like vectors, including the pandas library’s Series structure. A Series is a one-dimensional array-like object containing a sequence of values and an associated array of labels (called its index).\n\nimport pandas as pd\n## Error in py_call_impl(callable, dots$args, dots$keywords): ModuleNotFoundError: No module named 'pandas'\ndigits_pi = pd.Series([3,1,4,1,5,9,2,6,5,3,5])\n\n# Access individual entries\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'pd' is not defined\ndigits_pi[0]\n## 3\ndigits_pi[1]\n## 1\ndigits_pi[2]\n\n# Python is 0 indexed - a list of 11 things goes from 0 to 10\n## 4\ndigits_pi[0]\n## 3\ndigits_pi[11] \n\n# logical indexing works here too\n## Error in py_call_impl(callable, dots$args, dots$keywords): IndexError: index 11 is out of bounds for axis 0 with size 11\ndigits_pi[digits_pi > 3]\n# simple multiplication works in a vectorized manner\n# that is, the whole vector is multiplied at once\n## array([4, 5, 9, 6, 5, 5])\ndigits_pi * 2\n\n# Print out the series\n## array([ 6,  2,  8,  2, 10, 18,  4, 12, 10,  6, 10])\nprint(digits_pi)\n## [3 1 4 1 5 9 2 6 5 3 5]\n\nThe Series object has a list of labels in the first printed column, and a list of values in the second. If we want, we can specify the labels manually to use as e.g. plot labels later:\n\nimport pandas as pd\n## Error in py_call_impl(callable, dots$args, dots$keywords): ModuleNotFoundError: No module named 'pandas'\nweekdays = pd.Series(['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], index = ['S', 'M', 'T', 'W', 'R', 'F', 'Sat'])\n\n# access individual objs\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'pd' is not defined\nweekdays[0]\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'weekdays' is not defined\nweekdays[1]\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'weekdays' is not defined\nweekdays['S']\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'weekdays' is not defined\nweekdays['Sat']\n\n# access the index\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'weekdays' is not defined\nweekdays.index\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'weekdays' is not defined\nweekdays.index[6] = 'Z' # you can't assign things to the index to change it\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'weekdays' is not defined\nweekdays\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'weekdays' is not defined\n\n\n\n\nWe can pull out items in a vector by indexing, but we can also replace specific things as well:\n\n\n\nR\nPython\n\n\n\n\nfavorite_cats <- c(\"Grumpy\", \"Garfield\", \"Jorts\", \"Jean\")\n\nfavorite_cats\n## [1] \"Grumpy\"   \"Garfield\" \"Jorts\"    \"Jean\"\n\nfavorite_cats[2] <- \"Nyan Cat\"\n\nfavorite_cats\n## [1] \"Grumpy\"   \"Nyan Cat\" \"Jorts\"    \"Jean\"\n\n\n\n\nfavorite_cats = [\"Grumpy\", \"Garfield\", \"Jorts\", \"Jean\"]\n\nfavorite_cats\n## ['Grumpy', 'Garfield', 'Jorts', 'Jean']\nfavorite_cats[1] = \"Nyan Cat\"\n\nfavorite_cats\n## ['Grumpy', 'Nyan Cat', 'Jorts', 'Jean']\n\n\n\n\nIf you’re curious about any of these cats, see the footnotes3.\n\n\n8.4.2 Indexing with Logical Vectors\nAs you might imagine, we can create vectors of all sorts of different data types. One particularly useful trick is to create a logical vector that goes along with a vector of another type to use as a logical index.\n\n\nlego vectors - a pink/purple hued set of 1x3 bricks representing the data and a corresponding set of 1x1 grey and black bricks representing the logical index vector of the same length\n\n\nIf we let the black lego represent “True” and the grey lego represent “False”, we can use the logical vector to pull out all values in the main vector.\n\n\n\n\n\n\nBlack = True, Grey = False\nGrey = True, Black = False\n\n\n\n\n\n\nNote that for logical indexing to work properly, the logical index must be the same length as the vector we’re indexing. This constraint will return when we talk about data frames, but for now just keep in mind that logical indexing doesn’t make sense when this constraint isn’t true.\n\n\nIndexing with logical vectors in R\nIndexing with logical vectors in python\n\n\n\n\n# Define a character vector\nweekdays <- c(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\")\nweekend <- c(\"Sunday\", \"Saturday\")\n\n# Create logical vectors\nrelax_days <- c(1, 0, 0, 0, 0, 0, 1) # doing this the manual way\nrelax_days <- weekdays %in% weekend # This creates a logical vector \n                                    # with less manual construction\nrelax_days\n## [1]  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE\n\nschool_days <- !relax_days # FALSE if weekend, TRUE if not\nschool_days\n## [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n\n# Using logical vectors to index the character vector\nweekdays[school_days] # print out all school days\n## [1] \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"\n\n\n\n\nimport numpy as np;\n\nanimals = np.array([\"Cat\", \"Dog\", \"Snake\", \"Lizard\", \"Tarantula\", \"Hamster\", \"Gerbil\", \"Otter\"])\n\n# Define a logical vector\ngood_pets = np.array([True, True, False, False, False, True, True, False])\nbad_pets = np.invert(good_pets) # Invert the logical vector \n                                # so True -> False and False -> True\n\nanimals[good_pets]\n## array(['Cat', 'Dog', 'Hamster', 'Gerbil'], dtype='<U9')\nanimals[bad_pets]\n## array(['Snake', 'Lizard', 'Tarantula', 'Otter'], dtype='<U9')\nanimals[~good_pets] # equivalent to using bad_pets\n## array(['Snake', 'Lizard', 'Tarantula', 'Otter'], dtype='<U9')\n\n\n\n\n\n8.4.3 Reviewing Types\nAs vectors are a collection of things of a single type, what happens if we try to make a vector with differently-typed things?\n\n\nR\nPython\n\n\n\n\nc(2L, FALSE, 3.1415, \"animal\") # all converted to strings\n## [1] \"2\"      \"FALSE\"  \"3.1415\" \"animal\"\n\nc(2L, FALSE, 3.1415) # converted to numerics\n## [1] 2.0000 0.0000 3.1415\n\nc(2L, FALSE) # converted to integers\n## [1] 2 0\n\n\n\n\nimport numpy as np\n\nnp.array([2, False, 3.1415, \"animal\"]) # all converted to strings\n## array(['2', 'False', '3.1415', 'animal'], dtype='<U32')\nnp.array([2, False, 3.1415]) # converted to floats\n## array([2.    , 0.    , 3.1415])\nnp.array([2, False]) # converted to integers\n## array([2, 0])\n\n\n\n\nAs a reminder, this is an example of implicit type conversion - R and python decide what type to use for you, going with the type that doesn’t lose data but takes up as little space as possible.\nTry it Out!\n\n\nProblem\nR Solution\nPython Solution\n\n\n\nCreate a vector of the integers from one to 30. Use logical indexing to pick out only the numbers which are multiples of 3.\n\n\n\nx <- 1:30\nx [ x %% 3 == 0]\n##  [1]  3  6  9 12 15 18 21 24 27 30\n\n\n\n\nimport numpy as np\nx = np.array(range(1, 31)) # because python is 0 indexed\nx[ x % 3 == 0]\n## array([ 3,  6,  9, 12, 15, 18, 21, 24, 27, 30])\n\n\n\n\n\n\nChallenge\nGeneral Solution\nR Solution\nPython Solution\n\n\n\nExtra challenge: Pick out numbers which are multiples of 2 or 3, but not multiples of 6!\n\n\nThis operation is xor, a.k.a. exclusive or. That is, X or Y, but not X AND Y.\nWe can write xor as (X OR Y) & !(X AND Y) – or we can use a predefined function: xor() in R, ^ in python.\n\n\n\nx <- 1:30\n\nx2 <- x %% 2 == 0 # multiples of 2\nx3 <- x %% 3 == 0 # multiples of 3\nx2xor3 <- xor(x2, x3)\nx2xor3_2 <- (x2 | x3) & !(x2 & x3)\nx[x2xor3]\n##  [1]  2  3  4  8  9 10 14 15 16 20 21 22 26 27 28\nx[x2xor3_2]\n##  [1]  2  3  4  8  9 10 14 15 16 20 21 22 26 27 28\n\n\n\n\nimport numpy as np\nx = np.array(range(1, 31))\n\nx2 = x % 2 == 0 # multiples of 2\nx3 = x % 3 == 0 # multiples of 3\nx2xor3 = x2 ^ x3\n\nx[x2xor3]\n## array([ 2,  3,  4,  8,  9, 10, 14, 15, 16, 20, 21, 22, 26, 27, 28])"
  },
  {
    "objectID": "part-gen-prog/03-data-struct.html#matrices",
    "href": "part-gen-prog/03-data-struct.html#matrices",
    "title": "8  Vectors, Matrices, Arrays, and Control Structures",
    "section": "\n8.5 Matrices",
    "text": "8.5 Matrices\nA matrix is the next step after a vector - it’s a set of values arranged in a two-dimensional, rectangular format.\n\n\nMatrix (Lego)\nR\nPython\n\n\n\n\n\nlego depiction of a 3-row, 4-column matrix of 2x2 red-colored blocks\n\n\n\n\n\n# Minimal matrix in R: take a vector, \n# tell R how many rows you want\nmatrix(1:12, nrow = 3)\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9   12\n\nmatrix(1:12, ncol = 3) # or columns\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\n\n# by default, R will fill in column-by-column\n# the byrow parameter tells R to go row-by-row\nmatrix(1:12, nrow = 3, byrow = T)\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    2    3    4\n## [2,]    5    6    7    8\n## [3,]    9   10   11   12\n\n# We can also easily create square matrices \n# with a specific diagonal (this is useful for modeling)\ndiag(rep(1, times = 4))\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    0    0    0\n## [2,]    0    1    0    0\n## [3,]    0    0    1    0\n## [4,]    0    0    0    1\n\n\n\nIn python, matrices are just a special case of a class called ndarray - n-dimensional arrays.\n\nimport numpy as np\n# Minimal ndarray in python by typing in the values in a structured format\nnp.array([[0,  1,  2],\n          [3,  4,  5],\n          [6,  7,  8],\n          [9, 10, 11]])\n# This syntax creates a list of the rows we want in our matrix\n\n# Matrix in python using a data vector and size parameters\n## array([[ 0,  1,  2],\n##        [ 3,  4,  5],\n##        [ 6,  7,  8],\n##        [ 9, 10, 11]])\nnp.reshape(range(0,12), (3,4))\n## array([[ 0,  1,  2,  3],\n##        [ 4,  5,  6,  7],\n##        [ 8,  9, 10, 11]])\nnp.reshape(range(0,12), (4,3))\n## array([[ 0,  1,  2],\n##        [ 3,  4,  5],\n##        [ 6,  7,  8],\n##        [ 9, 10, 11]])\nnp.reshape(range(0,12), (3,4), order = 'F')\n## array([[ 0,  3,  6,  9],\n##        [ 1,  4,  7, 10],\n##        [ 2,  5,  8, 11]])\n\nIn python, we create 2-dimensional arrays (aka matrices) either by creating a list of rows to join together or by reshaping a 1-dimensional array. The trick with reshaping the 1-dimensional array is the order argument: ‘F’ stands for “Fortran-like” and ‘C’ stands for “C-like”… so to go by column, you use ‘F’ and to go by row, you use ‘C’. Totally intuitive, right?\n\n\n\nMost of the problems we’re going to work on will not require much in the way of matrix or array operations. For now, you need the following:\n\nKnow that matrices exist and what they are (2-dimensional arrays of numbers)\nUnderstand how they are indexed (because it is extremely similar to data frames that we’ll work with in the next chapter)\nBe aware that there are lots of functions that depend on matrix operations at their core (including linear regression)\n\nFor more on matrix operations and matrix calculations, see Chapter 12.\n\n8.5.1 Indexing in Matrices\nBoth R and python use [row, column] to index matrices. To extract the bottom-left element of a 3x4 matrix in R, we would use [3,1] to get to the third row and first column entry; in python, we would use [2,0] (remember that Python is 0-indexed).\nAs with vectors, you can replace elements in a matrix using assignment.\n\n\nR\nPython\n\n\n\n\nmy_mat <- matrix(1:12, nrow = 3, byrow = T)\n\nmy_mat[3,1] <- 500\n\nmy_mat\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    2    3    4\n## [2,]    5    6    7    8\n## [3,]  500   10   11   12\n\n\n\nRemember that zero-indexing!\n\nimport numpy as np\n\nmy_mat = np.reshape(range(1, 13), (3,4))\n\nmy_mat[2,0] = 500\n\nmy_mat\n## array([[  1,   2,   3,   4],\n##        [  5,   6,   7,   8],\n##        [500,  10,  11,  12]])\n\n\n\n\n\n8.5.2 Matrix Operations\nThere are a number of matrix operations that we need to know for basic programming purposes:\n\nscalar multiplication \\[c*\\textbf{X} = c * \\left[\\begin{array}{cc} x_{1,1} & x_{1, 2}\\\\x_{2,1} & x_{2,2}\\end{array}\\right] = \\left[\\begin{array}{cc} c*x_{1,1} & c*x_{1, 2}\\\\c*x_{2,1} & c*x_{2,2}\\end{array}\\right]\\]\n\ntranspose - flip the matrix across the left top -> right bottom diagonal. \\[t(\\textbf{X}) = \\left[\\begin{array}{cc} x_{1,1} & x_{1, 2}\\\\x_{2,1} & x_{2,2}\\end{array}\\right]^T = \\left[\\begin{array}{cc} x_{1,1} & x_{2,1}\\\\x_{1,2} & x_{2,2}\\end{array}\\right]\\]\n\nmatrix multiplication (dot product) - If you haven’t had this in Linear Algebra, here’s a preview. See [3] for a better explanation \\[\\textbf{X}*\\textbf{Y} = \\left[\\begin{array}{cc} x_{1,1} & x_{1, 2}\\\\x_{2,1} & x_{2,2}\\end{array}\\right] * \\left[\\begin{array}{cc} y_{1,1} \\\\y_{2,1} \\end{array}\\right] = \\left[\\begin{array}{c}x_{1,1}*y_{1,1} + x_{1,2}*y_{2,1} \\\\x_{2, 1}*y_{1,1} + x_{2,2}*y_{2,1}\\end{array}\\right]\\] Note that matrix multiplication depends on having matrices of compatible dimensions. If you have two matrices of dimension \\((a \\times b)\\) and \\((c \\times d)\\), then \\(b\\) must be equal to \\(c\\) for the multiplication to work, and your result will be \\((a \\times d)\\).\n\n\n\nR\nPython\n\n\n\n\nx <- matrix(c(1, 2, 3, 4), nrow = 2, byrow = T)\ny <- matrix(c(5, 6), nrow = 2)\n\n# Scalar multiplication\nx * 3\n##      [,1] [,2]\n## [1,]    3    6\n## [2,]    9   12\n3 * x\n##      [,1] [,2]\n## [1,]    3    6\n## [2,]    9   12\n\n# Transpose\nt(x)\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\nt(y)\n##      [,1] [,2]\n## [1,]    5    6\n\n# matrix multiplication (dot product)\nx %*% y\n##      [,1]\n## [1,]   17\n## [2,]   39\n\n\n\n\nimport numpy as np\nx = np.array([[1,2],[3,4]])\ny = np.array([[5],[6]])\n\n# scalar multiplication\nx*3\n## array([[ 3,  6],\n##        [ 9, 12]])\n3*x\n\n# transpose\n## array([[ 3,  6],\n##        [ 9, 12]])\nx.T # shorthand\n## array([[1, 3],\n##        [2, 4]])\nx.transpose() # Long form\n\n# Matrix multiplication (dot product)\n## array([[1, 3],\n##        [2, 4]])\nnp.dot(x, y)\n## array([[17],\n##        [39]])"
  },
  {
    "objectID": "part-gen-prog/03-data-struct.html#arrays",
    "href": "part-gen-prog/03-data-struct.html#arrays",
    "title": "8  Vectors, Matrices, Arrays, and Control Structures",
    "section": "\n8.6 Arrays",
    "text": "8.6 Arrays\nArrays are a generalized n-dimensional version of a vector: all elements have the same type, and they are indexed using square brackets in both R and python: [dim1, dim2, dim3, ...]\nI don’t think you will need to create 3+ dimensional arrays in this class, but if you want to try it out, here is some code.\n\n\nR\nPython\n\n\n\n\narray(1:8, dim = c(2,2,2))\n## , , 1\n## \n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n## \n## , , 2\n## \n##      [,1] [,2]\n## [1,]    5    7\n## [2,]    6    8\n\nNote that displaying this requires 2 slices, since it’s hard to display 3D information in a 2D terminal arrangement.\n\n\n\nimport numpy as np\n\nnp.array([[[1,2],[3,4]],[[5,6], [7,8]]])\n## array([[[1, 2],\n##         [3, 4]],\n## \n##        [[5, 6],\n##         [7, 8]]])"
  },
  {
    "objectID": "part-gen-prog/03-data-struct.html#data-frames",
    "href": "part-gen-prog/03-data-struct.html#data-frames",
    "title": "8  Vectors, Matrices, Arrays, and Control Structures",
    "section": "\n8.7 Data Frames",
    "text": "8.7 Data Frames\nA data frame is a special type of list - one in which each element in the list is a vector of the same length. If you put these vectors side-by-side, you get a table of data that looks like a spreadsheet. In Python, a DataFrame is a dict of Series.\nThe lego version of a data frame looks like this:\n\n\nA data frame with 4 columns. A data frame is essentially a list where all of the components are vectors or lists, and are constrained to have the same length.\n\n\n\n\nR\nPython\n\n\n\nWhen you examine the structure of a data frame, as shown below, you get each column shown in a row, with its type and the first few values in the column. The head(n) command shows the first \\(n\\) rows of a data frame (enough to see what’s there, not enough to overflow your screen).\n\ndata(mtcars) # Load the data -- included in base R\nhead(mtcars) # Look at the first 6 rows\n##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb\n## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\nstr(mtcars) # Examine the structure of the object\n## 'data.frame':    32 obs. of  11 variables:\n##  $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n##  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n##  $ disp: num  160 160 108 258 360 ...\n##  $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n##  $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n##  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n##  $ qsec: num  16.5 17 18.6 19.4 17 ...\n##  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n##  $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n##  $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n##  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n\nYou can change column values or add new columns easily using assignment. The summary() function can be used on specific columns to perform summary operations (a 5-number summary useful for making e.g. boxplots is provided by default).\n\nmtcars$gpm <- 1/mtcars$mpg # gpm is sometimes used to assess efficiency\n\nsummary(mtcars$gpm)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n## 0.02950 0.04386 0.05208 0.05423 0.06483 0.09615\nsummary(mtcars$mpg)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   10.40   15.43   19.20   20.09   22.80   33.90\n\nOften, it is useful to know the dimensions of a data frame. The number of rows can be obtained by using nrow(df) and similarly, the columns can be obtained using ncol(df) (or, get both with dim()). There is also an easy way to get a summary of each column in the data frame, using summary().\n\nsummary(mtcars)\n##       mpg             cyl             disp             hp       \n##  Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0  \n##  1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5  \n##  Median :19.20   Median :6.000   Median :196.3   Median :123.0  \n##  Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7  \n##  3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0  \n##  Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0  \n##       drat             wt             qsec             vs        \n##  Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :0.0000  \n##  1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:0.0000  \n##  Median :3.695   Median :3.325   Median :17.71   Median :0.0000  \n##  Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :0.4375  \n##  3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:1.0000  \n##  Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :1.0000  \n##        am              gear            carb            gpm         \n##  Min.   :0.0000   Min.   :3.000   Min.   :1.000   Min.   :0.02950  \n##  1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.000   1st Qu.:0.04386  \n##  Median :0.0000   Median :4.000   Median :2.000   Median :0.05208  \n##  Mean   :0.4062   Mean   :3.688   Mean   :2.812   Mean   :0.05423  \n##  3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000   3rd Qu.:0.06483  \n##  Max.   :1.0000   Max.   :5.000   Max.   :8.000   Max.   :0.09615\ndim(mtcars)\n## [1] 32 12\nnrow(mtcars)\n## [1] 32\nncol(mtcars)\n## [1] 12\n\nMissing variables in an R data frame are indicated with NA.\n\n\nWhen you examine the structure of a data frame, as shown below, you get each column shown in a row, with its type and the first few values in the column. The df.head(n) command shows the first \\(n\\) rows of a data frame (enough to see what’s there, not enough to overflow your screen).\n\nmtcars = pd.read_csv(\"https://vincentarelbundock.github.io/Rdatasets/csv/datasets/mtcars.csv\")\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'pd' is not defined\nmtcars.head(5)\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'mtcars' is not defined\nmtcars.info()\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'mtcars' is not defined\n\nYou can change column values or add new columns easily using assignment. It’s also easy to access specific columns to perform summary operations. You can access a column named xyz using df.xyz or using df[\"xyz\"]. To create a new column, you must use df[\"xyz\"].\n\nmtcars[\"gpm\"] = 1/mtcars.mpg # gpm is sometimes used to assess efficiency\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'mtcars' is not defined\nmtcars.gpm.describe()\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'mtcars' is not defined\nmtcars.mpg.describe()\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'mtcars' is not defined\n\nOften, it is useful to know the dimensions of a data frame. The dimensions of a data frame (rows x columns) can be accessed using df.shape. There is also an easy way to get a summary of each column in the data frame, using df.describe().\n\nmtcars.describe()\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'mtcars' is not defined\nmtcars.shape\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'mtcars' is not defined\n\nMissing variables in a pandas data frame are indicated with nan or NULL.\n\n\n\n\n\n\n\n\n\nTry it out: Data Frames\n\n\n\n\n\nSetup\nProblem\nR Solution\nPython Solution\n\n\n\nThe dataset state.x77 contains information on US state statistics in the 1970s. By default, it is a matrix, but we can easily convert it to a data frame, as shown below.\n\ndata(state)\nstate_facts <- data.frame(state.x77)\nstate_facts <- cbind(state = row.names(state_facts), state_facts, stringsAsFactors = F) \n# State names were stored as row labels\n# Store them in a variable instead, and add it to the data frame\n\nrow.names(state_facts) <- NULL # get rid of row names\n\nhead(state_facts)\n##        state Population Income Illiteracy Life.Exp Murder HS.Grad Frost   Area\n## 1    Alabama       3615   3624        2.1    69.05   15.1    41.3    20  50708\n## 2     Alaska        365   6315        1.5    69.31   11.3    66.7   152 566432\n## 3    Arizona       2212   4530        1.8    70.55    7.8    58.1    15 113417\n## 4   Arkansas       2110   3378        1.9    70.66   10.1    39.9    65  51945\n## 5 California      21198   5114        1.1    71.71   10.3    62.6    20 156361\n## 6   Colorado       2541   4884        0.7    72.06    6.8    63.9   166 103766\n\n# Write data out so that we can read it in using Python\nwrite.csv(state_facts, file = \"data/state_facts.csv\", row.names = F)\n## Error in file(file, ifelse(append, \"a\", \"w\")): cannot open the connection\n\nWe can write out the built in R data and read it in using pd.read_csv, which creates a DataFrame in pandas.\n\nimport pandas as pd\n## Error in py_call_impl(callable, dots$args, dots$keywords): ModuleNotFoundError: No module named 'pandas'\nstate_facts = pd.read_csv(\"https://raw.githubusercontent.com/srvanderplas/unl-stat850/main/data/state_facts.csv\")\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'pd' is not defined\n\n\n\n\nHow many rows and columns does it have? Can you find different ways to get that information?\nThe Illiteracy column contains the percent of the population of each state that is illiterate. Calculate the number of people in each state who are illiterate, and store that in a new column called TotalNumIlliterate. Note: Population contains the population in thousands.\nCalculate the average population density of each state (population per square mile) and store it in a new column PopDensity. Using the R reference card, can you find functions that you can combine to get the state with the minimum population density?\n\n\n\n\n# 3 ways to get rows and columns\nstr(state_facts)\n## 'data.frame':    50 obs. of  9 variables:\n##  $ state     : chr  \"Alabama\" \"Alaska\" \"Arizona\" \"Arkansas\" ...\n##  $ Population: num  3615 365 2212 2110 21198 ...\n##  $ Income    : num  3624 6315 4530 3378 5114 ...\n##  $ Illiteracy: num  2.1 1.5 1.8 1.9 1.1 0.7 1.1 0.9 1.3 2 ...\n##  $ Life.Exp  : num  69 69.3 70.5 70.7 71.7 ...\n##  $ Murder    : num  15.1 11.3 7.8 10.1 10.3 6.8 3.1 6.2 10.7 13.9 ...\n##  $ HS.Grad   : num  41.3 66.7 58.1 39.9 62.6 63.9 56 54.6 52.6 40.6 ...\n##  $ Frost     : num  20 152 15 65 20 166 139 103 11 60 ...\n##  $ Area      : num  50708 566432 113417 51945 156361 ...\ndim(state_facts)\n## [1] 50  9\nnrow(state_facts)\n## [1] 50\nncol(state_facts)\n## [1] 9\n\n# Illiteracy\nstate_facts$TotalNumIlliterate <- state_facts$Population * 1e3 * (state_facts$Illiteracy/100) \n\n# Population Density\nstate_facts$PopDensity <- state_facts$Population * 1e3/state_facts$Area \n# in people per square mile\n\n# minimum population\nstate_facts$state[which.min(state_facts$PopDensity)]\n## [1] \"Alaska\"\n\n\n\n\n# Ways to get rows and columns\nstate_facts.shape\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'state_facts' is not defined\nstate_facts.index.size # rows\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'state_facts' is not defined\nstate_facts.columns.size # columns\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'state_facts' is not defined\nstate_facts.info() # columns + rows + missing counts + data types\n\n# Illiteracy\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'state_facts' is not defined\nstate_facts[\"TotalNumIlliterate\"] = state_facts[\"Population\"] * 1e3 * state_facts[\"Illiteracy\"]/100\n\n# Population Density\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'state_facts' is not defined\nstate_facts[\"PopDensity\"] = state_facts[\"Population\"] * 1e3/state_facts[\"Area\"] \n# in people per square mile\n\n# minimum population\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'state_facts' is not defined\nmin_dens = state_facts[\"PopDensity\"].min()\n# Get location of minimum population\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'state_facts' is not defined\nloc_min_dens = state_facts.PopDensity.isin([min_dens])\n# Pull out matching state\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'state_facts' is not defined\nstate_facts.state[loc_min_dens]\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'state_facts' is not defined\n\n\n\n\n\n\n\n8.7.1 Creating Data Frames\nIt is also possible to create data frames from scratch by building them out of simpler components, such as vectors or dicts of lists. This tends to be useful for small data sets, but it is more common to read data in from e.g. CSV files, which I’ve used several times already but haven’t yet shown you how to do (see Chapter 13 for the full how-to).\n\n\nR\nPython\n\n\n\n\nmath_and_lsd <- data.frame(\n  lsd_conc = c(1.17, 2.97, 3.26, 4.69, 5.83, 6.00, 6.41),\n  test_score = c(78.93, 58.20, 67.47, 37.47, 45.65, 32.92, 29.97))\nmath_and_lsd\n##   lsd_conc test_score\n## 1     1.17      78.93\n## 2     2.97      58.20\n## 3     3.26      67.47\n## 4     4.69      37.47\n## 5     5.83      45.65\n## 6     6.00      32.92\n## 7     6.41      29.97\n\n# add a column - character vector\nmath_and_lsd$subjective <- c(\"finally coming back\", \"getting better\", \"it's totally better\", \"really tripping out\", \"is it over?\", \"whoa, man\", \"I can taste color, but I can't do math\")\n\nmath_and_lsd\n##   lsd_conc test_score                             subjective\n## 1     1.17      78.93                    finally coming back\n## 2     2.97      58.20                         getting better\n## 3     3.26      67.47                    it's totally better\n## 4     4.69      37.47                    really tripping out\n## 5     5.83      45.65                            is it over?\n## 6     6.00      32.92                              whoa, man\n## 7     6.41      29.97 I can taste color, but I can't do math\n\n\n\n\nmath_and_lsd = pd.DataFrame({\n  \"lsd_conc\": [1.17, 2.97, 3.26, 4.69, 5.83, 6.00, 6.41],\n  \"test_score\": [78.93, 58.20, 67.47, 37.47, 45.65, 32.92, 29.97]})\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'pd' is not defined\nmath_and_lsd\n\n# add a column - character vector\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'math_and_lsd' is not defined\nmath_and_lsd[\"subjective\"] = [\"finally coming back\", \"getting better\", \"it's totally better\", \"really tripping out\", \"is it over?\", \"whoa, man\", \"I can taste color, but I can't do math\"]\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'math_and_lsd' is not defined\nmath_and_lsd\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'math_and_lsd' is not defined"
  },
  {
    "objectID": "part-gen-prog/03-data-struct.html#sec-data-struct-refs",
    "href": "part-gen-prog/03-data-struct.html#sec-data-struct-refs",
    "title": "8  Vectors, Matrices, Arrays, and Control Structures",
    "section": "\n8.8 References",
    "text": "8.8 References\n\n\n\n\n[1] \nN. Matloff, The art of r programming: A tour of statistical software design. No Starch Press, 2011 [Online]. Available: https://books.google.com/books?id=o2aLBAAAQBAJ\n\n\n\n[2] \nM. Fripp, “Answer to \"python pandas dataframe, is it pass-by-value or pass-by-reference\". Stack overflow,” Aug. 12, 2016. [Online]. Available: https://stackoverflow.com/a/38925257/2859168. [Accessed: Jan. 10, 2023]\n\n\n[3] \nMathIsFun.com, “How to multiply matrices. Math is fun,” 2021. [Online]. Available: https://www.mathsisfun.com/algebra/matrix-multiplying.html. [Accessed: Jan. 10, 2023]"
  },
  {
    "objectID": "part-gen-prog/04-control-struct.html#conditional-statements",
    "href": "part-gen-prog/04-control-struct.html#conditional-statements",
    "title": "9  Control Structures",
    "section": "\n9.1 Conditional Statements",
    "text": "9.1 Conditional Statements\nConditional statements determine if code is evaluated.\nThey look like this:\nif (condition)\n  then\n    (thing to do)\n  else\n    (other thing to do)\nThe else (other thing to do) part may be omitted.\nWhen this statement is read by the computer, the computer checks to see if condition is true or false. If the condition is true, then (thing to do) is also run. If the condition is false, then (other thing to do) is run instead.\nLet’s try this out:\n\n\nR\nPython\n\n\n\n\nx <- 3\ny <- 1\n\nif (x > 2) { \n  y <- 8\n} else {\n  y <- 4\n}\n\nprint(paste(\"x =\", x, \"; y =\", y))\n## [1] \"x = 3 ; y = 8\"\n\nIn R, the logical condition after if must be in parentheses. It is common to then enclose the statement to be run if the condition is true in {} so that it is clear what code matches the if statement. You can technically put the condition on the line after the if (x > 2) line, and everything will still work, but then it gets hard to figure out what to do with the else statement - it technically would also go on the same line, and that gets hard to read.\n\nx <- 3\ny <- 1\n\nif (x > 2) y <- 8 else y <- 4\n\nprint(paste(\"x =\", x, \"; y =\", y))\n## [1] \"x = 3 ; y = 8\"\n\nSo while the 2nd version of the code technically works, the first version with the brackets is much easier to read and understand. Please try to emulate the first version!\n\n\n\nx = 3\ny = 1\n\nif x > 2:\n  y = 8\nelse:\n  y = 4\n\nprint(\"x =\", x, \"; y =\", y)\n## x = 3 ; y = 8\n\nIn python, all code grouping is accomplished with spaces instead of with brackets. So in python, we write our if statement as if x > 2: with the colon indicating that what follows is the code to evaluate. The next line is indented with 2 spaces to show that the code on those lines belongs to that if statement. Then, we use the else: statement to provide an alternative set of code to run if the logical condition in the if statement is false. Again, we indent the code under the else statement to show where it “belongs”.\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nPython will throw errors if you mess up the spacing. This is one thing that is very annoying about Python… but it’s a consequence of trying to make the code more readable.\n\n\n\n9.1.1 Representing Conditional Statements as Diagrams\nA common way to represent conditional logic is to draw a flow chart diagram.\nIn a flow chart, conditional statements are represented as diamonds, and other code is represented as a rectangle. Yes/no or True/False branches are labeled. Typically, after a conditional statement, the program flow returns to a single point.\n\n\nProgram flow diagram outline of a simple if/else statement\n\n\n\n9.1.2 Chaining Conditional Statements: Else-If\nIn many cases, it can be helpful to have a long chain of conditional statements describing a sequence of alternative statements.\n\n\n\n\n\n\nExample - Conditional Evaluation\n\n\n\nSuppose I want to determine what categorical age bracket someone falls into based on their numerical age. All of the bins are mutually exclusive - you can’t be in the 25-40 bracket and the 41-55 bracket.\n\n\nProgram Flow Map\nR\nPython\n\n\n\n\n\nProgram flow map for a series of mutually exclusive categories. If our goal is to take a numeric age variable and create a categorical set of age brackets, such as <18, 18-25, 26-40, 41-55, 56-65, and >65, we can do this with a series of if-else statements chained together. Only one of the bracket assignments is evaluated, so it is important to place the most restrictive condition first.\n\n\nThe important thing to realize when examining this program flow map is that if age <= 18 is true, then none of the other conditional statements even get evaluated. That is, once a statement is true, none of the other statements matter. Because of this, it is important to place the most restrictive statement first.\n\n\nProgram flow map for a series of mutually exclusive categories, emphasizing that only some statements are evaluated. When age = 40, only (age <= 18), (age <= 25), and (age <= 40) are evaluated conditionally. Of the assignment statements, only bracket = ‘26-40’ is evaluated when age = 40.\n\n\nIf for some reason you wrote your conditional statements in the wrong order, the wrong label would get assigned:\n\n\nProgram flow map for a series of mutually exclusive categories, with category labels in the wrong order - <40 is evaluated first, and so <= 25 and <= 18 will never be evaluated and the wrong label will be assigned for anything in those categories.\n\n\nIn code, we would write this statement using else-if (or elif) statements.\n\n\n\nage <- 40 # change this as you will to see how the code works\n\nif (age < 18) {\n  bracket <- \"<18\"\n} else if (age <= 25) {\n  bracket <- \"18-25\"\n} else if (age <= 40) {\n  bracket <- \"26-40\"\n} else if (age <= 55) {\n  bracket <- \"41-55\" \n} else if (age <= 65) {\n  bracket <- \"56-65\"\n} else {\n  bracket <- \">65\"\n}\n\nbracket\n## [1] \"26-40\"\n\n\n\nPython uses elif as a shorthand for else if statements. As always, indentation/white space in python matters. If you put an extra blank line between two elif statements, then the interpreter will complain. If you don’t indent properly, the interpreter will complain.\n\nage = 40 # change this to see how the code works\n\nif age < 18:\n  bracket = \"<18\"\nelif age <= 25:\n  bracket = \"18-25\"\nelif age <= 40:\n  bracket = \"26-40\"\nelif age <= 55:\n  bracket = \"41-55\"\nelif age <= 65:\n  bracket = \"56-65\"\nelse:\n  bracket = \">65\"\n  \nbracket\n## '26-40'\n\n\n\n\n\n\n\n\n\n\n\n\nTry it out - Chained If/Else Statements\n\n\n\n\n\nProblem\nFlow Map\nR Solution\nPython Solution\n\n\n\nThe US Tax code has brackets, such that the first $10,275 of your income is taxed at 10%, anything between $10,275 and $41,775 is taxed at 12%, and so on.\nHere is the table of tax brackets for single filers in 2022:\n\n\nrate\nIncome\n\n\n\n10%\n$0 to $10,275\n\n\n12%\n$10,275 to $41,775\n\n\n22%\n$41,775 to $89,075\n\n\n24%\n$89,075 to $170,050\n\n\n32%\n$170,050 to $215,950\n\n\n35%\n$215,950 to $539,900\n\n\n37%\n$539,900 or more\n\n\n\nNote: For the purposes of this problem, we’re ignoring the personal exemption and the standard deduction, so we’re already simplifying the tax code.\nWrite a set of if statements that assess someone’s income and determine what their overall tax rate is.\nHint: You may want to keep track of how much of the income has already been taxed in a variable and what the total tax accumulation is in another variable.\n\n\n\n\n\n\n\n\nThe control flow diagram for the tax brackets\n\n\nControl flow diagrams can be extremely helpful when figuring out how programs work (and where gaps in your logic are when you’re debugging). It can be very helpful to map out your program flow as you’re untangling a problem.\n\n\n\n# Start with total income\nincome <- 200000\n\n# x will hold income that hasn't been taxed yet\nx <- income\n# y will hold taxes paid\ny <- 0\n\nif (x <= 10275) {\n  y <- x*.1 # tax paid\n  x <- 0 # All money has been taxed\n} else {\n  y <- y + 10275 * .1\n  x <- x - 10275 # Money remaining that hasn't been taxed\n}\n\nif (x <= (41775 - 10275)) {\n  y <- y + x * .12\n  x <- 0\n} else {\n  y <- y + (41775 - 10275) * .12\n  x <- x - (41775 - 10275) \n}\n\nif (x <= (89075 - 41775)) {\n  y <- y + x * .22\n  x <- 0\n} else {\n  y <- y + (89075 - 41775) * .22\n  x <- x - (89075 - 41775)\n}\n\nif (x <= (170050 - 89075)) {\n  y <- y + x * .24\n  x <- 0\n} else {\n  y <- y + (170050 - 89075) * .24\n  x <- x - (170050 - 89075)\n}\n\nif (x <= (215950 - 170050)) {\n  y <- y + x * .32\n  x <- 0\n} else {\n  y <- y + (215950 - 170050) * .32\n  x <- x - (215950 - 170050)\n}\n\nif (x <= (539900 - 215950)) {\n  y <- y + x * .35\n  x <- 0\n} else {\n  y <- y + (539900 - 215950) * .35\n  x <- x - (539900 - 215950)\n}\n\nif (x > 0) {\n  y <- y + x * .37\n}\n\n\nprint(paste(\"Total Tax Rate on $\", income, \" in income = \", round(y/income, 4)*100, \"%\"))\n## [1] \"Total Tax Rate on $ 2e+05  in income =  22.12 %\"\n\n\n\n\n# Start with total income\nincome = 200000\n\n# untaxed will hold income that hasn't been taxed yet\nuntaxed = income\n# taxed will hold taxes paid\ntaxes = 0\n\nif untaxed <= 10275:\n  taxes = untaxed*.1 # tax paid\n  untaxed = 0 # All money has been taxed\nelse:\n  taxes = taxes + 10275 * .1\n  untaxed = untaxed - 10275 # money remaining that hasn't been taxed\n\nif untaxed <= (41775 - 10275):\n  taxes = taxes + untaxed * .12\n  untaxed = 0\nelse:\n  taxes = taxes + (41775 - 10275) * .12\n  untaxed = untaxed - (41775 - 10275) \n\n\nif untaxed <= (89075 - 41775):\n  taxes = taxes + untaxed * .22\n  untaxed = 0\nelse: \n  taxes = taxes + (89075 - 41775) * .22\n  untaxed = untaxed - (89075 - 41775)\n\nif untaxed <= (170050 - 89075):\n  taxes = taxes + untaxed * .24\n  untaxed = 0\nelse: \n  taxes = taxes + (170050 - 89075) * .24\n  untaxed = untaxed - (170050 - 89075)\n\nif untaxed <= (215950 - 170050):\n  taxes = taxes + untaxed * .32\n  untaxed = 0\nelse:\n  taxes = taxes + (215950 - 170050) * .32\n  untaxed = untaxed - (215950 - 170050)\n\nif untaxed <= (539900 - 215950):\n  taxes = taxes + untaxed * .35\n  untaxed = 0\nelse: \n  taxes = taxes + (539900 - 215950) * .35\n  untaxed = untaxed - (539900 - 215950)\n\n\nif untaxed > 0:\n  taxes = taxes + untaxed * .37\n\n\n\nprint(\"Total Tauntaxed Rate on $\", income, \" in income = \", round(taxes/income, 4)*100, \"%\")\n## Total Tauntaxed Rate on $ 200000  in income =  22.12 %\n\nWe will find a better way to represent this calculation once we discuss loops - we can store each bracket’s start and end point in a vector and loop through them. Any time you find yourself copy-pasting code and changing values, you should consider using a loop (or eventually a function) instead."
  },
  {
    "objectID": "part-gen-prog/04-control-struct.html#loops",
    "href": "part-gen-prog/04-control-struct.html#loops",
    "title": "9  Control Structures",
    "section": "\n9.2 Loops",
    "text": "9.2 Loops\n\nOften, we write programs which update a variable in a way that the new value of the variable depends on the old value:\nx = x + 1\nThis means that we add one to the current value of x.\nBefore we write a statement like this, we have to initialize the value of x because otherwise, we don’t know what value to add one to.\nx = 0\nx = x + 1\nWe sometimes use the word increment to talk about adding one to the value of x; decrement means subtracting one from the value of x.\nA particularly powerful tool for making these types of repetitive changes in programming is the loop, which executes statements a certain number of times. Loops can be written in several different ways, but all loops allow for executing a block of code a variable number of times.\n\n9.2.1 While Loops\nIn the previous section, we discussed conditional statements, where a block of code is only executed if a logical statement is true. The simplest type of loop is the while loop, which executes a block of code until a statement is no longer true.\n\n\n\n\n\n\nExample - While Loops\n\n\n\n\n\nFlow Map\nR\nPython\n\n\n\n\n\nFlow map showing while-loop pseudocode (while x <= N) { # code that changes x in some way} and the program flow map expansion where we check if x > N (exiting the loop if true); otherwise, we continue into the loop, execute the main body of #code and then change x and start over.\n\n\n\n\n\nx <- 0\n\nwhile (x < 10) { \n  # Everything in here is executed \n  # during each iteration of the loop\n  print(x)\n  x <- x + 1\n}\n## [1] 0\n## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\n## [1] 7\n## [1] 8\n## [1] 9\n\n\n\n\nx = 0\n\nwhile x < 10:\n  print(x)\n  x = x + 1\n## 0\n## 1\n## 2\n## 3\n## 4\n## 5\n## 6\n## 7\n## 8\n## 9\n\n\n\n\n\n\n\n\n\n\n\n\nTry it Out - While Loops\n\n\n\n\n\nProblem\nMath Notation\nR Solution\nPython solution\n\n\n\nWrite a while loop that verifies that \\[\\lim_{N \\rightarrow \\infty} \\prod_{k=1}^N \\left(1 + \\frac{1}{k^2}\\right) = \\frac{e^\\pi - e^{-\\pi}}{2\\pi}.\\]\nTerminate your loop when you get within 0.0001 of \\(\\frac{e^\\pi - e^{-\\pi}}{2\\pi}\\). At what value of \\(k\\) is this point reached?\n\n\nBreaking down math notation for code:\n\nIf you are unfamiliar with the notation \\(\\prod_{k=1}^N f(k)\\), this is the product of \\(f(k)\\) for \\(k = 1, 2, ..., N\\), \\[f(1)\\cdot f(2)\\cdot ... \\cdot f(N)\\]\nTo evaluate a limit, we just keep increasing \\(N\\) until we get arbitrarily close to the right hand side of the equation.\n\nIn this problem, we can just keep increasing \\(k\\) and keep track of the cumulative product. So we define k=1, prod = 1, and ans before the loop starts. Then, we loop over k, multiplying prod by \\((1 + 1/k^2)\\) and then incrementing \\(k\\) by one each time. At each iteration, we test whether prod is close enough to ans to stop the loop.\n\n\nIn R, you will use pi and exp() - these are available by default without any additional libraries or packages.\n\nk <- 1\nprod <- 1\nans <- (exp(pi) - exp(-pi))/(2*pi)\ndelta <- 0.0001\n\nwhile (abs(prod - ans) >= 0.0001) {\n  prod <- prod * (1 + 1/k^2)\n  k <- k + 1\n}\n\nk\n## [1] 36761\nprod\n## [1] 3.675978\nans\n## [1] 3.676078\n\n\n\nNote that in python, you will have to import the math library to get the values of pi and the exp function. You can refer to these as math.pi and math.exp() respectively.\n\nimport math\n\nk = 1\nprod = 1\nans = (math.exp(math.pi) - math.exp(-math.pi))/(2*math.pi)\ndelta = 0.0001\n\nwhile abs(prod - ans) >= 0.0001:\n  prod = prod * (1 + k**-2)\n  k = k + 1\n  if k > 500000:\n    break\n\n\nprint(\"At \", k, \" iterations, the product is \", prod, \"compared to the limit \", ans,\".\")\n## At  36761  iterations, the product is  3.675977910975878 compared to the limit  3.676077910374978 .\n\n\n\n\n\n\n\n\n\n\n\n\nWarning: Avoid Infinite Loops\n\n\n\nIt is very easy to create an infinite loop when you are working with while loops. Infinite loops never exit, because the condition is always true. If in the while loop example we decrement x instead of incrementing x, the loop will run forever.\nYou want to try very hard to avoid ever creating an infinite loop - it can cause your session to crash.\nOne common way to avoid infinite loops is to create a second variable that just counts how many times the loop has run. If that variable gets over a certain threshold, you exit the loop.\n\n\nR\nPython\n\n\n\nThis while loop runs until either x < 10 or n > 50 - so it will run an indeterminate number of times and depends on the random values added to x. Since this process (a ‘random walk’) could theoretically continue forever, we add the n>50 check to the loop so that we don’t tie up the computer for eternity.\n\nx <- 0\nn <- 0 # count the number of times the loop runs\n\nwhile (x < 10) { \n  print(x)\n  x <- x + rnorm(1) # add a random normal (0, 1) draw each time\n  n <- n + 1\n  if (n > 50) \n    break # this stops the loop if n > 50\n}\n## [1] 0\n## [1] 0.7663695\n## [1] 0.6916474\n## [1] 0.1560627\n## [1] 0.3049669\n## [1] 0.6713217\n## [1] 0.565267\n## [1] 0.9019003\n## [1] -0.2484665\n## [1] -0.4224632\n## [1] -0.7467641\n## [1] -1.088828\n## [1] -2.01091\n## [1] -0.4266778\n## [1] -0.9332609\n## [1] -0.5159336\n## [1] 0.5332492\n## [1] 0.8082018\n## [1] -0.4578172\n## [1] -0.4757312\n## [1] -0.892661\n## [1] -0.5324376\n## [1] -1.04227\n## [1] -2.663171\n## [1] -2.914548\n## [1] -2.503939\n## [1] -2.039351\n## [1] -0.05067776\n## [1] -0.1977406\n## [1] -0.5952903\n## [1] 0.284483\n## [1] -0.6241905\n## [1] -1.623226\n## [1] -2.126691\n## [1] -0.4863301\n## [1] -0.2658294\n## [1] -0.7757274\n## [1] -0.8769397\n## [1] -0.515018\n## [1] 0.6776994\n## [1] 0.7597403\n## [1] 0.979793\n## [1] -0.9245092\n## [1] 0.5888193\n## [1] -1.080682\n## [1] -1.779875\n## [1] -0.6162698\n## [1] -0.4827826\n## [1] -0.0386485\n## [1] 0.2714825\n## [1] -0.1793772\n\n\n\n\nimport numpy as np; # for the random normal draw\n\nx = 0\nn = 0 # count the number of times the loop runs\n\nwhile x < 10:\n  print(x)\n  x = x + np.random.normal(0, 1, 1) # add a random normal (0, 1) draw each time\n  n = n + 1\n  if n > 50:\n    break # this stops the loop if n > 50\n## 0\n## [1.14036002]\n## [1.28985273]\n## [0.56089606]\n## [2.16878824]\n## [0.65288158]\n## [0.78564367]\n## [1.26336149]\n## [1.68142125]\n## [1.15020679]\n## [1.98932943]\n## [1.67968289]\n## [0.85256507]\n## [1.20961438]\n## [1.53103144]\n## [2.58959883]\n## [2.41903881]\n## [4.07443875]\n## [4.73428571]\n## [4.93206485]\n## [5.47656297]\n## [5.64975817]\n## [6.75073581]\n## [5.24720387]\n## [3.54315054]\n## [3.15053175]\n## [3.07689963]\n## [4.93880272]\n## [5.34713704]\n## [6.69901367]\n## [8.38163482]\n## [8.18711008]\n## [7.56301681]\n## [7.90903157]\n## [6.87630933]\n## [6.22014504]\n## [5.438693]\n## [5.83645463]\n## [6.53881576]\n## [6.8413142]\n## [7.45970054]\n## [8.12243588]\n## [9.05386587]\n## [8.98017889]\n## [8.90437333]\n## [7.83633957]\n## [7.41406837]\n## [6.33510989]\n## [4.45919431]\n## [5.64701861]\n## [4.56339666]\n\n\n\n\nIn both of the examples above, there are more efficient ways to write a random walk, but we will get to that later. The important thing here is that we want to make sure that our loops don’t run for all eternity.\n\n\n\n9.2.2 For Loops\nAnother common type of loop is a for loop. In a for loop, we run the block of code, iterating through a series of values (commonly, one to N, but not always). Generally speaking, for loops are known as definite loops because the code inside a for loop is executed a specific number of times. While loops are known as indefinite loops because the code within a while loop is evaluated until the condition is falsified, which is not always a known number of times.\n\n\n\n\n\n\nExample - For Loop Syntax\n\n\n\n\n\nFlow Map\nR\nPython\n\n\n\n\n\nFlow map showing for-loop pseudocode (for j in 1 to N) { # code} and the program flow map expansion where j starts at 1 and we check if j > N (exiting the loop if true); otherwise, we continue into the loop, execute the main body of #code and then increment j and start over.\n\n\n\n\n\nfor (i in 1:5 ) {\n  print(i)\n}\n## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\n\n\n\n\nfor i in range(5):\n  print(i)\n## 0\n## 1\n## 2\n## 3\n## 4\n\nBy default range(5) goes from 0 to 5, the upper bound. When i = 5 the loop exits. This is because range(5) creates a vector [0, 1, 2, 3, 4].\n\n\n\n\n\nFor loops are often run from 1 to N (or 0 to N-1 in python) but in essence, a for loop is very commonly used to do a task for every value of a vector.\n\n9.2.2.1 Example - For Loops\n\n\nR\nPython\n\n\n\nFor instance, in R, there is a built-in variable called month.name. Type month.name into your R console to see what it looks like. If we want to iterate along the values of month.name, we can:\n\nfor (i in month.name)\n  print(i)\n## [1] \"January\"\n## [1] \"February\"\n## [1] \"March\"\n## [1] \"April\"\n## [1] \"May\"\n## [1] \"June\"\n## [1] \"July\"\n## [1] \"August\"\n## [1] \"September\"\n## [1] \"October\"\n## [1] \"November\"\n## [1] \"December\"\n\n\n\nIn python, we have to define our vector or list to start out with, but that’s easy enough:\n\nfuturama_crew = ['Fry', 'Leela', 'Bender', 'Amy', 'the Professor', 'Hermes', 'Zoidberg', 'Nibbler']\nfor i in futurama_crew:\n  print(i)\n## Fry\n## Leela\n## Bender\n## Amy\n## the Professor\n## Hermes\n## Zoidberg\n## Nibbler"
  },
  {
    "objectID": "part-gen-prog/04-control-struct.html#other-control-structures",
    "href": "part-gen-prog/04-control-struct.html#other-control-structures",
    "title": "9  Control Structures",
    "section": "\n9.3 Other Control Structures",
    "text": "9.3 Other Control Structures\n\n9.3.1 Conditional Statements\ncase statements, e.g. case_when in tidyverse\n\n9.3.2 Loops\n\n9.3.2.1 Controlling Loops\nWhile I do not often use break, next, and continue statements, they do exist in both languages and can be useful for controlling the flow of program execution. I have moved the section on this to Section 22.2 for the sake of brevity and to reduce the amount of new material those without programming experience are being exposed to in this section.\n\n9.3.2.2 Other Types of Loops\nThere are other types of loops in most languages, such as the do-while loop, which runs the code first and then evaluates the logical condition to determine whether the loop will be run again.\n\n\n\n\n\n\nExample: do-while loops\n\n\n\n\n\nR\nPython\n\n\n\nIn R, do-while loops are most naturally implemented using a very primitive type of iteration: a repeat statement.\n\nrepeat {\n  # statements go here\n  if (condition)\n    break # this exits the repeat statement\n}\n\n\n\nIn python, do-while loops are most naturally implemented using a while loop with condition TRUE:\n\nwhile TRUE:\n  # statements go here\n  if condition:\n    break\n\n\n\n\n\n\nAn additional means of running code an indeterminate number of times is the use of recursion, which we cannot cover until we learn about functions. I have added an additional section, Section 22.3, to cover this topic, but it is not essential to being able to complete most basic data programming tasks. Recursion is useful when working with structures such as trees (including phylogenetic trees) and nested lists."
  },
  {
    "objectID": "part-gen-prog/04-control-struct.html#sec-control-struct-refs",
    "href": "part-gen-prog/04-control-struct.html#sec-control-struct-refs",
    "title": "9  Control Structures",
    "section": "\n9.4 References",
    "text": "9.4 References"
  },
  {
    "objectID": "part-gen-prog/05-functions.html#objectives",
    "href": "part-gen-prog/05-functions.html#objectives",
    "title": "10  Writing Functions",
    "section": "\n10.1 Objectives",
    "text": "10.1 Objectives\n\nIdentify the parts of a function from provided source code\nPredict what the function will return when provided with input values and source code\nGiven a task, lay out the steps necessary to complete the task in pseudocode\nWrite a function which uses necessary input values to complete a task"
  },
  {
    "objectID": "part-gen-prog/05-functions.html#when-to-write-a-function",
    "href": "part-gen-prog/05-functions.html#when-to-write-a-function",
    "title": "10  Writing Functions",
    "section": "\n10.2 When to write a function?",
    "text": "10.2 When to write a function?\nIf you’ve written the same code (with a few minor changes, like variable names) more than twice, you should probably write a function instead. There are a few benefits to this rule:\n\nYour code stays neater (and shorter), so it is easier to read, understand, and maintain.\nIf you need to fix the code because of errors, you only have to do it in one place.\nYou can re-use code in other files by keeping functions you need regularly in a file (or if you’re really awesome, in your own package!)\nIf you name your functions well, your code becomes easier to understand thanks to grouping a set of actions under a descriptive function name.\n\n\n\n\n\n\n\nLearn more about functions\n\n\n\nThere is some extensive material on this subject in R for Data Science [1] on functions. If you want to really understand how functions work in R, that is a good place to go.\n\n\n\n\n\n\n\n\nExample: Turning Code into Functions\n\n\n\nThis example is modified from R for Data Science [2, Ch. 19].\nWhat does this code do? Does it work as intended?\n\n\nR\nPython\n\n\n\n\ndf <- tibble::tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n## Error in loadNamespace(x): there is no package called 'tibble'\n\ndf$a <- (df$a - min(df$a, na.rm = TRUE)) / \n  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))\n## Error in df$a: object of type 'closure' is not subsettable\ndf$b <- (df$b - min(df$b, na.rm = TRUE)) / \n  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))\n## Error in df$b: object of type 'closure' is not subsettable\ndf$c <- (df$c - min(df$c, na.rm = TRUE)) / \n  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))\n## Error in df$c: object of type 'closure' is not subsettable\ndf$d <- (df$d - min(df$d, na.rm = TRUE)) / \n  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))\n## Error in df$d: object of type 'closure' is not subsettable\n\n\n\n\nimport pandas as pd\n## Error in py_call_impl(callable, dots$args, dots$keywords): ModuleNotFoundError: No module named 'pandas'\nimport numpy as np\n\ndf = pd.DataFrame({\n  'a': np.random.randn(10), \n  'b': np.random.randn(10), \n  'c': np.random.randn(10), \n  'd': np.random.randn(10)})\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'pd' is not defined\ndf.a = (df.a - min(df.a))/(max(df.a) - min(df.a))\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'df' is not defined\ndf.b = (df.b - min(df.b))/(max(df.b) - min(df.a))\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'df' is not defined\ndf.c = (df.c - min(df.c))/(max(df.c) - min(df.c))\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'df' is not defined\ndf.d = (df.d - min(df.d))/(max(df.d) - min(df.d))\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'df' is not defined\n\n\n\n\nThe code rescales a set of variables to have a range from 0 to 1. But, because of the copy-pasting, the code’s author made a mistake and forgot to change an a to b.\nWriting a function to rescale a variable would prevent this type of copy-paste error.\nTo write a function, we first analyze the code to determine how many inputs it has:\n\n\nR\nPython\n\n\n\n\ndf$a <- (df$a - min(df$a, na.rm = TRUE)) / \n  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))\n## Error in df$a: object of type 'closure' is not subsettable\n\nThis code has only one input: df$a.\n\n\n\n\ndf.a = (df.a - min(df.a))/(max(df.a) - min(df.a))\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'df' is not defined\n\nThis code has only one input: df.a\n\n\n\nTo convert the code into a function, we start by rewriting it using general names:\n\n\nR\nPython\n\n\n\nIn this case, it might help to replace df$a with x.\n\nx <- df$a \n## Error in df$a: object of type 'closure' is not subsettable\n\n(x - min(x, na.rm = TRUE)) / \n  (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n## Error in eval(expr, envir, enclos): object 'x' not found\n\n\n\nIn this case, it might help to replace df.a with x.\n\nx = df.a\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'df' is not defined\n(x - min(x))/(max(x) - min(x))\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'x' is not defined\n\n\n\n\nThen, we make it a bit easier to read, removing duplicate computations if possible (for instance, computing min two times).\n\n\nR\nPython\n\n\n\nIn R, we can use the range function, which computes the maximum and minimum at the same time and returns the result as c(min, max)\n\nrng <- range(x, na.rm = T)\n## Error in eval(expr, envir, enclos): object 'x' not found\n\n(x - rng[1])/(rng[2] - rng[1])\n## Error in eval(expr, envir, enclos): object 'x' not found\n\n\n\nIn python, range is the equivalent of seq() in R, so we are better off just using min and max.\n\nx = df.a\n\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'df' is not defined\nxmin, xmax = [x.min(), x.max()]\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'x' is not defined\n(x - xmin)/(xmax - xmin)\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'x' is not defined\n\n\n\n\nFinally, we turn this code into a function:\n\n\nR\nPython\n\n\n\n\nrescale01 <- function(x) {\n  rng <- range(x, na.rm = T)\n  (x - rng[1])/(rng[2] - rng[1])\n}\n\nrescale01(df$a)\n## Error in df$a: object of type 'closure' is not subsettable\n\n\nThe name of the function, rescale01, describes what the function does - it rescales the data to between 0 and 1.\nThe function takes one argument, named x; any references to this value within the function will use x as the name. This allows us to use the function on df$a, df$b, df$c, and so on, with x as a placeholder name for the data we’re working on at the moment.\nThe code that actually does what your function is supposed to do goes in the body of the function, between { and } (this is true in R, in python, there are different conventions, but the same principle applies)\nThe function returns the last value computed: in this case, (x - rng[1])/(rng[2]-rng[1]). You can make this explicit by adding a return() statement around that calculation.\n\n\n\n\ndef rescale01(x):\n  xmin, xmax = [x.min(), x.max()]\n  return (x - xmin)/(xmax - xmin)\n\nrescale01(df.a)\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'df' is not defined\n\n\nThe name of the function, rescale01, describes what the function does - it rescales the data to between 0 and 1.\nThe function takes one argument, named x; any references to this value within the function will use x as the name. This allows us to use the function on df.a, df.b, df.c, and so on, with x as a placeholder name for the data we’re working on at the moment.\nThe code that actually does what your function is supposed to do goes in the body of the function, indented relative to the line with def: function_name():. At the end of the function, you should have a blank line with no spaces or tabs.\nThe function returns the value it is told to return: in this case, (x - xmin)/(xmax - xmin). In Python, you must return a value if you want the function to perform a computation. 1\n\n\n\n\nThe process for creating a function is important: first, you figure out how to do the thing you want to do. Then, you simplify the code as much as possible. Only at the end of that process do you create an actual function."
  },
  {
    "objectID": "part-gen-prog/05-functions.html#syntax",
    "href": "part-gen-prog/05-functions.html#syntax",
    "title": "10  Writing Functions",
    "section": "\n10.3 Syntax",
    "text": "10.3 Syntax\n\n\nR and python syntax for defining functions. Portions of the command that indicate the function name, function scope, and return statement are highlighted in each block.\n\n\nIn R, functions are defined as other variables, using <-, but we specify the arguments a function takes by using the function() statement. The contents of the function are contained within { and }. If the function returns a value, a return() statement can be used; alternately, if there is no return statement, the last computation in the function will be returned.\nIn python, functions are defined using the def command, with the function name, parentheses, and the function arguments to follow. The first line of the function definition ends with a :, and all subsequent lines of the function are indented (this is how python knows where the end of the function is). A python function return statement is return <value>, with no parentheses needed.\nNote that in python, the return statement is not optional. It is not uncommon to have python functions that don’t return anything; in R, this is a bit less common, for reasons we won’t get into here."
  },
  {
    "objectID": "part-gen-prog/05-functions.html#arguments-and-parameters",
    "href": "part-gen-prog/05-functions.html#arguments-and-parameters",
    "title": "10  Writing Functions",
    "section": "\n10.4 Arguments and Parameters",
    "text": "10.4 Arguments and Parameters\nAn argument is the name for the object you pass into a function.\nA parameter is the name for the object once it is inside the function (or the name of the thing as defined in the function).\n\n\n\n\n\n\nExample: Parts of a Function\n\n\n\nLet’s examine the difference between arguments and parameters by writing a function that takes a dog’s name and returns “ is a good pup!”.\n\n\nR\nPython\n\n\n\n\ndog <- \"Eddie\"\n\ngoodpup <- function(name) {\n  paste(name, \"is a good pup!\")\n}\n\ngoodpup(dog)\n## [1] \"Eddie is a good pup!\"\n\n\n\n\ndog = \"Eddie\"\n\ndef goodpup(name):\n  return name + \" is a good pup!\"\n\ngoodpup(dog)\n## 'Eddie is a good pup!'\n\n\n\n\nIn this example function, when we call goodpup(dog), dog is the argument. name is the parameter.\nWhat is happening inside the computer’s memory as goodpup runs?\n\n\nA sketch of the execution of the program goodpup, showing that name is only defined within the local environment that is created while goodpup is running. We can never access name in our global environment.\n\n\n\n\nThis is why the distinction between arguments and parameters matters. Parameters are only accessible while inside of the function - and in that local environment, we need to call the object by the parameter name, not the name we use outside the function (the argument name).\nWe can even call a function with an argument that isn’t defined outside of the function call: goodpup(\"Tesla\") produces “Tesla is a good pup!”. Here, I do not have a variable storing the string “Tesla”, but I can make the function run anyways. So “Tesla” here is an argument to goodpup but it is not a variable in my environment.\nThis is a confusing set of concepts and it’s ok if you only just sort of get what I’m trying to explain here. Hopefully it will become more clear as you write more code.\n\n\n\n\n\n\nTry it out: Function Parts\n\n\n\nFor each of the following blocks of code, identify the function name, function arguments, parameter names, and return statements. When the function is called, see if you can predict what the output will be. Also determine whether the function output is stored in memory or just printed to the command line.\n\n\nFunction 1\nAnswer\n\n\n\n\n\ndef hello_world():\n  print(\"Hello World\")\n\n\nhello_world()\n\n\n\n\nFunction name: hello_world\n\nFunction parameters: none\nFunction arguments: none\nFunction output:\n\n\nhello_world()\n## Hello World\n\n\nFunction output is not stored in memory and is printed to the command line.\n\n\n\n\n\n\nFunction 2\nAnswer\n\n\n\n\n\nmy_mean <- function(x) {\n  censor_x <- sample(x, size = length(x) - 2, replace = F)\n  mean(censor_x)\n}\n\n\nset.seed(3420523)\nx = my_mean(1:10)\nx\n\n\n\n\nFunction name: my_mean\n\nFunction parameters: x\nFunction arguments: 1:10\nFunction output: (varies each time the function is run unless you set the seed)\n\n\nset.seed(3420523)\nx = my_mean(1:10)\nx\n## [1] 6\n\n\nFunction output is saved to memory (x) and printed to the command line\n\n\n\n\n\n\n\n10.4.1 Named Arguments and Parameter Order\nIn the examples above, you didn’t have to worry about what order parameters were passed into the function, because there were 0 and 1 parameters, respectively. But what happens when we have a function with multiple parameters?\n\n\nR\nPython\n\n\n\n\n\ndivide <- function(x, y) {\n  x / y\n}\n\n\n\n\n\ndef divide(x, y):\n  return x / y\n\n\n\n\nIn this function, the order of the parameters matters! divide(3, 6) does not produce the same result as divide(6, 3). As you might imagine, this can quickly get confusing as the number of parameters in the function increases.\nIn this case, it can be simpler to use the parameter names when you pass in arguments.\n\n\nR\nPython\n\n\n\n\ndivide(3, 6)\n## [1] 0.5\n\ndivide(x = 3, y = 6)\n## [1] 0.5\n\ndivide(y = 6, x = 3)\n## [1] 0.5\n\ndivide(6, 3)\n## [1] 2\n\ndivide(x = 6, y = 3)\n## [1] 2\n\ndivide(y = 3, x = 6)\n## [1] 2\n\n\n\n\ndivide(3, 6)\n## 0.5\ndivide(x = 3, y = 6)\n## 0.5\ndivide(y = 6, x = 3)\n## 0.5\ndivide(6, 3)\n## 2.0\ndivide(x = 6, y = 3)\n## 2.0\ndivide(y = 3, x = 6)\n## 2.0\n\n\n\n\nAs you can see, the order of the arguments doesn’t much matter, as long as you use named arguments, but if you don’t name your arguments, the order very much matters.\n\n10.4.2 Input Validation\nWhen you write a function, you often assume that your parameters will be of a certain type. But you can’t guarantee that the person using your function knows that they need a certain type of input. In these cases, it’s best to validate your function input.\n\n\n\n\n\n\nInput Validation Example\n\n\n\n\n\nR\nPython\n\n\n\nIn R, you can use stopifnot() to check for certain essential conditions. If you want to provide a more illuminating error message, you can check your conditions using if() and then use stop(\"better error message\") in the body of the if statement.\n\nadd <- function(x, y) {\n  x + y\n}\n\nadd(\"tmp\", 3)\n## Error in x + y: non-numeric argument to binary operator\n\nadd <- function(x, y) {\n  stopifnot(is.numeric(x))\n  stopifnot(is.numeric(y))\n  x + y\n}\n\nadd(\"tmp\", 3)\n## Error in add(\"tmp\", 3): is.numeric(x) is not TRUE\nadd(3, 4)\n## [1] 7\n\n\n\nIn Python, the easiest way to handle errors is to use a try statement, which operates rather like an if statement: if the statement executes, then we’re good to go; if not, we can use except to handle different types of errors. The else clause is there to handle anything that needs to happen if the statement in the try clause executes without any errors.\n\n\ndef add(x, y):\n  x + y\n\nadd(\"tmp\", 3)\n## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: can only concatenate str (not \"int\") to str\ndef add(x, y):\n  try:\n    return x + y\n  except TypeError:\n    print(\"x and y must be add-able\")\n  else:\n    # We should never get here, because the try clause has a return statement\n    print(\"Else clause?\")\n  return\n\nadd(\"tmp\", 3)\n## x and y must be add-able\nadd(3, 4)\n## 7\n\nYou can read more about error handling in Python here\n\n\n\n\n\nInput validation is one aspect of defensive programming - programming in such a way that you try to ensure that your programs don’t error out due to unexpected bugs by anticipating ways your programs might be misunderstood or misused [3]."
  },
  {
    "objectID": "part-gen-prog/05-functions.html#scope",
    "href": "part-gen-prog/05-functions.html#scope",
    "title": "10  Writing Functions",
    "section": "\n10.5 Scope",
    "text": "10.5 Scope\nWhen talking about functions, for the first time we start to confront a critical concept in programming, which is scope. Scope is the part of the program where the name you’ve given a variable is valid - that is, where you can use a variable.\n\nA variable is only available from inside the region it is created.\n\nWhat do I mean by the part of a program? The lexical scope is the portion of the code (the set of lines of code) where the name is valid.\nThe concept of scope is best demonstrated through a series of examples, so in the rest of this section, I’ll show you some examples of how scope works and the concepts that help you figure out what “scope” actually means in practice.\n\n10.5.1 Name Masking\nScope is most clearly demonstrated when we use the same variable name inside and outside a function. Note that this is 1) bad programming practice, and 2) fairly easily avoided if you can make your names even slightly more creative than a, b, and so on. But, for the purposes of demonstration, I hope you’ll forgive my lack of creativity in this area so that you can see how name masking works.\n\n\n\n\n\n\nDanger\n\n\n\nWhat does this function return, 10 or 20?\n\n\nPseudocode\nSketch\nR\nPython\n\n\n\na = 10\n\nmyfun = function() {\n  a = 20\n  return a\n}\n\nmyfun()\n\n\n\n\nA sketch of the global environment as well as the environment within myfun(). Because a=20 inside myfun(), when we call myfun(), we get the value of a within that environment, instead of within the global environment.\n\n\n\n\n\na <- 10\n\nmyfun <- function() {\n  a <- 20\n  a\n}\n\nmyfun()\n## [1] 20\n\n\n\n\n\na = 10\n\ndef myfun():\n  a = 20\n  return a\n\nmyfun()\n## 20\n\n\n\n\n\n\nThe lexical scope of the function is the area that is between the braces (in R) or the indented region (in python). Outside the function, a has the value of 10, but inside the function, a has the value of 20. So when we call myfun(), we get 20, because the scope of myfun is the local context where a is evaluated, and the value of a in that environment dominates.\nThis is an example of name masking, where names defined inside of a function mask names defined outside of a function.\n\n10.5.2 Environments and Scope\nAnother principle of scoping is that if you call a function and then call the same function again, the function’s environment is re-created each time. Each function call is unrelated to the next function call when the function is defined using local variables.\n\n\n\n\n\n\nDanger\n\n\n\n\n\nPseudocode\nSketch\nR\nPython\n\n\n\nmyfun = function() {\n  if a is not defined\n    a = 1\n  else\n    a = a + 1\n}\n\nmyfun()\nmyfun()\n\nWhat does this output?\n\n\n\n\nWhen we define myfun, we create a template for an environment with variables and code to excecute. Each time myfun() is called, that template is used to create a new environment. This prevents successive calls to myfun() from affecting each other – which means a = 1 every time.\n\n\n\n\n\nmyfun <- function() {\n  if (!exists(\"aa\")) {\n    aa <- 1\n  } else {\n    aa <- aa + 1\n  }\n  return(aa)\n}\n\nmyfun()\n## [1] 1\nmyfun()\n## [1] 1\n\n\n\n\ndef myfun():\n  try: aa\n  except NameError: aa = 1\n  else: aa = aa + 1\n  return aa\n\nmyfun()\n## 1\nmyfun()\n## 1\n\nNote that the try command here is used to handle the case where a doesn’t exist. If there is a NameError (which will happen if aa is not defined) then we define aa = 1, if there is not a NameError, then aa = aa + 1.\nThis is necessary because Python does not have a built-in way to test if a variable exists before it is used [4], Ch 17.\n\n\n\n\n\n\n10.5.3 Dynamic Lookup\nScoping determines where to look for values – when, however, is determined by the sequence of steps in the code. When a function is called, the calling environment (the global environment or set of environments at the time the function is called) determines what values are used.\nIf an object doesn’t exist in the function’s environment, the global environment will be searched next; if there is no object in the global environment, the program will error out. This behavior, combined with changes in the calling environment over time, can mean that the output of a function can change based on objects outside of the function.\n\n\n\n\n\n\nDanger\n\n\n\n\n\nPseudocode\nSketch\nR\nPython\n\n\n\nmyfun = function() x + 1\n\nx = 14\n\nmyfun()\n\nx = 20\n\nmyfun()\n\nWhat will the output be of this code?\n\n\n\n\nThe state of the global environment at the time the function is called (that is, the state of the calling environment) can change the results of the function\n\n\n\n\n\nmyfun <- function() {\n  x + 1\n}\n\nx <- 14\n\nmyfun()\n## [1] 15\n\nx <- 20\n\nmyfun()\n## [1] 21\n\n\n\n\n\ndef myfun():\n  return x + 1\n\n\nx = 14\n\nmyfun()\n## 15\nx = 20\n\nmyfun()\n## 21\n\n\n\n\n\n\n\n\n\n\n\n\nTry It Out: Function Scope\n\n\n\nWhat does the following function return? Make a prediction, then run the code yourself. From [2, Ch. 6]\n\n\nR code\nR solution\nPython code\nPython solution\n\n\n\n\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x ^ 2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)\n\n\n\n\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x ^ 2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)\n## [1] 202\n\n\n\n\ndef f(x):\n  def f(x):\n    def f():\n      return x ^ 2\n    return f() + 1\n  return f(x) * 2\n\nf(10)\n\n\n\n\ndef f(x):\n  def f(x):\n    def f():\n      return x ** 2\n    return f() + 1\n  return f(x) * 2\n\nf(10)\n## 202"
  },
  {
    "objectID": "part-gen-prog/05-functions.html#sec-functions-refs",
    "href": "part-gen-prog/05-functions.html#sec-functions-refs",
    "title": "10  Writing Functions",
    "section": "\n10.6 References",
    "text": "10.6 References\n\n\n\n\n[1] \nG. Grolemund and H. Wickham, R for Data Science, 1st ed. O’Reilly Media, 2017 [Online]. Available: https://r4ds.had.co.nz/. [Accessed: May 09, 2022]\n\n\n[2] \nH. Wickham, Advanced R, 2nd ed. CRC Press, 2019 [Online]. Available: http://adv-r.had.co.nz/. [Accessed: May 09, 2022]\n\n\n[3] \nWikipedia Contributors, “Defensive programming,” Wikipedia. Wikimedia Foundation, Apr. 2022 [Online]. Available: https://en.wikipedia.org/w/index.php?title=Defensive_programming&oldid=1084121123. [Accessed: May 31, 2022]\n\n\n[4] \nA. Martelli and D. Ascher, Python Cookbook. O’Reilly Media, 2002 [Online]. Available: https://learning.oreilly.com/library/view/python-cookbook/0596001673/ch05s24.html. [Accessed: May 31, 2022]"
  },
  {
    "objectID": "part-gen-prog/06-debugging.html",
    "href": "part-gen-prog/06-debugging.html",
    "title": "11  Debugging",
    "section": "",
    "text": "12 I’ve deleted the intermediate chunks because they screw\n’ knitr::knit(text=indoc, output=“test.md”) rmarkdown::render(“test.md”)"
  },
  {
    "objectID": "part-gen-prog/06-debugging.html#objectives",
    "href": "part-gen-prog/06-debugging.html#objectives",
    "title": "11  Debugging",
    "section": "\n11.1 Objectives",
    "text": "11.1 Objectives\n\nCreate reproducible examples of problems\nUse built in debugging tools to trace errors\nUse online resources to research errors\n\n\n\nThe faces of debugging (by Allison Horst)"
  },
  {
    "objectID": "part-gen-prog/06-debugging.html#avoiding-errors-defensive-programming",
    "href": "part-gen-prog/06-debugging.html#avoiding-errors-defensive-programming",
    "title": "11  Debugging",
    "section": "\n11.2 Avoiding Errors: Defensive Programming",
    "text": "11.2 Avoiding Errors: Defensive Programming\nOne of the best debugging strategies (that isn’t a debugging strategy at all, really) is to code defensively [1]. By that, I mean, code in a way that you will make debugging things easier later.\n\nModularize your code. Each function should do only one task, ideally in the least-complex way possible.\nMake your code readable. If you can read the code easily, you’ll be able to narrow down the location of the bug more quickly.\nComment your code. This makes it more likely that you will be able to locate the spot where the bug is likely to have occurred, and will remind you how things are calculated. Remember, comments aren’t just for your collaborators or others who see the code. They’re for future you.\nDon’t duplicate code. If you have the same code (or essentially the same code) in two or three different places, put that code in a function and call the function instead. This will save you trouble when updating the code in the future, but also makes narrowing down the source of the bug less complex.\nReduce the number of dependencies you have on outside software packages. Often bugs are introduced when a dependency is updated and the functionality changes slightly. The tidyverse [2] is notorious for this.\n\n\n\n\n\n\n\nNote\n\n\n\nIt’s ok to write code using lots of dependencies, but as you transition from “experimental” code to “production” code (you’re using the code without tinkering with it) you should work to reduce the dependencies, where possible. In addition, if you do need packages with lots of dependencies, try to make sure those packages are relatively popular, used by a lot of people, and currently maintained. (The tidyverse is a bit better from this perspective, because the constituent packages are some of the most installed R packages on CRAN.)\n\n\nAnother way to handle dependency management is to use the renv package [3], which creates a local package library with the appropriate versions of your packages stored in the same directory as your project. renv was inspired by the python concept of virtual environments, and it does also work with python if you’re using both R and python inside a project (e.g. this book uses renv). renv will at the very least help you minimize issues with code not working after unintentional package updates.\n\nAdd safeguards against unexpected inputs. Check to make sure inputs to the function are valid. Check to make sure intermediate results are reasonable (e.g. you don’t compute the derivative of a function and come up with “a”.)\nDon’t reinvent the wheel. If you have working, tested code for a task, use that! If someone else has working code that’s used by the community, don’t write your own unless you have a very good reason. The implementation of lm has been better tested than your homegrown linear regression.\nCollect your often-reused code in packages that you can easily load and make available to “future you”. The process of making a package often encourages you to document your code better than you would a script. A good resource for getting started making R packages is [4], and a similar python book is [5]."
  },
  {
    "objectID": "part-gen-prog/06-debugging.html#working-through-errors",
    "href": "part-gen-prog/06-debugging.html#working-through-errors",
    "title": "11  Debugging",
    "section": "\n11.3 Working through Errors",
    "text": "11.3 Working through Errors\n\n11.3.1 First steps\n\n11.3.1.1 Get into the right mindset\nYou can’t debug something effectively if you’re upset. You have to be in a puzzle-solving, detective mindset to actually solve a problem. If you’re already stressed out, try to relieve that stress before you tackle the problem: take a shower, go for a walk, pet a puppy.\n\n\nA debugging manifesto [6]\n\n\n\n11.3.1.2 Check your spelling\nI’ll guess that 80% of my personal debugging comes down to spelling errors and misplaced punctuation.\n\n\nTitle: user.fist_name [7]\n\n\n\n11.3.2 General Debugging Strategies\n\n\n\nDebugging: Being the detective in a crime movie where you are also the murderer. - some t-shirt I saw once\n\nWhile defensive programming is a nice idea, if you’re already at the point where you have an error you can’t diagnose, then… it doesn’t help that much. At that point, you’ll need some general debugging strategies to work with. The overall process is well described in [8]; I’ve added some steps that are commonly overlooked and modified the context from the original package development to introductory programming. I’ve also integrated some lovely illustrations from Julia Evans (@b0rk) to lighten the mood.\n\nRealize that you have a bug\nRead the error message\n\n\n\nDebugging strategy: Reread the error message[9]\n\n\n\n\nGoogle! Seriously, just google the whole error message.\nIn R you can automate this with the errorist and searcher packages. Python is so commonly used that you’ll likely be able to find help for your issue if you are specific enough.\n\n\n\n\n\nDebugging strategy: Shorten your feedback loop [10]\n\n\n\n\nMake the error repeatable: This makes it easier to figure out what the error is, faster to iterate, and easier to ask for help.\n\nUse binary search (remove 1/2 of the code, see if the error occurs, if not go to the other 1/2 of the code. Repeat until you’ve isolated the error.)\nGenerate the error faster - use a minimal test dataset, if possible, so that you can ask for help easily and run code faster. This is worth the investment if you’ve been debugging the same error for a while. \nNote which inputs don’t generate the bug – this negative “data” is helpful when asking for help.\n\n\n\nDebugging strategy: Change working code into broken code [12]\n\n\n\nFigure out where it is. Debuggers may help with this, but you can also use the scientific method to explore the code, or the tried-and-true method of using lots of print() statements.\nCome up with one question. If you’re stuck, it can be helpful to break it down a bit and ask one tiny question about the bug.\n\n\n\nDebugging strategy: Come up with one question [13]\n\n\n\n\nFix it and test it. The goal with tests is to ensure that the same error doesn’t pop back up in a future version of your code. Generate an example that will test for the error, and add it to your documentation. If you’re developing a package, unit test suites offer a more formalized way to test errors and you can automate your testing so that every time your code is changed, tests are run and checked.\n\n\n\n\n\nDebugging strategy: Write a unit test [14]\n\n\nThere are several other general strategies for debugging:\n\nRetype (from scratch) your code\nThis works well if it’s a short function or a couple of lines of code, but it’s less useful if you have a big script full of code to debug. However, it does sometimes fix really silly typos that are hard to spot, like having typed <-- instead of <- in R and then wondering why your answers are negative.\nVisualize your data as it moves through the program. This may be done using print() statements, or the debugger, or some other strategy depending on your application.\nTracing statements. Again, this is part of print() debugging, but these messages indicate progress - “got into function x”, “returning from function y”, and so on.\nRubber ducking. Have you ever tried to explain a problem you’re having to someone else, only to have a moment of insight and “oh, never mind”? Rubber ducking outsources the problem to a nonjudgmental entity, such as a rubber duck1. You simply explain, in terms simple enough for your rubber duck to understand, exactly what your code does, line by line, until you’ve found the problem. See [15] for a more thorough explanation.\n\nDo not be surprised if, in the process of debugging, you encounter new bugs. This is a problem that’s well-known enough that it has its own xkcd comic. At some point, getting up and going for a walk may help. Redesigning your code to be more modular and more organized is also a good idea."
  },
  {
    "objectID": "part-gen-prog/06-debugging.html#dividing-problems-into-smaller-parts",
    "href": "part-gen-prog/06-debugging.html#dividing-problems-into-smaller-parts",
    "title": "11  Debugging",
    "section": "\n11.4 Dividing Problems into Smaller Parts",
    "text": "11.4 Dividing Problems into Smaller Parts\n\n“Divide each difficulty into as many parts as is feasible and necessary to resolve it.” -René Descartes, Discourse on Method\n\nIn programming, as in life, big, general problems are very hard to solve effectively. Instead, the goal is to break a problem down into smaller pieces that may actually be solvable.\n\n\n\n\n\n\nExample: Exhaustion\n\n\n\nThis example inspired by [16].\n\n\nGeneral problem\nSpecific problem\nSubproblems\nBrainstorm\nSubproblem solutions\n\n\n\n“I’m exhausted all the time”\nOk, so this is a problem that many of us have from time to time (or all the time). If we get a little bit more specific at outlining the problem, though, we can sometimes get a bit more insight into how to solve it.\n\n\n“I wake up in the morning and I don’t have any energy to do anything. I want to go back to sleep, but I have too much to do to actually give in and sleep. I spend my days worrying about how I’m going to get all of the things on my to-do list done, and then I lie awake at night thinking about how many things there are to do tomorrow. I don’t have time for hobbies or exercise, so I drink a lot of coffee instead to make it through the day.”\nThis is a much more specific list of issues, and some of these issues are actually things we can approach separately.\n\n\nMoving through the list in the previous tab, we can isolate a few issues. Some of these issues are undoubtedly related to each other, but we can approach them separately (for the most part).\n\nPoor quality sleep (tired in the morning, lying awake at night)\nToo many things to do (to-do list)\nChemical solutions to low energy (coffee during the day)\nAnxiety about completing tasks (worrying, insomnia)\nLack of personal time for hobbies or exercise\n\n\n\n\nGet a check-up to rule out any other issues that could cause sleep quality degradation - depression, anxiety, sleep apnea, thyroid conditions, etc.\n\nAsk the doctor about taking melatonin supplements for a short time to ensure that sleep starts off well (note, don’t take medical advice from a stats textbook!)\n\n\nReformat your to-do list:\n\nSet time limits for things on the to-do list\nBreak the to-do list into smaller, manageable tasks that can be accomplished within a relatively short interval - such as an hour\nSort the to-do list by priority and level of “fun” so that each day has a few hard tasks and a couple of easy/fun tasks. Do the hard tasks first, and use the easy/fun tasks as a reward.\n\n\nSet a time limit for caffeine (e.g. no coffee after noon) so that caffeine doesn’t contribute to poor quality sleep\nAddress anxiety with medication (from 1), scheduled time for mindfulness meditation, and/or self-care activities\nScheduling time for exercise/hobbies\n\nscheduling exercise in the morning to take advantage of the endorphins generated by working out\nscheduling hobbies in the evening to reward yourself for a day’s work and wind down work well before bedtime\n\n\n\n\n\nWhen the sub-problem has a viable solution, move on to the next sub-problem. Don’t try to tackle everything at once. Here, that might look like this list, where each step is taken separately and you give each thing a few days to see how it affects your sleep quality. In programming, of course, this list would perhaps be a bit more sequential, but real life is messy and the results take a while to populate.\n\n[1] Make the doctor’s appointment.\n[5] While waiting for the appointment, schedule exercise early in the day and hobbies later in the day to create a “no-work” period before bedtime.\n[1] Go to the doctor’s appointment, follow up with any concerns.\n\n[1] If doctor approves, start taking melatonin according to directions\n\n\n[2] Work on reformatting the to-do list into manageable chunks. Schedule time to complete chunks using your favorite planning method.\n[4] If anxiety is still an issue after following up with the doctor, add some mindfullness meditation or self-care to the schedule in the mornings or evenings.\n[3] If sleep quality is still an issue, set a time limit for caffeine\n[2] Revise your to-do list and try a different tactic if what you were trying didn’t work."
  },
  {
    "objectID": "part-gen-prog/06-debugging.html#minimal-working-or-reproducible-examples",
    "href": "part-gen-prog/06-debugging.html#minimal-working-or-reproducible-examples",
    "title": "11  Debugging",
    "section": "\n11.5 Minimal Working (or Reproducible) Examples",
    "text": "11.5 Minimal Working (or Reproducible) Examples\n\n\n\n\nThe reprex R package will help you make a reproducible example (drawing by Allison Horst)\n\n\nIf all else has failed, and you can’t figure out what is causing your error, it’s probably time to ask for help. If you have a friend or buddy that knows the language you’re working in, by all means ask for help sooner - use them as a rubber duck if you have to. But when you ask for help online, often you’re asking people who are much more knowledgeable about the topic - members of R core and really famous python developers browse stackoverflow and may drop in and help you out. Under those circumstances, it’s better to make the task of helping you as easy as possible because it shows respect for their time. The same thing goes for your supervisors and professors.\nThere are numerous resources for writing what’s called a “minimal working example”, “reproducible example” (commonly abbreviated reprex), or MCVE (minimal complete verifiable example). Much of this is lifted directly from the StackOverflow post describing a minimal reproducible example.\nThe goal is to reproduce the error message with information that is\n\n\nminimal - as little code as possible to still reproduce the problem\n\ncomplete - everything necessary to reproduce the issue is contained in the description/question\n\nreproducible - test the code you provide to reproduce the problem.\n\nYou should format your question to make it as easy as possible to help you. Make it so that code can be copied from your post directly and pasted into a terminal. Describe what you see and what you’d hope to see if the code were working.\n\n\n\n\n\n\nOther Minimum Working Example/Reprex resources\n\n\n\n\nreprex package: Do’s and Don’ts\n\nHow to use the reprex package - vignette with videos from Jenny Bryan\nreprex magic - Vignette adapted from a blog post by Nick Tierney\n\n\n\n\n\n\n\n\n\nExample: MWEs\n\n\n\nNote: You don’t need to know anything about SAS to understand this example.\n\nSAS markdown\n\n\nA long time ago, when this book covered R and SAS, I had issues with SAS graphs rendering in black and white most of the time.\nI started debugging the issue with the following code chunk:\n```{{r sas-cat-aes-map-07, engine=“sashtml”, engine.path=“sas”, fig.path = “image/”}} libname classdat “sas/”;\nPROC SGPLOT data=classdat.fbiwide; SCATTER x = Population y = Assault / markerattrs=(size=8pt symbol=circlefilled) group = Abb; /* maps to point color by default */ RUN; QUIT;\nPROC SGPLOT data=classdat.fbiwide NOAUTOLEGEND; /* dont generate a legend / SCATTER x = Population y = Assault / markercharattrs=(size=8) markerchar = Abb / specify marker character variable */ group = Abb ; RUN; QUIT;\n\n\nAfter running the code separately in SAS and getting a figure that looked like what I'd expected, I set out to construct a reproducible example so that I could post to the [SASmarkdown github issues page](https://github.com/Hemken/SASmarkdown/issues/14) and ask for help.\n\nThe first thing I did was strip out all of the extra stuff that didn't need to be in the chunk - this chunk generates 2 pictures; I only need one. \nThis chunk requires the fbiwide data from the `classdata` R package (that I exported to CSV); I replaced it with a dataset in the `sashelp` library.\n\nWhen I was done, the chunk looked like this:\n\nPROC SGPLOT data=sashelp.snacks; SCATTER x = date y = QtySold / markerattrs=(size=8pt symbol=circlefilled) group = product; /* maps to point color by default */ RUN; QUIT;\n\nThen, I started constructing my reproducible example. \nI ran `?sas_enginesetup` to get to a SASmarkdown help page, because I remembered it had a nice way to generate and run markdown files from R directly (without saving the Rmd file). \n\nI copied the example from that page:\n\n11.6 indoc <- ’\ntitle: “Basic SASmarkdown Doc” author: “Doug Hemken” output: html_document —\n\n\n13 everything up when I print this chunk out\n\n\nThen, I created several chunks which would do the following:\n1. Write the minimal example SAS code above to a [file](files/reprex.sas)\n2. Call that file in a SASmarkdown chunk using the `%include` macro, which dumps the listed file into the SAS program. This generates the [plot](files/SASmarkdown-reprex/unnamed-chunk-1.png) using SASmarkdown.\n3. Call the file using SAS batch mode    \n(this runs the code and produces a [plot](files/SASmarkdown-reprex/SGPlot.png) outside of SASmarkdown, to prove that the issue is SASmarkdown itself)\n\nFinally, I included the image generated from the batch mode call manually.\n\nYou can see the resulting code [here](https://github.com/Hemken/SASmarkdown/issues/14).\n\nI pasted my example into the issues page, and then included some additional information: \n\n1. A screenshot of the rendered page\n2. The image files themselves\n3. A description of what happened\n4. My suspicions (some obvious option I'm missing?)\n5. An additional line of R code that would delete any files created if someone ran my example. Because file clutter sucks.\n\nThis process took me about 45 minutes, but that was still much shorter than the time I'd spent rerunning code trying to get it to work with no success. \n\nIn less than 24 hours, the package maintainer responded with a (admittedly terse) explanation of what he thought caused the problem. \nI had to do some additional research to figure out what that meant, but once I had my reproducible example working in color, I posted that code (so that anyone else with the same problem would know what to do).\n\nThen, I had to tinker with the book a bit to figure out if there were easier ways to get the same result.\nThe end result, though, was that I got what I wanted - color figures throughout the book!\n\n#### Python/Quarto\n\nWhile converting the book from Rmarkdown to quarto, I ran into an issue setting up GitHub Actions (basically, when I push changes, GitHub rebuilds the book from scratch automatically). \n\n\nI found an issue describing the same segfault issue I had been getting, and so I made a [post there](https://github.com/rstudio/reticulate/issues/1133) with a new github repository containing a [minimal working example](https://github.com/srvanderplas/test-quarto) that I set up to test the problem. \n\nWithin 24h, I had gotten replies from people working at RStudio, and one of them had [diagnosed the problem](https://github.com/rstudio/reticulate/issues/1133#issuecomment-1021783041). \nAfter I asked a few more questions, one of them submitted a pull request to my repository with a solution.\n\nI didn't know enough python or enough about GitHub Actions to diagnose the problem myself, but because I managed to create a reproducible example, I got the answers I needed from people with more experience.\n\n:::\n\n:::\n\n::: callout-tip\n### Try It Out \n\nUse [this list of StackOverflow posts](files/Debugging_exercise.html) to try out your new debugging techniques. \nCan you figure out what's wrong? \nWhat information would you need from the poster in order to come up with a solution?\nHow much time did you spend trying to figure out what the poster was actually asking?\n:::\n\n\n\n## Debugging Tools\n\nNow that we've discussed general strategies for debugging that will work in any language, lets get down to the dirty details of debugging. \n\n### Low tech debugging with print() and other tools\nSometimes called \"tracing\" techniques, the most common, universal, and low tech strategy for debugging involves scattering messages throughout your code. \nWhen the code is executed, you get a window into what the variables look like during execution.\n\nThis is called **print debugging** and it is an incredibly useful tool.\n\n::: callout-caution\n#### Example: Nested Functions\n\n::: panel-tabset\n#### R\nImagine we start with this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 1\ny = 2\nz = 0\n\naa <- function(x) {\n  bb <- function(y) {\n    cc <- function(z) {\n      z + y\n    }\n    cc(3) + 2\n  }\n  x + bb(4)\n}\n\naa(5)\n## [1] 14\n\n\n\n\nand the goal is to understand what’s happening in the code. We might add some lines:\n\nx = 1\ny = 2\nz = 0\n\naa <- function(x) {\n  print(paste(\"Entering aa(). x = \", x))\n  bb <- function(y) {\n    print(paste(\"Entering bb(). x = \", x, \"y = \", y))\n    cc <- function(z) {\n      print(paste(\"Entering cc(). x = \", x, \"y = \", y, \"z = \", z))\n      cres <- z + y\n      print(paste(\"Returning\", cres, \"from cc()\"))\n      cres\n    }\n    bres <- cc(3) + 2\n    print(paste(\"Returning\", bres, \"from bb()\"))\n    bres\n  }\n  ares <- x + bb(4)\n  print(paste(\"Returning\",ares, \"from aa()\"))\n  ares\n}\n\naa(5)\n## [1] \"Entering aa(). x =  5\"\n## [1] \"Entering bb(). x =  5 y =  4\"\n## [1] \"Entering cc(). x =  5 y =  4 z =  3\"\n## [1] \"Returning 7 from cc()\"\n## [1] \"Returning 9 from bb()\"\n## [1] \"Returning 14 from aa()\"\n## [1] 14\n\n\n13.0.0.1 Python\nImagine we start with this:\n\nx = 1\ny = 2\nz = 0\n\ndef aa(x):\n  def bb(y):\n    def cc(z):\n      return z + y\n    return cc(3) + 2\n  return x + bb(4)\n\naa(5)\n## 14\n\nand the goal is to understand what’s happening in the code. We might add some lines:\n\nx = 1\ny = 2\nz = 0\n\ndef aa(x):\n  print(\"Entering aa(). x = \" + str(x))\n  def bb(y):\n    print(\"Entering bb(). x = \" + str(x) + \", y = \" + str(y))\n    def cc(z):\n      print(\"Entering cc(). x = \" + str(x) + \", y = \" + str(y) + \", z = \" + str(z))\n      cres = z + y\n      print(\"Returning \" + str(cres) + \" from cc()\")\n      return cres\n    bres = cc(3) + 2\n    print(\"Returning \" + str(bres) + \" from bb()\")\n    return bres\n  ares = x + bb(4)\n  print(\"Returning \" + str(ares) + \" from aa()\")\n  return ares\n\naa(5)\n## Entering aa(). x = 5\n## Entering bb(). x = 5, y = 4\n## Entering cc(). x = 5, y = 4, z = 3\n## Returning 7 from cc()\n## Returning 9 from bb()\n## Returning 14 from aa()\n## 14\n\n\n\n\n:::\nFor more complex data structures, it can be useful to add str(), head(), or summary() functions.\n\n\n\n\n\n\nReal world example: Web Scraping\n\n\n\nIn fall 2020, I wrote a webscraper to get election polling data from the RealClearPolitics site as part of the electionViz package. I wrote the function search_for_parent() to get the parent HTML tag which matched the “tag” argument, that had the “node” argument as a descendant. I used print debugging to show the sequence of tags on the page.\nI was assuming that the order of the parents would be “html”, “body”, “div”, “table”, “tbody”, “tr” - descending from outer to inner (if you know anything about HTML/XML structure).\nTo prevent the site from changing on me (as websites tend to do…), I’ve saved the HTML file here.\n\n\nR\nPython\n\n\n\n\nlibrary(xml2) # read html\n\nsearch_for_parent <- function(node, tag) {\n  # Get all of the parent nodes \n  parents <- xml2::xml_parents(node)\n  # Get the tags of every parent node\n  tags <- purrr::map_chr(parents, rvest::html_name)\n  print(tags)\n  \n  # Find matching tags\n  matches <- which(tags == tag)\n  print(matches)\n  \n  # Take the minimum matching tag\n  min_match <- min(matches)\n  if (length(matches) == 1) return(parents[min_match]) else return(NULL)\n}\n\npage <- read_html(\"shorturl.at/jkS59\")\n## Error: 'shorturl.at/jkS59' does not exist in current working directory ('/__w/stat-computing-r-python/stat-computing-r-python/part-gen-prog').\n# find all poll results in any table\npoll_results <- xml_find_all(page, \"//td[@class='lp-results']\") \n## Error in UseMethod(\"xml_find_all\"): no applicable method for 'xml_find_all' applied to an object of class \"function\"\n# find the table that contains it\nsearch_for_parent(poll_results[1], \"table\") \n## Error in nodeset_apply(x, function(x) .Call(node_parents, x)): object 'poll_results' not found\n\n\n\nYou may need to pip install lxml requests bs4 to run this code.\n\n# !pip install lxml requests bs4\nfrom bs4 import BeautifulSoup\n## Error in py_call_impl(callable, dots$args, dots$keywords): ModuleNotFoundError: No module named 'bs4'\nimport requests as req\n## Error in py_call_impl(callable, dots$args, dots$keywords): ModuleNotFoundError: No module named 'requests'\nimport numpy as np\n\n\ndef search_for_parent(node, tag):\n  # Get all of the parent nodes\n  parents = node.find_parents()\n  # get tag type for each parent node\n  tags = [x.name for x in parents]\n  print(tags)\n  \n  # Find matching tags\n  matches = np.array([i for i, val in enumerate(tags) if val == tag])\n  print(matches)\n  \n  # Take the minimum matching tag\n  min_match = np.min(matches)\n  if matches.size == 1:\n    ret = parents[min_match]\n  \n  return ret\n\n\nhtml_file = open('shorturl.at/jkS59', 'r')\n## Error in py_call_impl(callable, dots$args, dots$keywords): FileNotFoundError: [Errno 2] No such file or directory: 'shorturl.at/jkS59'\npage = html_file.read() \n# Read the page as HTML\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'html_file' is not defined\nsoup = BeautifulSoup(page, 'html')\n# Find all poll results in any table\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'BeautifulSoup' is not defined\npoll_results = soup.findAll('td', {'class': 'lp-results'})\n# Find the table that contains the first poll result\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'soup' is not defined\nsearch_for_parent(poll_results[0], 'table')\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'poll_results' is not defined\n\n\n\n\nBy printing out all of the tags that contain node, I could see the order – inner to outer. I asked the function to return the location of the first table node, so the index (2nd value printed out) should match table in the character vector that was printed out first. I could then see that the HTML node that is returned is in fact the table node.\n\n\n\n\n\n\n\n\nTry it out: Hurricanes in R\n\n\n\nNot all bugs result in error messages, unfortunately, which makes higher-level techniques like traceback() less useful. The low-tech debugging tools, however, still work wonderfully.\n\n\nSetup\nBuggy code\nSolution 1: Identification\nSolution 2: Fixing\nSolution 3: Verifying\n\n\n\n\nlibrary(ggplot2)\n## Error in library(ggplot2): there is no package called 'ggplot2'\nlibrary(dplyr)\n## Error in library(dplyr): there is no package called 'dplyr'\nlibrary(magrittr)\nlibrary(maps)\n## Error in library(maps): there is no package called 'maps'\nlibrary(ggthemes)\n## Error in library(ggthemes): there is no package called 'ggthemes'\nworldmap <- map_data(\"world\")\n## Error in map_data(\"world\"): could not find function \"map_data\"\n\n# Load the data\ndata(storms, package = \"dplyr\")\n## Error in find.package(package, lib.loc, verbose = verbose): there is no package called 'dplyr'\n\n\n\nThe code below is supposed to print out a map of the tracks of all hurricanes of a specific category, 1 to 5, in 2013. Use print statements to figure out what’s wrong with my code.\n\n# Make base map to be used for each iteration\nbasemap <-  ggplot() + \n  # Country shapes\n  geom_polygon(aes(x = long, y = lat, group = group), \n               data = worldmap, fill = \"white\", color = \"black\") + \n  # Zoom in \n  coord_quickmap(xlim = c(-100, -10), ylim = c(10, 50)) + \n  # Don't need scales b/c maps provide their own geographic context...\n  theme_map()\n## Error in ggplot(): could not find function \"ggplot\"\n\nfor (i in 1:5) {\n  # Subset the data\n  subdata <- storms %>%\n    filter(year == 2013) %>%\n    filter(status == i)\n  \n  # Plot the data - path + points to show the observations\n  plot <- basemap +\n    geom_path(aes(x = long, y = lat, color = name), data = subdata) + \n    geom_point(aes(x = long, y = lat, color = name), data = subdata) + \n    ggtitle(paste0(\"Category \", i, \" storms in 2013\"))\n  print(plot)\n}\n## Error in as.ts(x): object 'storms' not found\n\n\n\nFirst, lets split the setup from the loop.\n\n# Make base map to be used for each iteration\nbasemap <-  ggplot() + \n  # Country shapes\n  geom_polygon(aes(x = long, y = lat, group = group), \n               data = worldmap, fill = \"white\", color = \"black\") + \n  # Zoom in \n  coord_quickmap(xlim = c(-100, -10), ylim = c(10, 50)) + \n  # Don't need scales b/c maps provide their own geographic context...\n  theme_map()\n## Error in ggplot(): could not find function \"ggplot\"\n\nprint(basemap) # make sure the basemap is fine\n## Error in print(basemap): object 'basemap' not found\n\n# Load the data\ndata(storms, package = \"dplyr\")\n## Error in find.package(package, lib.loc, verbose = verbose): there is no package called 'dplyr'\n\nstr(storms) # make sure the data exists and is formatted as expected\n## Error in str(storms): object 'storms' not found\n\nEverything looks ok in the setup chunk…\n\nfor (i in 1:5) {\n  print(paste0(\"Category \", i, \" storms\"))\n  # Subset the data\n  subdata <- storms %>%\n    filter(year == 2013) %>%\n    filter(status == i)\n  \n  print(paste0(\"subdata dims: nrow \", nrow(subdata), \" ncol \", ncol(subdata)))\n        # str(subdata) works too, but produces more clutter. I started\n        # with str() and moved to dim() when I saw the problem\n  \n  # Plot the data - path + points to show the observations\n  plot <- basemap +\n    geom_path(aes(x = long, y = lat, color = name), data = subdata) + \n    geom_point(aes(x = long, y = lat, color = name), data = subdata) + \n    ggtitle(paste0(\"Category \", i, \" storms in 2013\"))\n  # print(plot) # Don't print plots - clutters up output at the moment\n}\n## [1] \"Category 1 storms\"\n## Error in as.ts(x): object 'storms' not found\n\nOk, so from this we can see that something is going wrong with our filter statement - we have no rows of data.\n\n\n\nhead(storms)\n## Error in head(storms): object 'storms' not found\n\nWhoops. I meant “category” when I typed “status”.\n\nfor (i in 1:5) {\n  print(paste0(\"Category \", i, \" storms\"))\n  # Subset the data\n  subdata <- storms %>%\n    filter(year == 2013) %>%\n    filter(category == i)\n  \n  print(paste0(\"subdata dims: nrow \", nrow(subdata), \" ncol \", ncol(subdata)))\n        # str(subdata) works too, but produces more clutter. I started\n        # with str() and moved to dim() when I saw the problem\n  \n  # Plot the data - path + points to show the observations\n  plot <- basemap +\n    geom_path(aes(x = long, y = lat, color = name), data = subdata) + \n    geom_point(aes(x = long, y = lat, color = name), data = subdata) + \n    ggtitle(paste0(\"Category \", i, \" storms in 2013\"))\n  # print(plot) # Don't print plots - clutters up output at the moment\n}\n## [1] \"Category 1 storms\"\n## Error in as.ts(x): object 'storms' not found\n\nOk, that’s something, at least. We now have some data for category 1 storms…\n\nfilter(storms, year == 2013) %>%\n  # Get max category for each named storm\n  group_by(name) %>%\n  filter(category == max(category)) %>%\n  ungroup() %>%\n  # See what categories exist\n  select(name, category) %>%\n  unique()\n## Error in select(., name, category): could not find function \"select\"\n\nIt looks like 2013 was just an incredibly quiet year for tropical activity.\n\n\n2013 may have been a quiet year for tropical activity in the Atlantic, but 2004 was not. So let’s just make sure our code works by checking out 2004.\n\nfor (i in 1:5) {\n  print(paste0(\"Category \", i, \" storms\"))\n  # Subset the data\n  subdata <- storms %>%\n    filter(year == 2004) %>%\n    filter(category == i)\n  \n  print(paste0(\"subdata dims: nrow \", nrow(subdata), \" ncol \", ncol(subdata)))\n        # str(subdata) works too, but produces more clutter. I started\n        # with str() and moved to dim() when I saw the problem\n  \n  # Plot the data - path + points to show the observations\n  plot <- basemap +\n    geom_path(aes(x = long, y = lat, color = name), data = subdata) + \n    geom_point(aes(x = long, y = lat, color = name), data = subdata) + \n    ggtitle(paste0(\"Category \", i, \" storms in 2013\"))\n  print(plot) # Don't print plots - clutters up output at the moment\n}\n## [1] \"Category 1 storms\"\n## Error in as.ts(x): object 'storms' not found\n\nIf we want to only print informative plots, we could add an if statement. Now that the code works, we can also comment out our print() statements (we could delete them, too, depending on whether we anticipate future problems with the code).\n\nfor (i in 1:5) {\n  # print(paste0(\"Category \", i, \" storms\"))\n  \n  # Subset the data\n  subdata <- storms %>%\n    filter(year == 2013) %>%\n    filter(category == i)\n  \n  # print(paste0(\"subdata dims: nrow \", nrow(subdata), \" ncol \", ncol(subdata)))\n  #       # str(subdata) works too, but produces more clutter. I started\n  #       # with str() and moved to dim() when I saw the problem\n  \n  # Plot the data - path + points to show the observations\n  plot <- basemap +\n    geom_path(aes(x = long, y = lat, color = name), data = subdata) + \n    geom_point(aes(x = long, y = lat, color = name), data = subdata) + \n    ggtitle(paste0(\"Category \", i, \" storms in 2013\"))\n  \n  if (nrow(subdata) > 0) print(plot) \n}\n## Error in as.ts(x): object 'storms' not found\n\n\n\n\n\n\nOnce you’ve found your problem, go back and delete or comment out your print statements, as they’re no longer necessary. If you think you may need them again, comment them out, otherwise, just delete them so that your code is neat, clean, and concise.\n\n13.0.1 After an error has occurred - traceback()\n\ntraceback() can help you narrow down where an error occurs by taking you through the series of function calls that led up to the error. This may help you identify which function is actually causing the problem, which is especially useful when you have nested functions or are using package functions that depend on other packages.\n\n\n\n\n\n\nDemo: Using traceback\n\n\n\n\n\nR\nPython\n\n\n\n\naa <- function(x) {\n  bb <- function(y) {\n    cc <- function(z) {\n     stop('there was a problem')  # This generates an error\n    }\n    cc()\n  }\n  bb()\n}\n\naa()\n## Error in cc(): there was a problem\n\nFor more information, you could run traceback\n\ntraceback()\n\nWhich will provide the following output:\n4: stop(\"there was a problem\") at #4\n3: c() at #6\n2: b() at #8\n1: a()\nReading through this, we see that a() was called, b() was called, c() was called, and then there was an error. It’s even kind enough to tell us that the error occurred at line 4 of the code.\nIf you are running this code interactively in RStudio, it’s even easier to run traceback() by clicking on the “Show Traceback” option that appears when there is an error.\n\n\nBoth Show Traceback and Rerun with Debug are useful tools\n\n\nIf you are using source() to run the code in Rstudio, it will even provide a link to the file and line location of the error. \n\n\n\nimport sys,traceback\n\ndef aa(x):\n  def bb(y):\n    def cc(z):\n      try: \n        return y + z + tuple()[0] # This generates an error\n      except IndexError:\n        exc_type, exc_value, exc_tb = sys.exc_info()\n        traceback.print_exception(exc_type, exc_value, exc_tb, file = sys.stdout)\n    return cc(3) + 2\n  return x + bb(4)\n\naa(5)\n## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'\n\nPython’s traceback information is a bit more low-level and requires a bit more from the programmer than R’s version.\n\n\n\n\n\n\n13.0.2 Interactive Debugging\n\n\n\n\n\n\nR browser()\nPython\n\n\n\nThe browser() function is useful for debugging your own code. If you’re writing a function and something isn’t working quite right, you can insert a call to browser() in that function, and examine what’s going on.\n\n\n\n\n\n\nExample of using browser()\n\n\n\nSuppose that I want to write a function that will plot an xkcd comic in R.\nI start with\n\nlibrary(png)\nlibrary(xml2)\nlibrary(dplyr)\n## Error in library(dplyr): there is no package called 'dplyr'\n\n# get the most current xkcd\nget_xkcd <- function() {\n  url <- \"http://xkcd.com\"\n  page <- read_html(url)\n  # Find the comic\n  image <- xml_find_first(page, \"//div[@id='comic']/img\") %>%\n    # pull the address out of the tag\n    xml_attr(\"src\")\n  \n  \n  readPNG(source = image)\n}\n\nget_xkcd() %>%\n  as.raster() %>%\n  plot()\n## Error in readPNG(source = image): unable to open //imgs.xkcd.com/comics/washing_machine_settings.png\n\nHere’s the final function\n\nlibrary(png)\nlibrary(xml2)\n\n# get the most current xkcd\nget_xkcd <- function() {\n  \n  url <- \"http://xkcd.com\"\n  page <- read_html(url)\n  # Find the comic\n  image <- xml_find_first(page, \"//div[@id='comic']/img\") %>%\n    # pull the address out of the tag\n    xml_attr(\"src\")\n  \n  # Fix image address so that we can access the image\n  image <- substr(image, 3, nchar(image))\n  \n  # Download the file to a temp file and read from there\n  file_location <- tempfile(fileext = \".png\")\n  download.file(image, destfile = file_location, quiet = T)\n  \n  readPNG(source = file_location)\n}\n\nget_xkcd() %>%\n  as.raster() %>%\n  plot()\n\n\n\n\n\n\n\n\nIn python, the equivalent interactive debugger is ipdb. You can install it with pip install ipdb.\nIf you want to run Python in the interactive ipython console, then you can invoke the ipdb debugging with %debug get_xkcd(). This is similar to browser() in R. If you’re working in Python in RStudio, though, you have to get into debug mode in a more involved way.\nTo run code using ipdb when your code hits an error, add from ipdb import launch_ipdb_on_exception to the top of your python code chunk. Then, at the bottom, put any lines that may trigger the error after these two lines:\nif __name__ == \"__main__\":\n  with launch_ipdb_on_exception():\n    <your properly indented code goes here>\nThis ensures that ipdb is launched when an error is reached.\n\n\n\n\n\n\nExample using ipdb\n\n\n\nSuppose that I want to write a function that will plot an xkcd comic in python.\nI start with\n\nfrom bs4 import BeautifulSoup\n## Error in py_call_impl(callable, dots$args, dots$keywords): ModuleNotFoundError: No module named 'bs4'\nimport urllib.request # work with html\nfrom PIL import Image # work with images\nimport numpy as np\n\n# importing pyplot and image from matplotlib\nimport matplotlib.pyplot as plt\nimport matplotlib.image as img\n\n# get the most current xkcd\ndef get_xkcd():\n  url = \"http://xkcd.com\"\n  \n  # Get the URL\n  html_file = urllib.request.urlopen(url)\n  page = html_file.read() \n  decode_page = page.decode(\"utf8\")\n  \n  # Read the page as HTML\n  soup = BeautifulSoup(decode_page, 'html')\n  \n  # Get the comic src from the img tag\n  imlink = soup.select('#comic > img')[0].get('src')\n  # Format as a numpy array\n  image = np.array(Image.open(urllib.request.urlopen(imlink)))\n  \n  return image\n\nplt.imshow(get_xkcd())\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'BeautifulSoup' is not defined\nplt.show()\n\n\n\n\nHere’s the final function\n\nfrom bs4 import BeautifulSoup\n## Error in py_call_impl(callable, dots$args, dots$keywords): ModuleNotFoundError: No module named 'bs4'\nimport urllib.request # work with html\nfrom PIL import Image # work with images\nimport numpy as np\n\n# importing pyplot and image from matplotlib\nimport matplotlib.pyplot as plt\nimport matplotlib.image as img\n\n# get the most current xkcd\ndef get_xkcd():\n  url = \"http://xkcd.com\"\n  \n  # Get the URL\n  html_file = urllib.request.urlopen(url)\n  page = html_file.read() \n  decode_page = page.decode(\"utf8\")\n  \n  # Read the page as HTML\n  soup = BeautifulSoup(decode_page, 'html')\n  \n  # Get the comic src from the img tag\n  imlink = soup.select('#comic > img')[0].get('src')\n  # Format as a numpy array\n  image = np.array(Image.open(urllib.request.urlopen('https:' + imlink)))\n  \n  return image\n\nplt.imshow(get_xkcd())\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'BeautifulSoup' is not defined\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTry it out\n\n\n\n\n\nProblem\nR Solution\nPython Solution\n\n\n\nEach xkcd has a corresponding ID number (ordered sequentially from 1 to 2722 at the time this was written). Modify the XKCD functions above to make use of the id parameter, so that you can pass in an ID number and get the relevant comic.\nUse interactive debugging tools to help you figure out what logic you need to add. You should not need to change the web scraping code - the only change should be to the URL.\nWhat things might you add to make this function “defensive programming” compatible?\n\n\n\n# get the most current xkcd or the specified number\nget_xkcd <- function(id = NULL) {\n  if (is.null(id)) {\n    # Have to get the location of the image ourselves\n    url <- \"http://xkcd.com\"\n  } else if (is.numeric(id)) {\n    url <- paste0(\"http://xkcd.com/\", id, \"/\")\n  } else {\n    # only allow numeric or null input\n    stop(\"To get current xkcd, pass in NULL, otherwise, pass in a valid comic number\")\n  }\n\n  page <- read_html(url)\n  # Find the comic\n  image <- xml_find_first(page, \"//div[@id='comic']/img\") %>%\n    # pull the address out of the tag\n    xml_attr(\"src\")\n  # Fix image address so that we can access the image\n  image <- substr(image, 3, nchar(image)) # cut the first 2 characters off\n\n  # make temp file\n  location <- tempfile(fileext = \"png\")\n  download.file(image, destfile = location, quiet = T)\n\n  # This checks to make sure we saved the file correctly\n  if (file.exists(location)) {\n    readPNG(source = location)\n  } else {\n    # Give a good informative error message\n    stop(paste(\"Something went wrong saving the image at \", image, \" to \", location))\n  }\n}\n\nget_xkcd(2259) %>%\n  as.raster() %>% \n  plot()\n\n\n\n\n\n\n\nfrom bs4 import BeautifulSoup\n## Error in py_call_impl(callable, dots$args, dots$keywords): ModuleNotFoundError: No module named 'bs4'\nimport urllib.request # work with html\nfrom PIL import Image # work with images\nimport numpy as np\n\n# importing pyplot and image from matplotlib\nimport matplotlib.pyplot as plt\nimport matplotlib.image as img\n\n# get the most current xkcd\ndef get_xkcd(id=''):\n  image = 0 # Defining a placeholder\n  \n  if id == '':\n    # Have to get the location of the image ourselves\n    url = \"http://xkcd.com\"\n  elif id.isnumeric():\n    url = \"http://xkcd.com/\" + id + \"/\"\n  else:\n    # only allow numeric or null input\n    raise TypeError(\"To get current xkcd, pass in an empty string, otherwise, pass in a valid integer comic number\")\n  \n  # Print debugging left in for your amusement\n  # print(type(id))\n  \n  # Get the URL\n  html_file = urllib.request.urlopen(url)\n  page = html_file.read() \n  decode_page = page.decode(\"utf8\")\n  \n  # Read the page as HTML\n  soup = BeautifulSoup(decode_page, 'html')\n  \n  # Get the comic src from the img tag\n  imnode = soup.select('#comic > img')\n  \n  try:\n    imlink = imnode[0].get('src')\n  except:\n    raise Exception(\"No comic could be found with number \" + id + \" (url = \"+ url+ \" )\")\n  \n  try: \n    # Format as a numpy array\n    image = np.array(Image.open(urllib.request.urlopen('https:' + imlink)))\n    return image\n  except: \n    raise Exception(\"Reading the image failed. Check to make sure an image exists at \" + url)\n    return(None)\n\n\nres = get_xkcd('')\n\nError in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'BeautifulSoup' is not defined\n\nplt.imshow(res)\n\nError in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'res' is not defined\n\nplt.show()\n\n\n\nres = get_xkcd('3000')\n\nError in py_call_impl(callable, dots$args, dots$keywords): urllib.error.HTTPError: HTTP Error 404: Not Found\n\nres = get_xkcd('abcd')\n\nError in py_call_impl(callable, dots$args, dots$keywords): TypeError: To get current xkcd, pass in an empty string, otherwise, pass in a valid integer comic number\n\n\n\n\n\n\n\n\n13.0.3 R debug()\n\nIn the traceback() Rstudio output, the other option is “rerun with debug”. In short, debug mode opens up a new interactive session inside the function evaluation environment. This lets you observe what’s going on in the function, pinpoint the error (and what causes it), and potentially fix the error, all in one neat workflow.\ndebug() is most useful when you’re working with code that you didn’t write yourself. So, if you can’t change the code in the function causing the error, debug() is the way to go. Otherwise, using browser() is generally easier. Essentially, debug() places a browser() statement at the first line of a function, but without having to actually alter the function’s source code.\n\n\n\n\n\n\ndebug() example\n\n\n\n\n\n\ndata(iris)\n\ntmp <- lm(Species ~ ., data = iris)\nsummary(tmp)\n## \n## Call:\n## lm(formula = Species ~ ., data = iris)\n## \n## Residuals:\n## Error in quantile.default(resid): (unordered) factors are not allowed\n\nWe get this weird warning, and then an error about factors when we use summary() to look at the coefficients.\n\ndebug(lm) # turn debugging on\n\n\ntmp <- lm(Species ~ ., data = iris)\nsummary(tmp)\n\nundebug(lm) # turn debugging off\n\n\n\nThe first thing I see when I run lm after turning on debug (screenshot)\n\n\n\n\nThe variables passed into the lm function are available as named and used in the function. In addition, we have some handy buttons in the console window that will let us ‘drive’ through the function\n\n\nAfter pressing “next” a few times, you can see that I’ve stepped through the first few lines of the lm function.\n\n\nStepping through the function. The arrow on the left side in the editor window shows which line of code we’re currently at.\n\n\nWe can see that once we’re at line 21, we get a warning about using type with a factor response, and that the warning occurs during a call to the model.response function. So, we’ve narrowed our problem down - we passed in a numeric variable as the response (y) variable, but it’s a factor, so our results aren’t going to mean much. We were using the function wrong.\nWe probably could have gotten there from reading the error message carefully, but this has allowed us to figure out exactly what happened, where it happened, and why it happened.\n\n\nI can hit “Stop” or type “Q” to exit the debug environment.\n\n\nBut, until I run undebug(lm), every call to lm will take me into the debug window.\n\n\n\nundebug(f) will remove the debug flag on the function f. debugonce(f) will only debug f the first time it is run.\n\n\n\n\n\n\nTry it out: debug in R\n\n\n\n\n\nProblem\nSolution\n\n\n\nlarger(x, y) is supposed to return the elementwise maximum of two vectors.\n\nlarger <- function(x, y) { \n  y.is.bigger <- y > x \n  x[y.is.bigger] <- y[y.is.bigger] \n  x\n} \n\nlarger(c(1, 5, 10), c(2, 4, 11))\n## [1]  2  5 11\n\n\nlarger(c(1, 5, 10), 6)\n## [1]  6 NA 10\n\nWhy is there an NA in the second example? It should be a 6. Figure out why this happens, then try to fix it.\n\n\nI’ll replicate “debug” in non-interactive mode by setting up an environment where x and y are defined\n\n\nx <- c(1, 5, 10)\ny <- 6\n\n# Inside of larger() with x = c(1, 5, 10), y = 6\n(y.is.bigger <- y > x ) # putting something in () prints it out\n## [1]  TRUE  TRUE FALSE\ny[y.is.bigger] # This isn't quite what we were going for, but it's what's causing the issue\n## [1]  6 NA\nx[y.is.bigger] # What gets replaced\n## [1] 1 5\n\n\n# Better option\nlarger <- function(x, y) { \n  y.is.bigger <- y > x \n  ifelse(y.is.bigger, y, x)\n} \n\n\n\n\n\n\n\n\n\n\n[1] \nWikipedia Contributors, “Defensive programming,” Wikipedia. Wikimedia Foundation, Apr. 2022 [Online]. Available: https://en.wikipedia.org/w/index.php?title=Defensive_programming&oldid=1084121123. [Accessed: May 31, 2022]\n\n\n[2] \nH. Wickham et al., “Welcome to the tidyverse,” Journal of Open Source Software, vol. 4, no. 43, p. 1686, 2019, doi: 10.21105/joss.01686. \n\n\n[3] \nK. Ushey, Renv: Project environments. 2022 [Online]. Available: https://CRAN.R-project.org/package=renv\n\n\n\n[4] \nH. Wickham and J. Bryan, R Packages: Organize, Test, Document, and Share Your Code, 1st ed. Sebastopol, CA: O’Reilly, 2015 [Online]. Available: https://r-pkgs.org/. [Accessed: Sep. 23, 2022]\n\n\n[5] \nT. Beuzen and T. Timbers, Python Packages, 1st edition. Boca Raton: Chapman; Hall/CRC, 2022 [Online]. Available: https://py-pkgs.org/\n\n\n\n[6] \nJ. Evans, “A debugging manifesto https://t.co/3eSOFQj1e1,” Twitter. Sep. 2022 [Online]. Available: https://twitter.com/b0rk/status/1570060516839641092. [Accessed: Sep. 21, 2022]\n\n\n[7] \nNasser_Junior, “User.fist_name https://t.co/lxrf3IFO4x,” Twitter. Aug. 2020 [Online]. Available: https://twitter.com/Nasser_Junior/status/1295805928315531264. [Accessed: Sep. 21, 2022]\n\n\n[8] \nH. Wickham, Advanced R, 2nd ed. CRC Press, 2019 [Online]. Available: http://adv-r.had.co.nz/. [Accessed: May 09, 2022]\n\n\n[9] \nJ. Evans, “Debugging strategy: Reread the error message https://t.co/2BZHhPg04h,” Twitter. Sep. 2022 [Online]. Available: https://twitter.com/b0rk/status/1570463473011920897. [Accessed: Sep. 21, 2022]\n\n\n[10] \nJ. Evans, “Debugging strategy: Shorten your feedback loop https://t.co/1cByDlafsK,” Twitter. Jul. 2022 [Online]. Available: https://twitter.com/b0rk/status/1549164800978059264. [Accessed: Sep. 21, 2022]\n\n\n[11] \nJ. Evans, “Debugging strategy: Write a tiny program https://t.co/Kajr5ZyeIp,” Twitter. Jul. 2022 [Online]. Available: https://twitter.com/b0rk/status/1547247776001654786. [Accessed: Sep. 21, 2022]\n\n\n[12] \nJ. Evans, “Debugging strategy: Change working code into broken code https://t.co/1T5uNDDFs0,” Twitter. Jul. 2022 [Online]. Available: https://twitter.com/b0rk/status/1545099244238946304. [Accessed: Sep. 21, 2022]\n\n\n[13] \nJ. Evans, “Debugging strategy: Come up with one question https://t.co/2Lytzl4laQ,” Twitter. Aug. 2022 [Online]. Available: https://twitter.com/b0rk/status/1554120424602193921. [Accessed: Sep. 21, 2022]\n\n\n[14] \nJ. Evans, “Debugging strategy: Write a unit test https://t.co/mC01DBNyM3,” Twitter. Aug. 2022 [Online]. Available: https://twitter.com/b0rk/status/1561718747504803842. [Accessed: Sep. 21, 2022]\n\n\n[15] \nT. Monteiro, “Improve how you code: Understanding rubber duck debugging. Duckly blog,” Oct. 31, 2019. [Online]. Available: https://duckly.com/blog/improve-how-to-code-with-rubber-duck-debugging/. [Accessed: Jan. 11, 2023]\n\n\n[16] \nS. Grimes, “This 500-Year-Old Piece of Advice Can Help You Solve Your Modern Problems,” Forge. Dec. 2019 [Online]. Available: https://forge.medium.com/the-500-year-old-piece-of-advice-that-will-change-your-life-1e580f115731. [Accessed: Sep. 21, 2022]"
  },
  {
    "objectID": "part-gen-prog/06-debugging.html#indoc--",
    "href": "part-gen-prog/06-debugging.html#indoc--",
    "title": "11  Debugging",
    "section": "\n11.6 indoc <- ’",
    "text": "11.6 indoc <- ’\ntitle: “Basic SASmarkdown Doc” author: “Doug Hemken” output: html_document —"
  },
  {
    "objectID": "part-gen-prog/07-matrix-calcs.html",
    "href": "part-gen-prog/07-matrix-calcs.html",
    "title": "12  Matrix Calculations",
    "section": "",
    "text": "While R, SAS, and Python are all extremely powerful statistical programming languages, the core of most programming languages is the ability to do basic calculations and matrix arithmetic. As almost every dataset is stored as a matrix-like structure (data sets and data frames both allow for multiple types, which isn’t quite compatible with more canonical matrices), it is useful to know how to do matrix-level calculations in whatever language you are planning to use to work with data.\nIn this section, we will essentially be using our programming language as overgrown calculators.\nIn the next chapters we’ll talk about data types and structures, so you’ll get to see more about matrices and arrays, but for now, let’s confine ourselves to using R and python to do basic math calculations.\n\n\nTable 12.1: Table of common mathematical and matrix operations in R, SAS, and Python [1].\n\n\n\n\n\n\n\nOperation\nR\nSAS\nPython\n\n\n\nAddition\n+\n+\n+\n\n\nSubtraction\n-\n-\n-\n\n\nElementwise Multiplication\n*\n#\n*\n\n\nDivision\n/\n/\n/\n\n\nModulo (Remainder)\n%%\nMOD\n%\n\n\nInteger Division\n%/%\nFLOOR(x\\y)\n//\n\n\nElementwise Exponentiation\n^\n##\n**\n\n\nMatrix/Vector Multiplication\n%*%\n*\nnp.dot()\n\n\nMatrix Exponentiation\n^\n**\nnp.exp()\n\n\nMatrix Transpose\nt(A)\n\nA`\nnp.transpose(A)\n\n\nMatrix Determinant\ndet(A)\ndet(A)\nnp.linalg.det(A)\n\n\nMatrix Diagonal\ndiag(A)\ndiag(A)\nnp.linalg.diag(A)\n\n\nMatrix Inverse\nsolve(A)\nsolve(A, diag({...}))\nnp.linalg.inv(A)\n\n\n\n\n\n12.0.1 Basic Mathematical Operators\n\n\nR\nPython\nSAS\n\n\n\n\nx <- 1:10\ny <- seq(3, 30, by = 3)\n\nx + y\n##  [1]  4  8 12 16 20 24 28 32 36 40\nx - y\n##  [1]  -2  -4  -6  -8 -10 -12 -14 -16 -18 -20\nx * y\n##  [1]   3  12  27  48  75 108 147 192 243 300\nx / y\n##  [1] 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333\n##  [8] 0.3333333 0.3333333 0.3333333\nx^2\n##  [1]   1   4   9  16  25  36  49  64  81 100\nt(x) %*% y\n##      [,1]\n## [1,] 1155\n\n\n\n\nimport numpy as np\n\nx = np.array(range(1, 11))\ny = np.array(range(3, 33, 3)) # python indexes are not inclusive\n\nx + y\n## array([ 4,  8, 12, 16, 20, 24, 28, 32, 36, 40])\nx - y\n## array([ -2,  -4,  -6,  -8, -10, -12, -14, -16, -18, -20])\nx * y\n## array([  3,  12,  27,  48,  75, 108, 147, 192, 243, 300])\nx / y\n## array([0.33333333, 0.33333333, 0.33333333, 0.33333333, 0.33333333,\n##        0.33333333, 0.33333333, 0.33333333, 0.33333333, 0.33333333])\nx ** 2\n## array([  1,   4,   9,  16,  25,  36,  49,  64,  81, 100])\nnp.dot(x.T, y)\n## 1155\n\n\n\nBy default, SAS creates row vectors with do(a, b, by = c) syntax. The transpose operator (a single backtick) can be used to transform A into A`.\nproc iml; \n  x = do(1, 10, 1);\n  y = do(3, 30, 3);\n\n  z = x + y;\n  z2 = x - y;\n  z3 = x # y;\n  z4 = x/y;\n  z5 = x##2;\n  z6 = x` * y;\n  print z, z2, z3, z4, z5, z6;\nquit;\n\n\n\n\n12.0.2 Matrix Operations\nOther matrix operations, such as determinants and extraction of the matrix diagonal, are similarly easy:\n\n\nR\nPython\nSAS\n\n\n\n\nmat <- matrix(c(1, 2, 3, 6, 4, 5, 7, 8, 9), nrow = 3, byrow = T)\nmat\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    6    4    5\n## [3,]    7    8    9\nt(mat) # transpose\n##      [,1] [,2] [,3]\n## [1,]    1    6    7\n## [2,]    2    4    8\n## [3,]    3    5    9\ndet(mat) # get the determinant\n## [1] 18\ndiag(mat) # get the diagonal\n## [1] 1 4 9\ndiag(diag(mat)) # get a square matrix with off-diag 0s\n##      [,1] [,2] [,3]\n## [1,]    1    0    0\n## [2,]    0    4    0\n## [3,]    0    0    9\ndiag(1:3) # diag() also will create a diagonal matrix if given a vector\n##      [,1] [,2] [,3]\n## [1,]    1    0    0\n## [2,]    0    2    0\n## [3,]    0    0    3\n\n\n\n\nimport numpy as np\nmat = np.array([[1, 2, 3],[6, 4, 5],[7, 8, 9]], dtype = int, order ='C')\n\nmat\n## array([[1, 2, 3],\n##        [6, 4, 5],\n##        [7, 8, 9]])\nmat.T\n## array([[1, 6, 7],\n##        [2, 4, 8],\n##        [3, 5, 9]])\nnp.linalg.det(mat) # numerical precision...\n## 18.000000000000004\nnp.diag(mat)\n## array([1, 4, 9])\nnp.diag(np.diag(mat))\n## array([[1, 0, 0],\n##        [0, 4, 0],\n##        [0, 0, 9]])\nnp.diag(range(1, 4))\n## array([[1, 0, 0],\n##        [0, 2, 0],\n##        [0, 0, 3]])\n\n\n\nproc iml;\n  mat = {1 2 3, 6 4 5, 7 8 9}; \n  tmat = mat`; /* transpose */\n  determinant = det(mat); /* get the determinant */\n  diagonal_vector = vecdiag(mat); /* get the diagonal as a vector */\n  diagonal_mat = diag(mat); /* get the diagonal as a square matrix */\n                            /* with 0 on off-diagonal entries */\n  \n  dm = diag({1 2 3}); /* make a square matrix with vector as the diagonal */\n  \n  print tmat, determinant, diagonal_vector, diagonal_mat, dm;\nquit;\n\n\n\n\n12.0.3 Matrix Inverse\nThe other important matrix-related function is the inverse. In R, A^-1 will get you the elementwise reciprocal of the matrix. Not exactly what we’d like to see… Instead, in R and SAS, we use the solve() function. The inverse is defined as the matrix B such that AB = I where I is the identity matrix (1’s on diagonal, 0’s off-diagonal). So if we solve(A) (in R) or solve(A, diag(n)) in SAS (where n is a vector of 1s the size of A), we will get the inverse matrix. In Python, we use the np.linalg.inv() function to invert a matrix, which is a bit more linguistically familiar.\n\n\nR\nPython\nSAS\n\n\n\n\nmat <- matrix(c(1, 2, 3, 6, 4, 5, 7, 8, 9), nrow = 3, byrow = T)\n\nminv <- solve(mat) # get the inverse\n\nminv\n##            [,1]       [,2]       [,3]\n## [1,] -0.2222222  0.3333333 -0.1111111\n## [2,] -1.0555556 -0.6666667  0.7222222\n## [3,]  1.1111111  0.3333333 -0.4444444\nmat %*% minv \n##               [,1]         [,2]          [,3]\n## [1,]  1.000000e+00 0.000000e+00  1.110223e-16\n## [2,] -8.881784e-16 1.000000e+00 -5.551115e-16\n## [3,]  0.000000e+00 2.220446e-16  1.000000e+00\n\n\n\n\nimport numpy as np\nmat = np.array([[1, 2, 3],[6, 4, 5],[7, 8, 9]], dtype = int, order ='C')\n\nminv = np.linalg.inv(mat)\nminv\n## array([[-0.22222222,  0.33333333, -0.11111111],\n##        [-1.05555556, -0.66666667,  0.72222222],\n##        [ 1.11111111,  0.33333333, -0.44444444]])\nnp.dot(mat, minv)\n## array([[ 1.00000000e+00,  0.00000000e+00,  1.11022302e-16],\n##        [-8.88178420e-16,  1.00000000e+00, -5.55111512e-16],\n##        [ 0.00000000e+00,  2.22044605e-16,  1.00000000e+00]])\nnp.round(np.dot(mat, minv), 2)\n## array([[ 1.,  0.,  0.],\n##        [-0.,  1., -0.],\n##        [ 0.,  0.,  1.]])\n\n\n\nDocumentation\n    proc iml;\n      mat = {1 2 3, 6 4 5, 7 8 9};\n\n      mat_inv = solve(mat, diag({1 1 1})); /* get the inverse */\n      mat_inv2 = inv(mat); /* less efficient and less accurate */\n      print mat_inv, mat_inv2;\n\n      id = mat * mat_inv;\n      id2 = mat * mat_inv2;\n      print id, id2; \n    quit;\n\n\n\n\n\n\n\n[1] \nQuartz25, Jesdisciple, H. Röst, D. Ross, L. D’Oliveiro, and BLibrestez55, Python Programming. Wikibooks, 2016 [Online]. Available: https://en.wikibooks.org/wiki/Python_Programming. [Accessed: May 28, 2022]"
  },
  {
    "objectID": "part-wrangling/00-wrangling.html#sec-wrangling-refs",
    "href": "part-wrangling/00-wrangling.html#sec-wrangling-refs",
    "title": "Part III: Data Wrangling",
    "section": "References",
    "text": "References\n\n\n\n\n[1] H. Wickham, “Tidy data,” The Journal of Statistical Software, vol. 59, 2014 [Online]. Available: http://www.jstatsoft.org/v59/i10/"
  },
  {
    "objectID": "graveyard.html#sec-math-logic",
    "href": "graveyard.html#sec-math-logic",
    "title": "22  Other Topics",
    "section": "\n22.1 Mathematical Logic",
    "text": "22.1 Mathematical Logic\nIn Chapter 8 and Chapter 9 we talk about more complicated data structures and control structures (for loops, if statements). I’ve included this section because it may be useful to review some concepts from mathematical logic.\nUnfortunately, to best demonstrate mathematical logic, I’m going to need you to know that a vector is like a list of the same type of thing. In R, vectors are defined using c(), so c(1, 2, 3) produces a vector with entries 1, 2, 3. In Python, we’ll primarily use numpy arrays, which we create using np.array([1, 2, 3]). Technically, this is creating a list, and then converting that list to a numpy array.\n\n22.1.1 And, Or, and Not\nWe can combine logical statements using and, or, and not.\n\n(X AND Y) requires that both X and Y are true.\n(X OR Y) requires that one of X or Y is true.\n(NOT X) is true if X is false, and false if X is true. Sometimes called negation.\n\nIn R, we use ! to symbolize NOT, in Python, we use ~ for vector-wise negation (NOT).\nOrder of operations dictates that NOT is applied before other operations. So NOT X AND Y is read as (NOT X) AND (Y). You must use parentheses to change the way this is interpreted.\n\n\nR\nPython\n\n\n\n\nx <- c(TRUE, FALSE, TRUE, FALSE)\ny <- c(TRUE, TRUE, FALSE, FALSE)\n\nx & y # AND\n## [1]  TRUE FALSE FALSE FALSE\nx | y # OR\n## [1]  TRUE  TRUE  TRUE FALSE\n!x & y # NOT X AND Y\n## [1] FALSE  TRUE FALSE FALSE\nx & !y # X AND NOT Y\n## [1] FALSE FALSE  TRUE FALSE\n\n\n\n\nimport numpy as np\nx = np.array([True, False, True, False])\ny = np.array([True, True, False, False])\n\nx & y\n## array([ True, False, False, False])\nx | y\n## array([ True,  True,  True, False])\n~x & y\n## array([False,  True, False, False])\nx & ~y\n## array([False, False,  True, False])\n\n\n\n\n\n22.1.2 De Morgan’s Laws\nDe Morgan’s Laws are a set of rules for how to combine logical statements. You can represent them in a number of ways:\n\nNOT(A or B) is equivalent to NOT(A) and NOT(B)\nNOT(A and B) is equivalent to NOT(A) or NOT(B)\n\n\n\nDefinitions\nDeMorgan’s First Law\nDeMorgan’s Second Law\n\n\n\n\n\nVenn Diagram of Set A and Set B\n\n\nSuppose that we set the convention that .\n\n\n\n\nA venn diagram illustration of De Morgan’s laws showing that the region that is outside of the union of A OR B (aka NOT (A OR B)) is the same as the region that is outside of (NOT A) and (NOT B)\n\n\n\n\n\n\nA venn diagram illustration of De Morgan’s laws showing that the region that is outside of the union of A AND B (aka NOT (A AND B)) is the same as the region that is outside of (NOT A) OR (NOT B)"
  },
  {
    "objectID": "graveyard.html#sec-controlling-loops",
    "href": "graveyard.html#sec-controlling-loops",
    "title": "22  Other Topics",
    "section": "\n22.2 Controlling Loops with Break, Next, Continue",
    "text": "22.2 Controlling Loops with Break, Next, Continue\n\n\nSometimes it is useful to control the statements in a loop with a bit more precision. You may want to skip over code and proceed directly to the next iteration, or, as demonstrated in the previous section with the break statement, it may be useful to exit the loop prematurely.\n\n22.2.1 Break Statement\n\n\nA break statement is used to exit a loop prematurely\n\n\n\n22.2.2 Next/Continue Statement\n\n\nA next (or continue) statement is used to skip the body of the loop and continue to the next iteration\n\n\n\n\n\n\n\n\nExample: Next/continue and Break statements\n\n\n\nLet’s demonstrate the details of next/continue and break statements.\nWe can do different things based on whether i is evenly divisible by 3, 5, or both 3 and 5 (thus divisible by 15)\n\n\nR\nPython\n\n\n\n\nfor (i in 1:20) {\n  if (i %% 15 == 0) {\n    print(\"Exiting now\")\n    break\n  } else if (i %% 3 == 0) {    \n    print(\"Divisible by 3\")\n    next\n    print(\"After the next statement\") # this should never execute\n  } else if (i %% 5 == 0) {\n    print(\"Divisible by 5\")\n  } else {\n    print(i)\n  }\n}\n## [1] 1\n## [1] 2\n## [1] \"Divisible by 3\"\n## [1] 4\n## [1] \"Divisible by 5\"\n## [1] \"Divisible by 3\"\n## [1] 7\n## [1] 8\n## [1] \"Divisible by 3\"\n## [1] \"Divisible by 5\"\n## [1] 11\n## [1] \"Divisible by 3\"\n## [1] 13\n## [1] 14\n## [1] \"Exiting now\"\n\n\n\n\nfor i in range(1, 20):\n  if i%15 == 0:\n    print(\"Exiting now\")\n    break\n  elif i%3 == 0:\n    print(\"Divisible by 3\")\n    continue\n    print(\"After the next statement\") # this should never execute\n  elif i%5 == 0:\n    print(\"Divisible by 5\")\n  else: \n    print(i)\n## 1\n## 2\n## Divisible by 3\n## 4\n## Divisible by 5\n## Divisible by 3\n## 7\n## 8\n## Divisible by 3\n## Divisible by 5\n## 11\n## Divisible by 3\n## 13\n## 14\n## Exiting now\n\n\n\n\n\n\nTo be quite honest, I haven’t really ever needed to use next/continue statements when I’m programming, and I rarely use break statements. However, it’s useful to know they exist just in case you come across a problem where you could put either one to use."
  },
  {
    "objectID": "graveyard.html#sec-recursion",
    "href": "graveyard.html#sec-recursion",
    "title": "22  Other Topics",
    "section": "\n22.3 Recursion",
    "text": "22.3 Recursion\nUnder construction.\nIn the meantime, check out [1] (R) and [2] (Python) for decent coverage of the basic idea of recursive functions."
  },
  {
    "objectID": "graveyard.html#sec-other-topics-refs",
    "href": "graveyard.html#sec-other-topics-refs",
    "title": "22  Other Topics",
    "section": "\n22.4 References",
    "text": "22.4 References\n\n\n\n\n[1] \nDataMentor, “R recursion. DataMentor,” Nov. 24, 2017. [Online]. Available: https://www.datamentor.io/r-programming/recursion/. [Accessed: Jan. 10, 2023]\n\n\n[2] \nParewa Labs Pvt. Ltd., “Python recursion. Learn python interactively,” 2020. [Online]. Available: https://www.programiz.com/python-programming/recursion. [Accessed: Jan. 10, 2023]"
  }
]