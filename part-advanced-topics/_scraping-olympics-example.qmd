

::: demo

### Demo: Reading in Olympics Medals from HTML {-}

The IOC (International Olympic Committee) publishes medal counts for each Olympics, including the [2024 Paris games](https://www.olympics.com/en/olympic-games/paris-2024/medals). 
If the code below doesn't work, try using the [archived page](../data/Paris 2024 Olympic Medal Table - Gold, Silver & Bronze.html) instead. 
A screenshot of the rendered page is available in @fig-olympic-medal-page. 
Though the page *appears* to have a table, in fact, the table does not make use of an HTML table element; instead, each row is a series of `div` elements

```{r olympic-data-setup-r}
#| message: false
#| warning: false
library(rvest)
library(xml2)
library(tibble)
library(tidyr)
library(dplyr)
library(purrr)
library(stringr)

doc <- read_html("../data/Paris 2024 Olympic Medal Table - Gold, Silver & Bronze.html")

html_element(doc, "table") # Search the HTML for `<table>` -- no results
```


Next, we look at the HTML and see that the table itself is wrapped in an element: `<div class="Table-styles__Wrapper-sc-7c5c517a-0 cqlSCS"></div>`. 
That's too much to type, so search for elements with a class that contains "Table". 

```{r olympic-data-table-container-r}
table_nodes <- html_element(doc, css = "[class*='Table']") 
table_nodes
```

It can be hard to get the hang of "reading" HTML to make sense of it -- what I usually do is try to find the narrowest set of nodes I can that have the content I want. 
To identify this, I'll use a process like that shown in @fig-olympic-html-gif, where I'll right click on the web page in the browser, select "Inspect element", and then interactively hover over various HTML elements until I get a sense of what each component of the rendered page looks like in HTML. 

In this case, the 'minimal node' is `<div data-cy="table-content" class="Table-styles__CommonGrid-sc-7c5c517a-1 Table-styles__Content-sc-7c5c517a-3 dTTMvn jfNiTo"></div>` -- it has just the content, without the sortable headers and other stuff that we don't particularly care about.
That is, the headers and such are important for context, but can be added in to the table relatively quickly (and thus aren't worth the time to scrape). 

I also noticed that in each "column" of a single row, there are div elements with attributes that contain the row number (`data-row-id` or `data-medal-id`), and that each div element has one or the other of these attributes, but not both. 
That means that if we can get the row numbers from the attributes and the column numbers based on the relative position of the elements, we can reconstruct the table structure from just a list of disjoint `<div>` elements. 

::: {.learnmore collapse=true}

#### Another Approach: Text Editor HTML Magic {-}

Sometimes, if I'm not feeling the interactive inspection in the browser, or if things are complicated and/or the inspection isn't going well, I'll take a more direct approach and copy a subset of the HTML out into a text editor. Then, I do a little bit of find-and-replace magic: 

1. Search for `<` and replace it with `\n<`, to get each tag on its own line in the text document. HTML may not care much about whitespace between text nodes, but it makes it a lot more human-readable. 
2. Search for `\n</` and replace it with `</` to get the end tags back on the same line as the corresponding start tag (at least for elements with no children). 

You can see the result of this find-and-replace magic in [this file](../data/Paris 2024 Olympic Medal Table - Gold, Silver & Bronze - table only.txt). 

In my simplified view, I start to notice a pattern of div-span-span. 
That is, each div element contains a couple of span elements, and there are several div- elements that show up for each row in the table.
Some of these elements have attribute `data-row-id` and some have attribute `data-medal-id`, but the values of each of these attributes have `row-##` where `##` is the row number in the table. 
As a result, it seems like we might want to focus primarily on the div elements and only work with the span elements if we absolutely have to. 

:::

There is always a "prettier" way to do HTML parsing, but in most cases it's faster and more straightforward to take a quick-and-dirty approach and only make things more complicated if necessary. 

Based on the basic structure I've described above, let's try to write code that 

1. Looks for the div elements that have attributes `data-row-id` and `data-medal-id`
2. Gets the text from these elements
3. Rearranges the text from (2) into rows and columns using a pivot operation
4. Converts medal counts to numeric variables, if they are characters, replacing '-' with `NA`

Each step in this outline may take more than one line of code.


```{r olympic-data-scrape-r}
#| code-annotations: select

table_data <- html_elements(doc, css = "div[data-row-id],div[data-medal-id]")   # <1>

header_names <- c("row", "flag", "country_abb", 
                  "gold", "silver", "bronze", "total", "country")   # <2>

medal_data <- tibble(
  idx = 1:length(table_data),                                                   # <3>
  text = map_chr(table_data, html_text),                                        # <4>
  medal_attributes = map_chr(table_data, ~html_attr(., "data-medal-id")),       # <5>
  row_attributes = map_chr(table_data, ~html_attr(., "data-row-id"))            # <6>
) |>
  mutate(row = if_else(is.na(medal_attributes),                                 # <7>
                       str_extract(row_attributes, "\\d{1,}"),                  # <7>
                       str_extract(medal_attributes, "\\d{1,}"))) |>            # <7>
  group_by(row) |>                                                              # <8>
  mutate(column = 1:n()) |>                                                     # <8>
  select(-idx, -medal_attributes, -row_attributes) |>                           # <9>
  pivot_wider(names_from = column, values_from = text) |>                       # <10>
  set_names(header_names) |>                                                    # <11>
  mutate(across(gold:total, as.numeric))                                        # <12>
```
1. Search for `div` nodes that have either `data-row-id` or `data-medal-id` attributes. 
2. Define a header row that corresponds to the 8 `div` elements in each row.
3. Create a table with the index of the nodes in the list created in step 1.
4. Convert each HTML node to text (quick and dirty option)
5. Get the `data-row-id` if it exists
6. Get the `data-medal-id` if it exists
7. Get the row number from `data-row-id` if `medal_attributes` is `NA`, and otherwise, get it from `data-medal-id.`
8. Group by row number and create column number, assuming the nodes are in row, column order. 
9. Remove columns that are no longer necessary so they don't interfere with pivot operation
10. Pivot to replicate structure of original table, using the `column` values as column names for now.
11. Set column names to descriptive labels
12. Convert gold, silver, bronze, and total columns to numeric variables, which causes `NA` to replace '-' in the original table. 

```{r}
#| echo: false

knitr::kable(head(medal_data), row.names = F)

```

:::