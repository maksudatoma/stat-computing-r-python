{
  "hash": "cfba6ba3d9096af63b3c33793c1888e3",
  "result": {
    "engine": "knitr",
    "markdown": "# Other Topics {#sec-other-topics}\n\n## Shell Commands {#sec-shell-commands}\n\nWhen talking to computers, sometimes it is convenient to cut through the graphical interfaces, menus, and so on, and just tell the computer what to do directly, using the **system shell** (aka terminal, command line prompt, console).\n\nMost system shells are fully functioning programming languages in their own right. \nThis section isn't going to attempt to teach you those skills - we'll focus instead on the basics - how to change directories, list files, and run programs.\n\n### Launching the system terminal\n\nIn RStudio, you can access a system terminal in the lower left corner by clicking on the tab labeled Terminal. If the tab does not exist, then go to Tools -> Terminal -> New Terminal in the main application toolbar.\n\nSometimes, it is preferable to launch a terminal separate from RStudio. Here's how to do that:\n\n::: panel-tabset\n\n####  {{< fa brands windows >}} Windows \n\nOption 1: Default Windows terminal (cmd.exe)\n\n1. Go to the search bar/start menu\n2. Type in cmd.exe\n3. A black window should appear.\n\nOption 2: Git bash (if you have git installed)\n\n1. Go to the search bar/start menu\n2. Type in bash\n3. Click on the Git Bash application\n\nIf you choose option 2, use the commands for Bash/Linux below. Bash tends to be a bit less clunky than the standard windows terminal.\n\n####  {{< fa brands apple >}} Mac\n\nOption 1: Dock\n\n1. Click the launchpad icon\n2. Type Terminal in the search field\n3. Click Terminal\n\nOption 2: Finder\n\n1. Open the Applications/Utilities folder\n2. Double-click on Terminal\n\n\n####  {{< fa brands linux >}} Linux\n\nOn most systems, pressing Ctrl-Alt-T or Super-T (Windows-T) will launch a terminal. \n\nOtherwise, launch your system menu (usually with the Super/Windows key) and type Terminal. You may have multiple options here; I prefer Konsole but I'm usually using KDE as my desktop environment. Other decent options include Gnome-terminal and xterm, and these are usually associated with Gnome and XFCE desktop environments, respectively.\n\n:::\n\n### File Path Structure\n\nOn Windows, file paths are constructed as follows: `C:\\Folder 1\\Folder_2\\file.R`. Paths are *generally* not case sensitive, so you can reference the same file path as `c:\\folder 1\\folder_2\\file.R`. Usually, paths are encased in `\"\"` because spaces make interpreting file paths complicated and Windows paths have lots of spaces.\n\nOn Unix systems, file paths are constructed as follows: `/home/user/folder1/folder2/file.R`. Paths are case sensitive, so you cannot reach `/home/user/folder1/folder2/file.R` if you use `/home/user/folder1/folder2/file.r`. On Unix systems, spaces in file paths must be escaped with `\\`, so any space character in a terminal should be typed `\\ ` instead. \n\nThis quickly gets complicated and annoying when working on code that is meant for multiple operating systems. These complexities are why when you're constructing a file path in R or python, you should use commands like `file.path(\"folder1\", \"folder2\", \"file.r\")` or `os.path.join(\"folder1\", \"folder2\", \"file.py\")`, so that your code will work on Windows, Mac, and Linux by default.\n\n### Basic Terminal Commands\n\nI have listed commands here for the most common languages used in each operating system. \nIf you are using Git Bash on Windows, follow the commands for Linux/Bash. If you are using Windows PowerShell, google the commands. \n\nIn most cases, Mac/Zsh is similar to Linux/Bash, but there are a few differences^[Mac used to use [bash](https://en.wikipedia.org/wiki/Bash_(Unix_shell)) but switched to [Zsh](https://en.wikipedia.org/wiki/Z_shell) in 2019 for licensing reasons.].\n\n::: {.column-page}\n\nTask |  {{< fa brands windows >}} Windows/CMD | {{< fa brands apple >}} Mac/Zsh |  {{< fa brands linux >}} Linux/Bash\n--- | --- | --- | ---\nList your current working directory | `cd` | `pwd` | `pwd`\nChange directory | `cd <path to new dir>` | `cd <path to new dir>` | `cd <path to new dir>`\nList files and folders in current directory | `dir` | `ls` | `ls`\nCopy file | `xcopy <source> <destination> <arguments>` | `cp <arguments> <source> <destination>`  | `cp <arguments> <source> <destination>` \nCreate directory | `mkdir <foldername>` | `mkdir <foldername>` | `mkdir <foldername>`\nDisplay file contents | `type <filename>` | `cat <filename>` | `cat <filename>`\n\n:::\n\n\n## Controlling Loops with Break, Next, Continue {#sec-controlling-loops}\n\n<!-- https://www.py4e.com/html3/05-iterations -->\n\n<!-- https://www.datamentor.io/r-programming/break-next/ -->\n\nSometimes it is useful to control the statements in a loop with a bit more precision. \nYou may want to skip over code and proceed directly to the next iteration, or, as demonstrated in the previous section with the `break` statement, it may be useful to exit the loop prematurely.\n\n### Break Statement\n\n![A break statement is used to exit a loop prematurely](images/other/break-statement.png)\n\n### Next/Continue Statement \n\n![A next (or continue) statement is used to skip the body of the loop and continue to the next iteration](images/other/next-statement-flow.png)\n\n\n::: callout-warning\n### Example: Next/continue and Break statements\nLet's demonstrate the details of next/continue and break statements.\n\nWe can do different things based on whether i is evenly divisible by 3, 5, or both 3 and 5 (thus divisible by 15)\n\n::: panel-tabset\n#### R {.unnumbered}\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:20) {\n  if (i %% 15 == 0) {\n    print(\"Exiting now\")\n    break\n  } else if (i %% 3 == 0) {    \n    print(\"Divisible by 3\")\n    next\n    print(\"After the next statement\") # this should never execute\n  } else if (i %% 5 == 0) {\n    print(\"Divisible by 5\")\n  } else {\n    print(i)\n  }\n}\n## [1] 1\n## [1] 2\n## [1] \"Divisible by 3\"\n## [1] 4\n## [1] \"Divisible by 5\"\n## [1] \"Divisible by 3\"\n## [1] 7\n## [1] 8\n## [1] \"Divisible by 3\"\n## [1] \"Divisible by 5\"\n## [1] 11\n## [1] \"Divisible by 3\"\n## [1] 13\n## [1] 14\n## [1] \"Exiting now\"\n```\n:::\n\n\n\n\n\n#### Python {.unnumbered}\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfor i in range(1, 20):\n  if i%15 == 0:\n    print(\"Exiting now\")\n    break\n  elif i%3 == 0:\n    print(\"Divisible by 3\")\n    continue\n    print(\"After the next statement\") # this should never execute\n  elif i%5 == 0:\n    print(\"Divisible by 5\")\n  else: \n    print(i)\n## 1\n## 2\n## Divisible by 3\n## 4\n## Divisible by 5\n## Divisible by 3\n## 7\n## 8\n## Divisible by 3\n## Divisible by 5\n## 11\n## Divisible by 3\n## 13\n## 14\n## Exiting now\n```\n:::\n\n\n\n\n:::\n:::\n\nTo be quite honest, I haven't really ever needed to use next/continue statements when I'm programming, and I rarely use break statements. However, it's useful to know they exist just in case you come across a problem where you could put either one to use.\n\n\n## Recursion {#sec-recursion}\n\nUnder construction. \n\nIn the meantime, check out @datamentorRecursion2017 (R) and @parewalabspvtPythonRecursion2020 (Python) for decent coverage of the basic idea of recursive functions.\n\n\n\n## Text Encoding {#sec-text-encoding}\n\n\nI've left this section in because it's a useful set of tricks, even though it does primarily deal with SAS. \n\nDon't know what UTF-8 is? [Watch this excellent YouTube video explaining the history of file encoding!](https://www.youtube.com/watch?v=MijmeoH9LT4)\n\nSAS also has procs to accommodate CSV and other delimited files. \nPROC IMPORT may be the simplest way to do this, but of course a DATA step will work as well. \nWe do have to tell SAS to treat the data file as a UTF-8 file (because of the japanese characters). \n\n\nWhile writing this code, I got an error of \"Invalid logical name\" because originally the filename was pokemonloc. Let this be a friendly reminder that your dataset names in SAS are limited to 8 characters in SAS. \n\n```\n/* x \"curl https://raw.githubusercontent.com/shahinrostami/pokemon_dataset/master/pokemon_gen_1_to_8.csv > ../data/pokemon_gen_1-8.csv\";\nonly run this once to download the file... */\nfilename pokeloc '../data/pokemon_gen_1-8.csv' encoding=\"utf-8\";\n\n\nproc import datafile = pokeloc out=poke\n  DBMS = csv; /* comma delimited file */\n  GETNAMES = YES\n  ;\nproc print data=poke (obs=10); /* print the first 10 observations */\n  run;\n```\n\nAlternately (because UTF-8 is finicky depending on your OS and the OS the data file was created under), you can convert the UTF-8 file to ASCII or some other safer encoding before trying to read it in.\n\nIf I fix the file in R (because I know how to fix it there... another option is to fix it manually), \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(dplyr)\ntmp <- read_csv(\"https://raw.githubusercontent.com/shahinrostami/pokemon_dataset/master/pokemon_gen_1_to_8.csv\")[,-1]\nwrite_csv(tmp, \"../data/pokemon_gen_1-8.csv\")\n\ntmp <- select(tmp, -japanese_name) %>%\n  # iconv converts strings from UTF8 to ASCII by transliteration - \n  # changing the characters to their closest A-Z equivalents.\n  # mutate_all applies the function to every column\n  mutate_all(iconv, from=\"UTF-8\", to = \"ASCII//TRANSLIT\")\n\nwrite_csv(tmp, \"../data/pokemon_gen_1-8_ascii.csv\", na='.')\n```\n:::\n\n\n\n\n\nThen, reading in the new file allows us to actually see the output.\n```\nlibname classdat \"sas/\";\n/* Create a library of class data */\n\nfilename pokeloc  \"../data/pokemon_gen_1-8_ascii.csv\";\n\nproc import datafile = pokeloc out=classdat.poke\n  DBMS = csv /* comma delimited file */\n  replace;\n  GETNAMES = YES;\n  GUESSINGROWS = 1028 /* use all data for guessing the variable type */\n  ;\nproc print data=classdat.poke (obs=10); /* print the first 10 observations */\n  run; \n```\n\nThis trick works in so many different situations. It's very common to read and do initial processing in one language, then do the modeling in another language, and even move to a different language for visualization. Each programming language has its strengths and weaknesses; if you know enough of each of them, you can use each tool where it is most appropriate. \n\n\n\n\n\n\n## References {#sec-other-topics-refs}\n",
    "supporting": [
      "graveyard_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}