{
  "hash": "35cd12fe6f1c12ee38ce9a466e47fa24",
  "result": {
    "engine": "knitr",
    "markdown": "# Using Functions and Libraries {#sec-calculator}\n\nIn addition to variables, **functions** are extremely important in programming.\nFunctions allow you to repeat a series of steps using different information and get the result.\nIn a way, a function is to a variable as a verb is to a noun - functions are a concise way of performing an action.\n\n## {{< fa bullseye >}} Objectives\n\n-   Understand how functions are used in R and python\n-   Understand how to install packages in R and python\n-   Understand how to load packages in R and python\n-   Use pipes to restructure code so that it is more readable\n\n## Mathematical Operators\n\nLet's first start with a special class of functions that you're probably familiar with from your math classes - mathematical operators.\n\nHere are a few of the most important ones:\n\n| Operation        | R symbol | Python symbol |\n|------------------|----------|---------------|\n| Addition         | `+`      | `+`           |\n| Subtraction      | `-`      | `-`           |\n| Multiplication   | `*`      | `*`           |\n| Division         | `/`      | `/`           |\n| Integer Division | `%/%`    | `//`          |\n| Modular Division | `%%`     | `%`           |\n| Exponentiation   | `^`      | `**`          |\n\n: Mathematical operators in R and Python {#tbl-math-operators}\n\nThese operands are all for scalar operations (operations on a single number) - vectorized versions, such as matrix multiplication, are somewhat more complicated (and different between R and python).\n\n::: callout-caution\n\n### Example: Integer and Modular Division\n\nInteger division is the whole number answer to A/B, and modular division is the fractional remainder when A/B.\n\nLet's demonstrate with the problem 14/3, which evaluates to 4.6666667 when division is used, but has integer part 4 and remainder 2.\n\n::: panel-tabset\n\n### R {.unnumbered}\n\n`14 %/% 3` in R would be 4, and `14 %% 3` in R would be 2.\n\n::: {.cell}\n\n```{.r .cell-code}\n14 %/% 3\n## [1] 4\n14 %% 3\n## [1] 2\n```\n:::\n\n### Python {.unnumbered}\n\n::: {.cell}\n\n```{.python .cell-code}\n14 // 3\n## 4\n14 % 3\n## 2\n```\n:::\n\n:::\n\n:::\n\n## Order of Operations\n\nBoth R and Python operate under the same mathematical rules of precedence that you learned in school.\nYou may have learned the acronym PEMDAS, which stands for Parentheses, Exponents, Multiplication/Division, and Addition/Subtraction.\nThat is, when examining a set of mathematical operations, we evaluate parentheses first, then exponents, and then we do multiplication/division, and finally, we add and subtract.\n\n::: panel-tabset\n\n### R {.unnumbered}\n\n::: {.cell}\n\n```{.r .cell-code}\n(1+1)^(5-2) # <1>\n1 + 2^3 * 4 # <2>\n3*1^3 # <3>\n## [1] 8\n## [1] 33\n## [1] 3\n```\n:::\n1. The items in parentheses are evaluated first, so the expression becomes (2)^(3). Then, exponentiation is performed, yielding 8.\n2. Exponentiation is performed first (PEMDAS), so the expression becomes 1 + 8*4. Then multiplication is performed, yielding 1 + 32. Addition is the final step, so we get 33.\n3. Exponentiation is performed first, so this becomes 3*1. Then multiplication is performed, producing a final result of 3. \n\n### Python {.unnumbered}\n\n::: {.cell}\n\n```{.python .cell-code}\n(1+1)**(5-2) # <1>\n1 + 2**3*4 # <2>\n3*1**3 # <3>\n## 8\n## 33\n## 3\n```\n:::\n1. The items in parentheses are evaluated first, so the expression becomes (2)^(3). Then, exponentiation is performed, yielding 8.\n2. Exponentiation is performed first (PEMDAS), so the expression becomes 1 + 8*4. Then multiplication is performed, yielding 1 + 32. Addition is the final step, so we get 33.\n3. Exponentiation is performed first, so this becomes 3*1. Then multiplication is performed, producing a final result of 3. \n\n:::\n\n## Simple String Operations\n\nPython has some additional operators that work on strings.\nIn R, you will have to use functions to perform these operations, as R does not have string operators.\n\n::: callout-demo\n\n### String Operations in R and Python\n\n::: panel-tabset\n\n#### Python {.unnumbered}\n\nIn Python, `+` will **concatenate** (stick together) two strings.\nMultiplying a string by an integer will repeat the string the specified number of times.\n\n::: {.cell}\n\n```{.python .cell-code}\n\"first \" + \"second\"\n## 'first second'\n\"hello \" * 3\n## 'hello hello hello '\n```\n:::\n\n#### R {.unnumbered}\n\nIn R, to concatenate things, we need to use functions: `paste` or `paste0`:\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(\"first\", \"second\", sep = \" \") # <1>\npaste(\"first\", \"second\", collapse = \" \")\npaste(c(\"first\", \"second\"), sep = \" \") # sep only works w/ 2 objects passed in\npaste(c(\"first\", \"second\"), collapse = \" \") # collapse works on vectors\n\npaste(c(\"a\", \"b\", \"c\", \"d\"), \n      c(\"first\", \"second\", \"third\", \"fourth\"), \n      sep = \"-\", collapse = \" \")\n# sep is used to collapse parameters, then collapse is used to collapse vectors\n\npaste0(c(\"a\", \"b\", \"c\"))\npaste0(\"a\", \"b\", \"c\") # equivalent to paste(..., sep = \"\")\n## [1] \"first second\"\n## [1] \"first second\"\n## [1] \"first\"  \"second\"\n## [1] \"first second\"\n## [1] \"a-first b-second c-third d-fourth\"\n## [1] \"a\" \"b\" \"c\"\n## [1] \"abc\"\n```\n:::\n\nYou don't need to understand the details of this code at this point in the class, but it is useful to know how to combine strings in both languages.\n\n:::\n\n:::\n\n\n## Logical Operators {#sec-logical-ops}\n\nLogical variables can be combined through the use of logical operators in much the same way that numerical variables are combined through mathematical operators.\n\nThere are specific **logical operators** which are used to aggregate and combine multiple logical variables: the primary logical operators are `and`, `or`, and `not` [^xor].\n\n[^xor]: A fourth commonly used logical operator is **exclusive or** (`xor`). `xor` is True if only one of the two conditions is True, but False if both are True. `xor` is not a basic boolean operator, as it can be written as a combination of other operators: `A xor B = (A or B) and not(A and B)`.\n\nIn **pseudocode**, which is human-readable logic structured like computer code but without the syntax, we usually write these out in all caps. \n\n- (X AND Y) requires that both X and Y are true.\n- (X OR Y) requires that one of X or Y is true.\n- (NOT X) is true if X is false, and false if X is true. Sometimes called **negation**.\n- (X XOR Y) requires that one (and only one) of X or Y is true. Sometimes called **exclusive or**.\n\n::: {.callout-tip collapse=true}\n\n### Truth Tables: Useful Tools for Understanding Logical Expressions\n\nWhen constructing a logical expression that combines Boolean variables, it can be helpful to build a **truth table** that lists all possible inputs on the left and the output of the operator on the right. \nA truth table demonstrating the logical operators `and`, `or`, `not` and `xor` is provided in @tbl-truth-general.\n\n\na | b | a `and` b | a `or` b | `not` a | `not` b | a `xor` b\n-- | -- | -- | -- | -- | -- | --\nT | T | T | T | F | F | F\nT | F | F | T | F | T | T\nF | T | F | T | T | F | T \nF | F | F | F | T | T | F\n\n: Truth table for each of the common logical operators. {#tbl-truth-general}\n\n:::\n\nOperation | R | Python\n--- | --- | ---\nand | `&` | `&` or `and`\nor | `|` | `|` or `or`\nnot | `!` | `not`\nxor | `xor()` | `^`\n\n: Logical operators in R and Python. These operators are intended for single values; evaluation of vectors may require different operators. Note the use of `^` for `xor` in Python! {#tbl-log-operators}\n\n\nWhen writing code, we use the logical operators in R and Python shown in @tbl-log-operators.\n\n\n:::: {.callout-warning collapse=true}\n\n### Exploring Logical Operators with R and Python\n\nWe can generate each entry in the truth table using the relevant logical operators in R and python. \n\n::: panel-tabset\n\n#### AND\n\nIn R, `and` comparisons use `&` as the operator.\n\n::: {.cell}\n\n```{.r .cell-code}\n\nTRUE & TRUE\n## [1] TRUE\nTRUE & FALSE\n## [1] FALSE\nFALSE & TRUE\n## [1] FALSE\nFALSE & FALSE\n## [1] FALSE\n```\n:::\n\nIn Python, `and` expressions use `&` as the operator.\n\n::: {.cell}\n\n```{.python .cell-code}\nTrue & True\n## True\nTrue & False\n## False\nFalse & True\n## False\nFalse & False\n## False\n```\n:::\n\nAlternately, in Python, you can also spell out the whole word and use `and` explicitly. \n\n::: {.cell}\n\n```{.python .cell-code}\nTrue and True\n## True\nTrue and False\n## False\nFalse and True\n## False\nFalse and False\n## False\n```\n:::\n\n\n#### OR\n\nIn R, `or` is denoted with `|` (the vertical bar, shift + the button above the enter key on most keyboards). \n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE | TRUE\n## [1] TRUE\nTRUE | FALSE\n## [1] TRUE\nFALSE | TRUE\n## [1] TRUE\nFALSE | FALSE\n## [1] FALSE\n```\n:::\n\nIn Python, `or` expressions use `|` as the operator.\n\n::: {.cell}\n\n```{.python .cell-code}\nTrue | True\n## True\nTrue | False\n## True\nFalse | True\n## True\nFalse | False\n## False\n```\n:::\n\nAlternately, in Python, you can also spell out the whole word and use `or` explicitly. \n\n::: {.cell}\n\n```{.python .cell-code}\nTrue or True\n## True\nTrue or False\n## True\nFalse or True\n## True\nFalse or False\n## False\n```\n:::\n\n\n#### NOT\n\nIn R, negation occurs using the `!` operator.\n\n::: {.cell}\n\n```{.r .cell-code}\n!TRUE\n## [1] FALSE\n!FALSE\n## [1] TRUE\n```\n:::\n\nIn Python, negation occurs using the `not` operator.\n\n::: {.cell}\n\n```{.python .cell-code}\nnot True\n## False\nnot False\n## True\n```\n:::\n\n#### XOR\n\nIn R, exclusive or uses the `xor()` function.\n\n::: {.cell}\n\n```{.r .cell-code}\nxor(TRUE, TRUE)\n## [1] FALSE\nxor(TRUE, FALSE)\n## [1] TRUE\nxor(FALSE, TRUE)\n## [1] TRUE\nxor(FALSE, FALSE)\n## [1] FALSE\n```\n:::\n\nIn Python, exclusive or uses the `^` operator.\n\n::: {.cell}\n\n```{.python .cell-code}\nTrue ^ True\n## False\nTrue ^ False\n## True\nFalse ^ True\n## True\nFalse ^ False\n## False\n```\n:::\n\nNote that this is why the exponentiation operator in Python is `**` instead of `^`. \nUsing `^` may produce errors (TypeError: unsupported operand type(s)) or may produce unexpected results with no warning at all, as in the following example. \n\n::: {.cell}\n\n```{.python .cell-code}\n3^4\n## 7\n```\n:::\n\n:::\n\n::::\n\n### Order of Operations\n\nJust as with mathematical operators, there is an order of operations to logical operators. \n\nPrecedence order: (top is evaluated first)\n\n- NOT \n- AND\n- OR\n\n\n::: panel-tabset\n\n#### R\n\n::: {.cell}\n\n```{.r .cell-code}\na1 <- TRUE\nb1 <- FALSE\nc1 <- FALSE\n\na1 | b1 & c1 # AND takes precedence\n## [1] TRUE\na1 | (b1 & c1) # same as above, with parentheses\n## [1] TRUE\n(a1 | b1) & c1 # force OR to be first using parentheses\n## [1] FALSE\n```\n:::\n\n#### Python\n\n::: {.cell}\n\n```{.python .cell-code}\na1 = True\nb1 = False\nc1 = False\n\na1 or b1 and c1 # AND takes precedence\n## True\na1 or (b1 and c1) # same as above, with parentheses\n## True\n(a1 or b1) and c1 # force OR to be first using parentheses\n## False\n```\n:::\n\n:::\n\n\n### De Morgan's Laws\n\n[De Morgan's Laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws) are a set of rules for how to combine logical statements, similar to distributive laws in numerical operations. You can represent them in a number of ways:\n\n-   NOT(A or B) is equivalent to NOT(A) and NOT(B)\n-   NOT(A and B) is equivalent to NOT(A) or NOT(B)\n\n::: {.callout-tip collapse=true}\n\n#### Visual Representation of DeMorgan's Laws\n\nWe can also represent De Morgan's Laws visually using Venn Diagrams.\n\n![Venn Diagram of Set A and Set B](../images/other/SetA and SetB.png)\n\nWe will use the convention that ![Shaded regions are TRUE, unshaded regions are FALSE](../images/other/TrueFalse.png).\n\n::: {.callout collapse=true}\n##### DeMorgan's First Law\n\n![A venn diagram illustration of De Morgan's laws showing that the region that is outside of the union of A OR B (aka NOT (A OR B)) is the same as the region that is outside of (NOT A) and (NOT B)](../images/other/DeMorgan1.png)\n\n::: panel-tabset\n\n###### R\n\n::: {.cell}\n\n```{.r .cell-code}\n!(TRUE | TRUE)\n## [1] FALSE\n!(TRUE | FALSE)\n## [1] FALSE\n!(FALSE | TRUE)\n## [1] FALSE\n!(FALSE | FALSE)\n## [1] TRUE\n\n!TRUE & !TRUE\n## [1] FALSE\n!TRUE & !FALSE\n## [1] FALSE\n!FALSE & !TRUE\n## [1] FALSE\n!FALSE & !FALSE\n## [1] TRUE\n```\n:::\n\n###### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nnot(True or True)\n## False\nnot(True or False)\n## False\nnot(False or True)\n## False\nnot(False or False)\n## True\n\nnot(True) and not(True)\n## False\nnot(True) and not(False)\n## False\nnot(False) and not(True)\n## False\nnot(False) and not(False)\n## True\n```\n:::\n\n:::\n\n:::\n\n\n::: {.callout collapse=true}\n\n##### DeMorgan's Second Law\n\n![A venn diagram illustration of De Morgan's laws showing that the region that is outside of the union of A AND B (aka NOT (A AND B)) is the same as the region that is outside of (NOT A) OR (NOT B)](../images/other/DeMorgan2.png)\n\n::: panel-tabset\n\n###### R\n\n::: {.cell}\n\n```{.r .cell-code}\n!(TRUE & TRUE)\n## [1] FALSE\n!(TRUE & FALSE)\n## [1] TRUE\n!(FALSE & TRUE)\n## [1] TRUE\n!(FALSE & FALSE)\n## [1] TRUE\n\n!TRUE | !TRUE\n## [1] FALSE\n!TRUE | !FALSE\n## [1] TRUE\n!FALSE | !TRUE\n## [1] TRUE\n!FALSE | !FALSE\n## [1] TRUE\n```\n:::\n\n###### Python\n::: {.cell}\n\n```{.python .cell-code}\nnot(True and True)\n## False\nnot(True and False)\n## True\nnot(False and True)\n## True\nnot(False and False)\n## True\n\nnot(True) or not(True)\n## False\nnot(True) or not(False)\n## True\nnot(False) or not(True)\n## True\nnot(False) or not(False)\n## True\n```\n:::\n\n:::\n\n:::\n\n:::\n\n## Using Functions\n\n**Functions** are sets of instructions that take **arguments** and **return** values.\nStrictly speaking, mathematical operators (like those above) are a special type of functions.\n\nWe're not going to talk about how to create our own functions just yet.\nInstead, in this chapter, let's figure out how to *use* functions.\n\n::: callout-warning\n\n### Cheat Sheets!\n\nIt may be helpful at this point to print out the [R reference card](../files/Short-refcard.pdf)[^02-prog-functions-1] and the [Python reference card.](../files/Python3_reference_cheat_sheet.pdf)[^02-prog-functions-2] \nThese cheat sheets contain useful functions for a variety of tasks in each language.\n:::\n\n[^02-prog-functions-1]: From https://cran.r-project.org/doc/contrib/Short-refcard.pdf\n\n[^02-prog-functions-2]: From http://sixthresearcher.com/wp-content/uploads/2016/12/Python3_reference_cheat_sheet.pdf\n\n\n### Function Vocabulary\n\nSuppose I have a function called `add(x, y)` which takes two numbers and adds them together.\n\nIn this example, `add` is the function name, and `x` and `y` are **parameters**: placeholder names for information to be passed into the function.\nNot all functions have named parameters, but it is common for named parameters to provide some indication of what information is supposed to go in that spot.\n\nWhen I call the function -- that is, I use it to add two numbers together, I have to pass in **arguments**.\nArguments are values which are assigned to parameters in the function and affect the result. \nThis is pretty technical and a bit nit-picky, but it's good to see information multiple times - we'll revisit functions in @sec-functions. \n\nThe **function call** would be `add(x = 3, y = 2)`, where 3 and 2 are the arguments.\nThe function call would be evaluated and would **return** 5 as the answer (assuming that `add` does what it says it does). \n\n::: {.callout-note collapse=true}\n\n### Function Vocabulary in Help Files\n\nLet's see these words in a more concrete setting. \n\n![Small excerpt from the R reference card, showing the `which.max` and `which.min` functions](../images/gen-prog/function-vocab.png){fig-alt=\"An image which has the heading 'Data selection and manipulation', and below that has the text 'which.max(x) returns the index of the greatest element of x' and 'which.min(x) returns the index of the smallest element of x'.\"}\n\n- `which.max` and `which.min` are the function names\n- `x` is the parameter\n\nWhen I type `which.max(x = c(2:10))` into the R console and hit Enter, \n- `c(2:10) = c(2, 3, 4, 5, 6, 7, 8, 9, 10)` is the argument\n- inside `which.max`, this argument has the name `x` (mostly helpful for debugging)\n- `which.max` will return 9, which is the index of `x` with the largest value (10)\n\n:::\n\n\n**Methods** are a special type of function that operate on a specific data type.\nIn Python, methods are applied using the syntax `variable.method_name()`.\nSo, you can get the length of a string variable `my_string` using `my_string.length()`.\n\nR has methods too, but they are invoked differently.\nIn R, you would get the length of a string variable using `length(my_string)`.\n\nRight now, it is not really necessary to know too much more about functions than this: you can invoke a function by passing in arguments, and the function will do a task and return the value.\n\n::: callout-tip\n\n### Your Turn {.unnumbered .tryitout}\n\n::: panel-tabset\n\n#### Problem\n\nTry out some of the functions mentioned on the R and Python cheatsheets.\n\nCan you figure out how to define a list or vector of numbers?\nIf so, can you use a function to calculate the maximum value?\n\nCan you find the R functions that will allow you to repeat a string variable multiple times or concatenate two strings?\nCan you do this task in Python?\n\n#### R Solution\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a vector of numbers\nx <- c(1, 2, 3, 4, 5)\n\n# Calculate the maximum\nmax(x)\n## [1] 5\n\n# function to repeat a variable multiple times\nrep(\"test\", 3)\n## [1] \"test\" \"test\" \"test\"\n# Concatenate strings, using \"ing... \" as the separator\npaste(rep(\"test\", 3), collapse = \"ing... \")\n## [1] \"testing... testing... test\"\n```\n:::\n\n#### Python Solution\n\n::: {.cell}\n\n```{.python .cell-code}\n# Define a list of numbers\nx = [1, 2, 3, 4, 5]\n\n# Calculate the maximum\nmax(x)\n## 5\n\n# Repeat a string multiple times\nx = (\"test\", )*3 # String multiplication \n                 # have to use a tuple () to get separate items\n# Then use 'yyy'.join(x) to paste items of x together with yyy as separators\n'ing... '.join(x)\n## 'testing... testing... test'\n```\n:::\n\n:::\n\n:::\n\n## Using R and Python as Overpowered Calculators\n\nNow that you're familiar with how to use functions, if not how to define them, you are capable of using R or python as a very fancy calculator.\nObviously, both languages can do many more interesting things, which we'll get to, but let's see if we can make R and Python do some very basic stuff that hopefully isn't too foreign to you.\n\n::: callout-caution\n\n### Example: Triangle Side Length\n\n![A right triangle with sides a, b, and hypotenuse c labeled.](../images/gen-prog/right-triangle.png)\n\nConsider this triangle.\nI've measured the sides in an image editor and determined that $a = 212$ pixels, $b = 345$ pixels, and $c = 406$ pixels.\nI suspect, however, that my measurements aren't quite right - for one thing, I tried to measure in the center of the line, but it wasn't as easy to do that well on the diagonal.\n\nLet's assume that my measurements for $a$ and $b$ are accurate and calculate how far off my estimate was for side $c$.\n\n::: panel-tabset\n\n#### R\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define variables for the 3 sides of the triangle\na <- 212\nb <- 345\nc_meas <- 406\nc_actual <- sqrt(a^2 + b^2)\n\n# Calculate difference between measured and actual\n# relative to actual \n# and make it a percentage\npct_error <- (c_meas - c_actual)/c_actual * 100\npct_error\n## [1] 0.2640307\n```\n:::\n\n#### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n# To get the sqrt function, we have to import the math package\nimport math\n\n# Define variables for the 3 sides of the triangle\na = 212\nb = 345\nc_meas = 406\nc_actual = math.sqrt(a**2 + b**2)\n\n# Calculate difference between measured and actual\n# relative to actual \n# and make it a percentage\npct_error = (c_meas - c_actual)/c_actual * 100\npct_error\n## 0.264030681414134\n```\n:::\n\n:::\n\nInteresting, I wasn't as inaccurate as I thought!\n\n:::\n\n\n::: callout-tip\n\n### Your Turn\n\nOf course, if you remember trigonometry, we don't have to work with right triangles.\nLet's see if we can use trigonometric functions to do the same task with an oblique triangle.\n\n::: panel-tabset\n\n#### Problem\n\nJust in case you've forgotten your Trig, the Law of Cosines says that $$c^2 = a^2 + b^2 - 2 a b \\cos(C),$$ where $C$ is the angle between sides $a$ and $b$.\n\n![An oblique triangle with sides labeled a, b, and c, and angles labeled as A, B, C with capital letter opposite the lowercase side.](../images/gen-prog/not-right-triangle.png)\n\nI measure side $a = 291$ pixels, side $b = 414$ pixels, and the angle between $a$ and $b$ to be $67.6^\\circ$.\nWhat will I likely get for the length of side $c$ in pixels?\n\nRemember to check whether R and python compute trig functions using radians or degrees!\nAs a reminder, $\\pi$ radians = $180^\\circ$.\n\n#### R solution\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define variables for the 3 sides of the triangle\na <- 291\nb <- 414\nc_angle <- 67.6\nc_actual <- sqrt(a^2 + b^2 - 2*a*b*cos(c_angle/180*pi))\nc_actual\n## [1] 405.2886\n```\n:::\n\nI measured the length of side $c$ as 407 pixels.\n\n#### Python solution\n\n::: {.cell}\n\n```{.python .cell-code}\n# To get the sqrt and cos functions, we have to import the math package\nimport math\n\n# Define variables for the 3 sides of the triangle\na = 291\nb = 414\nc_angle = 67.6\nc_actual = math.sqrt(a**2 + b**2 - 2*a*b*math.cos(c_angle/180*math.pi))\nc_actual\n## 405.28860699402117\n```\n:::\n\nI measured the length of side $c$ as 407 pixels.\n\n:::\n\n:::\n\n\nCongratulations, if you used a TI-84 in high school to do this sort of stuff, you're now just about as proficient with `R` and `python` as you were with that!\n\n## Libraries\n\nBoth R and python have a very robust system for extending the language with user-written **packages**.\nThese packages will give you access to features that aren't present in the base language, including new statistical methods, all sorts of plotting and visualization libraries, ways of interacting with data that are **way** more convenient than the default base language methods, and more.\n\n::: {.callout-note collapse=true}\n### Do you need to use a new package?\n\nThere are tons of considerations to think about when using a new package, like how well it's maintained, how many dependencies it has, and whether the developers of the package prioritize backwards-compatibility.\n\nWith each package you add, your project becomes more complex. \nOn the other hand, with each package you add, you should be able to do more things, and hopefully, you'll be able to leverage code from other developers to accomplish more complex tasks.\n\nThere's a critical balance between complexity and trying not to reinvent the wheel. \nAs you go through this book, you may want to consider different packages in light of this complexity cost/benefit analysis.\n\n:::\n\n\nBefore we talk about how to install packages, we need to step back and think a little bit about the pros and cons of different ways of managing packages, because the most common R and python setups use very different approaches.\n\n### Environment management\n\nA computing environment is a collection of packages (and corresponding functions) that are available to be used. \n\nR and python use very different environment management strategies.\nIn R, packages are stored in a central folder on your computer - by default, all projects will use the same set of packages.\nIn Python, packages should be stored in project-specific environments. There are many different ways to manage python environments.\n\nYour task is to choose one. \n\n::: {.callout-note collapse=true}\n\n#### Why environments?\n\nImagine that you're an accomplished programmer, and you are juggling multiple different projects.\nEach project uses some of the same packages, but some different packages as well.\nYou open up a project that you haven't run in a year, and you find out that one of the packages you've updated more recently breaks a bunch of code you wrote a year ago, because the functions in the package have been renamed.\n\nWhat could prevent this from happening?\n\nOne way to solve this problem is to store the packages used in each project inside the project directory, in what we might call a project environment.\nThis will keep each project isolated from the others, so that if you update a package in one project, it doesn't affect any other project.\n\nHowever, this approach results in a lot of duplication: for one thing, you have copies of each package hanging around in every folder on your computer.\nThat's not storage efficient, but it does keep your code from breaking as frequently.\n\nTypically, Python programmers prefer the first approach (project-specific **virtual environments**), and R programmers default to the second approach (installing packages at the **user** or **system** level).\n\nThis is one of the things that can make starting to learn python so difficult - it can be hard to make sure you're using the right environment.\nIt doesn't help that there are several different environment management systems in python - `virtualenv`, `pipenv`, and `conda` are the main options.\n\n:::\n\n\n\n#### Python environments\n\n::: {.callout-tip}\n\n##### Python Environments for the Decision Fatigued\n\nIf you don't care about the nuances of which python environment management option you should use, I recommend following the `venv` instructions for Python below. \n\n:::\n\n::: {.callout-note collapse=true}\n\n##### Deciding on an Environment\n\n`conda` and `virtualenv` (`venv`) are both virtual environment management systems. \n`conda` is sometimes preferred for scientific computing because it handles the complex dependencies that arise from large packages like `numpy` and `scipi` and `pandas` a bit better than `pip` does alone.\n\nBy default, @sec-setting-up just installs python at the system level.\nIf you want to use [anaconda](https://www.anaconda.com/products/distribution) or [miniconda](https://docs.conda.io/en/latest/miniconda.html) you should go read the documentation for those installers and follow those steps first.\nAlternately, you can install and load the `reticulate` R package and then run `install_miniconda()` - this will install `miniconda` somewhere that RStudio can find it, but it may make using `miniconda` outside of RStudio difficult.\n\n###### Consistency is critical {-}\n\nI *highly* recommend that you pick one of these options and use that consistently, rather than trying the advantages and disadvantages of each option in different projects.\nHere is a webcomic to serve as a cautionary tale if you do not heed this warning.\n\n[![Python Environment, by Randall Munroe of [xkcd](https://xkcd.com/1987/). CC-By-NC-2.5The Python environmental protection agency wants to seal it in a cement chamber, with pictorial messages to future civilizations warning them about the danger of using sudo to install random Python packages.](../images/gen-prog/python_environment.png){fig-alt=\"The Python environmental protection agency wants to seal it in a cement chamber, with pictorial messages to future civilizations warning them about the danger of using sudo to install random Python packages.\"}](https://xkcd.com/1987/)\n\n::: panel-tabset\n\n###### venv (System console)\n\nIn your system terminal, navigate to your project directory.\nItems within `< >` (as well as the <> characters) are intended to be replaced with values specific to your situation.\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd <project-directory>\npip3 install virtualenv # install virtual environments\n\n# Create a virtual environment\nvirtualenv <env-name>\n\n# Activate your virtual environment\nsource <env-name>/bin/activate\n\n# Install packages\npip install <pkg1> <pkg2> <pkg3>\n```\n:::\n\nThen, in RStudio, you will want to run the following lines in the R terminal:\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"reticulate\")\nlibrary(reticulate)\n\n# tell R/Rstudio what python to use\nSys.setenv(RETICULATE_PYTHON = \"<env-name>/bin/python\") \n```\n:::\n\nYou can make this step permanent by modifying the `.Rprofile` file in your project directory and adding the `Sys.setenv()` line to that file.\n\nRestart your R session before you start trying to work in python.\n\n###### venv (RStudio)\n\nOpen your RStudio project.\nIn your R terminal, run the following lines:\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"reticulate\")\nlibrary(reticulate)\nvirtualenv_create(envname = \"<env-name>\",\n                  packages = c(\"<pkg1>\", \"<pkg2>\", \"<pkg3>\"))\n\n# tell R/Rstudio what python to use\nSys.setenv(RETICULATE_PYTHON = \"<env-name>/bin/python\") \n\n# Activate your virtual environment\nuse_virtualenv(\"<env-name>\")\n\n# Check that the correct python instance is being used\npy_config()\n\n# Check that packages are installed in your virtual env\ngrep(pattern = \"<pkg1>|<pkg2>|<pkg3>\",\n     x = as.character(py_list_packages(envname = \"<env-name>\")$package))\n```\n:::\n\nRestart your R session before you start trying to work in python.\n\n###### conda (System console)\n\nThese steps constructed from @blackwoodHowUsePython2021. \nYou must have conda installed for these instructions to work!\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd <project-directory>\n# Create conda environment and install specific python version and packages \nconda create --prefix ./<env-name> python=<python-version> <pkg1> <pkg2> <pkg3> \n\n# Activate your virtual environment\nconda activate ./<env-name>\n```\n:::\n\nThen, in RStudio, you will want to run the following lines in the R terminal:\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"reticulate\")\nlibrary(reticulate)\n\n# tell R/Rstudio what python to use\nSys.setenv(RETICULATE_PYTHON = \"./<env-name>/bin/python\") \n```\n:::\n\nYou can make this step permanent by modifying the `.Rprofile` file in your project directory and adding the `Sys.setenv()` line to that file.\n\nRestart your R session before you start trying to work in python.\n\n###### conda (RStudio)\n\nOpen your RStudio project.\nIn your R terminal, run the following lines:\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"reticulate\")\nlibrary(reticulate)\nconda_create(envname = \"<env-name>\",\n             packages = c(\"<pkg1>\", \"<pkg2>\", \"<pkg3>\"))\n\n# tell R/Rstudio what python to use\nSys.setenv(RETICULATE_PYTHON = \"<env-name>/bin/python\") \n\n# Activate your virtual environment\nuse_condaenv(\"<env-name>\")\n\n# Check that the correct python instance is being used\npy_config()\n\n# Check that packages are installed in your virtual env\ngrep(pattern = \"<pkg1>|<pkg2>|<pkg3>\",\n     x = as.character(py_list_packages(envname = \"<env-name>\")$package))\n```\n:::\n\nRestart your R session before you start trying to work in python.\n\n###### System\n\nYou can install all python packages at the user/system level using `pip`.\nThis has the previously mentioned disadvantages, but has the major advantage of being very simple.\nTo install a python package `<package name>` using pip, run this command\n\n::: {.cell}\n\n```{.bash .cell-code}\npip3 install <package name>\n```\n:::\n\nSome computers may prefer that you use `pip` instead of `pip3` - figure out which one your computer requires and use that.\n\nSome operating systems (Linux) restrict the ability to install packages system-wide - I recommend creating a virtual environment or conda environment instead if you are using Linux to prevent constantly having to override warnings that exist for a reason. \n\n:::\n:::\n\n::: {.callout-note collapse=true}\n\n#### R environments (advanced)\n\nSome R programmers have adopted the python philosophy of project-specific package management, using an R package called `renv` [@usheyIntroductionRenv2023].\n\n`renv` documentation can be found [here](https://rstudio.github.io/renv/articles/renv.html) if you wish to try it out. I find that it is most useful for projects where package updates may break things - e.g. projects which run on shared systems or which are intended to work for a long period of time without maintenance. \n\nIf you want to use `renv`, you can do that by following these steps:\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"renv\")\n\nlibrary(renv)\n\n# Activate renv for a project\nrenv::activate()\n\n# this will install from github or CRAN\nrenv::install(c(\"pkg1\", \"pkg2\", \"githubuser/pkg3\")) \n```\n:::\n\nI use `renv` for this textbook, because if a package update breaks things, I need to systematically check *all* the code chunks in the textbook to make sure they all work. I don't want to do that every time someone fixes a minor bug, so I don't update the packages the textbook uses more than once a semester (normally). \n\n:::\n\n### Package repositories\n\nBoth R and Python have package systems, though generally, R is a bit more straightforward to deal with than python (in my opinion). \nPython's extra environment management systems sometimes come with additional package repositories, and it can be hard to identify the differences between them. \nBy contrast, all R packages seem to go through the same basic installation process and are just hosted in different places.\nThis is largely a result of the difference between R and Python's environment management strategies. \n\n\n|        | Formally Published                                                                 | Informally Published/Beta                                                                                                     |\n|--------|------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|\n| R      | [CRAN](https://cran.r-project.org/), [Bioconductor](https://www.bioconductor.org/) | github and other version control. See the [remotes package documentation](https://remotes.r-lib.org/) for all of the options. |\n| Python | [PyPi](https://pypi.org/)                                                          | github and other version control systems                                                                                      |\n\n### Package Installation\n\n#### Installing packages in Python {#sec-py-pkg-install}\n\nMany of the instructions here are modified from @makarovUsePythonRstudio2022.\n\nWhichever method (system, venv, conda) you use to manage your Python environment, when you go to install a new package, you have a few different options for how to do so. \n\n::: panel-tabset\n\n##### System console\n\nIn python, you will typically want to install packages using a system terminal.\n\n1. Make sure your virtual environment/conda environment is activated \n2. Installation commands:\n    - If you are using venv, `pip3 install <package name>` should install your package. \n    - If you are using conda, `conda install <package name>` is preferable, and if that doesn't work, then try using `pip3 install <package name>`.\n\n::: {.cell}\n\n```{.bash .cell-code}\n# If you're using virtualenv\npip install <pkg1>\n\n# If you're using conda, try this first\nconda install <pkg1>\n# If that fails, try pip\n```\n:::\n\n\n##### RStudio\n\nNote: This does NOT work to install python packages system-wide.\n\n1. Make sure R is using the correct python installation\n2. In the R terminal, run `reticulate::py_install(\"package name\")`\n\n##### IPython Magic\n\nThis is less elegant, but nearly foolproof as long as RStudio knows where to find python.\n\n1. At the top of the chunk, write `%pip install <package name>`\n2. Run this code (Cmd/Ctrl + Enter)\n3. **Comment the code out**, so that you aren't reinstalling the package every time you run the chunk. \n\n::: {.cell}\n\n```{.python .cell-code}\n%pip install <pkg1>\n```\n:::\n\nA slightly less elegant but more robust way to do this is to use  the sys package. \nLoading the `sys` package ensures that you're using the version of python that your file will be compiled with to install the package.\n\n::: {.cell}\n\n```{.python .cell-code}\nimport sys\n# For pip installation\n!{sys.executable} -m pip install <pkg1>\n\n# For conda installation\n!{sys.executable} -m conda install <pkg1>\n```\n:::\n\nOnce you've installed the package on your machine, you can comment these lines out so that they don't run every time - this makes it a bit easier when you try to run old code on a new machine, as you can just uncomment those lines.\n\n:::\n\n#### Installing packages in R\n\nPackage management in R is a bit simpler than package management in python.\n\nIn almost every case, you can install packages from CRAN with `install.packages(\"package name\")`. If your package is not on CRAN, and is instead on e.g. GitHub, you may have to use the `remotes` package to install it with `remotes::install_github(\"user/repo\")`\n\n::: {.cell}\n\n```{.r .cell-code}\n# CRAN packages\ninstall.packages(\"<pkg1>\")\n\n# Github packages\nremotes::install_github(\"username/reponame\")\n```\n:::\n\n### Loading Packages\n\nOnce you have the package installed, you need to load the package into memory so that you can use the functions and data contained within.\nAgain, R and python differ slightly in how programmers conventionally handle this process.\n\n-   R: Load all of the package's functions, overwriting already loaded functions if necessary\n-   Python: Load all of the package's functions, contained within an object that is either the package name or a shortened alias.\n\nNow, both R and python can load packages in either way, so this isn't an either/or thing - it's about knowing what the conventions of the language are, and then deciding whether or not it is appropriate to follow those conventions in your project.\n\n::: callout-demo\n\n#### Import the whole package and all functions\n\nTo demonstrate this approach, let's create a simple plot with a plotting library (`ggplot2` in R, `plotnine` in Python).\n\n::: panel-tabset\n\n##### R\n\nAll of the other packages in this plot are present by default in any new R environment.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\n# This code lists all the functions available to be called\npkgs <- search()\npkgs <- pkgs[grep(\"package:\",pkgs)]\n# get all the functions in each package that is loaded\nall_fns <- lapply(pkgs, function(x) as.character(lsf.str(x)))\n# create a data frame\npkg_fns <- data.frame(pkg = rep(pkgs, sapply(all_fns, length)), \n                      fn = unlist(all_fns))\npkg_fns$pkg <- gsub(\"package:\", \"\", pkg_fns$pkg)\n\n\nggplot(pkg_fns, aes(x = pkg, y = after_stat(count), fill = pkg)) + \n  geom_bar() + theme(legend.position = \"none\") + \n  ylab(\"# Functions\") + xlab(\"Package\")\n```\n\n::: {.cell-output-display}\n![](02-prog-functions_files/figure-html/unnamed-chunk-42-1.png){width=2100}\n:::\n:::\n\n##### Python\n\nIn python, there are built-in functions (`builtins`); I have then loaded the packages I typically use for plotting (`seaborn`, `seaborn.objects`, `matplotlib`), manipulating data (`pandas`, `numpy`), and standard `math` and `statistics` libraries. \n\n::: {.cell}\n\n```{.python .cell-code}\nimport seaborn as sns\nimport seaborn.objects as so\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\nimport statistics\nfrom inspect import getmembers, isfunction\n\npkgs = pd.DataFrame({\"name\": [\n  \"builtins\", \n  \"math\", \"statistics\", \n  \"seaborn\", \"seaborn\", \"matplotlib\", \n  \"pandas\", \"numpy\"\n  ], \n  \"abbrev\": [\n    \"builtins\", \n    \"math\", \"statistics\",\n    sns, so, plt, \n    pd, np]\n    })\n\npkgs[\"functions\"] = pkgs['abbrev'].apply(lambda x: dir(x), by_row=\"compat\")\n\npkgs = pkgs.explode('functions')\n\n# Filter out functions that start with __\npkgs = pkgs[~pkgs.functions.str.contains(\"__\")]\n\nplot = sns.countplot(pkgs, x = \"name\", hue = \"name\")\nplot.set_title(\"Number of Functions in Common Python Packages\")\nplot.set_xlabel(\"Package\")\nplot.set_ylabel(\"# Functions\")\nplt.show()\n```\n\n::: {.cell-output-display}\n![](02-prog-functions_files/figure-html/unnamed-chunk-43-1.png){width=672}\n:::\n:::\n\n:::\n\n:::\n\n::: callout-demo\n\n#### Use functions from the package without loading everything\n\n::: panel-tabset\n\n##### R\n\n::: {.cell}\n\n```{.r .cell-code}\n# This code lists all the functions available to be called\npkgs <- search()\npkgs <- pkgs[grep(\"package:\",pkgs)]\n# get all the functions in each package that is loaded\nall_fns <- lapply(pkgs, function(x) as.character(lsf.str(x)))\n# create a data frame\npkg_fns <- data.frame(pkg = rep(pkgs, sapply(all_fns, length)), \n                      fn = unlist(all_fns))\npkg_fns$pkg <- gsub(\"package:\", \"\", pkg_fns$pkg)\n\nggplot2::ggplot(pkg_fns, ggplot2::aes(x = pkg, fill = pkg)) + \n  ggplot2::geom_bar(y = ggplot2::after_stat(count)) + \n  ggplot2::theme(legend.position = \"none\") + \n  ggplot2::xlab(\"Package\") + ggplot2::ylab(\"# Functions\")\n## Error: object 'count' not found\n```\n:::\n\n##### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nimport plotnine as p9\npkg_fns = r.pkg_fns\n\n(\n  p9.ggplot(pkg_fns, p9.aes(x = \"pkg\", fill = \"pkg\")) + \n  p9.geom_bar(y = p9.after_stat(\"count\")) + \n  p9.theme(legend_position = \"none\") + \n  p9.xlab(\"Package\") + p9.ylab(\"# Functions\")\n)\n## <plotnine.ggplot.ggplot object at 0x7f2841829a10>\n```\n:::\n\n:::\n\n:::\n\nIn python, you can use `import package as nickname`, or you can just use `import package` and reference the package name directly.\nThere are some packages which have typical aliases, and it's best to use those so that you can look things up and not get too confused.\n\n| Package             | Common Alias | Explanation                                                                                    |\n|---------------------|--------------|------------------------------------------------------------------------------------------------|\n| pandas              | pd           | shorter                                                                                        |\n| numpy               | np           | shorter                                                                                        |\n| seaborn             | sns          | This is a reference to Samuel Norman Seaborn, played by Rob Lowe, in the TV show The West Wing |\n| plotnine            | p9           |                                                                                                |\n| BeautifulSoup (bs4) | bs           | BeautifulSoup is a reference to Alice in Wonderland. The package name in PyPi is actually bs4. |\n\n: Common Python package aliases\n\n## Pipes\n\nPipes are useful items for moving things from one place to another.\nIn programming, and in particular, in data programming, pipes are operators that let us move data around.\nIn R, we have two primary pipes that are similar (you may see both used if you google for code online).\nAny R version after 4.1 has a built-in pipe, `|>`; the `tidyverse` libraries use a pipe from the `magrittr` package, `%>%`.\n\nFor right now, it's ok to think of the two pipes as essentially the same (but you can read about the differences @machlisUseNewPipe2021).\n\nFundamentally, a pipe allows you to take a function `b()` and apply it to `x`, like `b(x)`, but write it as `x |> b()` or `x %>% b()`.\nThis is particularly useful in cases where there are multiple sequential analysis steps, because where in regular notation you have to read the functions from the inside out to understand the sequential steps, with pipes, you have a clear step-by-step list of the order of operations.\n\nIn Python, there is a `pipe` function in the Pandas library that works using `.pipe(function)` notation @shadowtalkerAnswerFunctionalPipes2015.\nFrom what I've seen reading code online, however, pipes are less commonly used in Python code than they are in R code.\nThat's ok - languages have different conventions, and it is usually best to adopt the convention of the language you're working in so that your code can be read, run, and maintained by others more easily.\n\n::: callout-tip\n\n### Try it out\n\n::: panel-tabset\n\n#### Problem\n\nGenerate 100 draws from a standard normal distribution and calculate the mean.\n\nIn R, simulate from a normal distribution with `rnorm`.\nIn python, use `np.random.normal` - you'll have to `import numpy as np` first.\n\nUse 3 approaches: 1.\nStore the data in a variable, then calculate the mean of the variable 2.\nCalculate the mean of the data by nesting the two functions (e.g. `mean(generate_normal(100))` in pseudocode) 3.\nCalculate the mean of the data using the pipe (e.g. `generate_normal(100) |> mean()`)\n\n**Consider**: What are the advantages and disadvantages of each approach?\nWould your answer change if there were more steps/functions required to get to the right answer?\n\n#### R solution\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- rnorm(100)\nmean(data)\n## [1] 0.01380002\n\nmean(rnorm(100))\n## [1] -8.162721e-05\n\nlibrary(magrittr) # load the pipe %>%\n\nrnorm(100) %>%\n  mean()\n## [1] -0.1199999\n\nrnorm(100) |> mean()\n## [1] -0.04524696\n```\n:::\n\n#### Python solution\n\nIn python, task 3 isn't really possible, because of the way Python function chaining works, but task 2 is basically the equivalent.\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nimport pandas as pd\n\nnums = pd.Series(np.random.normal(size = 100))\nnums.mean()\n## np.float64(-0.022860654769474856)\n\nnp.random.normal(size=100).mean()\n## np.float64(-0.08829574339232106)\n```\n:::\n \nThe conclusion here is that it's far easier to not use the pipe in python because the `.function` notation that python uses mimics the step-by-step approach of pipes in R even without using the actual pipe function.\nWhen you use data frames instead of Series, you *might* start using the pipe, but only in some circumstances - with user-defined functions, instead of **methods**.\nMethods are functions that are attached to a data type (technically, a class) and only work if they are defined for that class - for instance, `.mean()` is defined for both Pandas series and numpy arrays.\n\n:::\n\n:::\n\n<!-- ## References  {#sec-using-functions-refs} -->\n",
    "supporting": [
      "02-prog-functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}