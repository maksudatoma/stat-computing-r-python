{
  "hash": "8ed34f8c25f85ee6a826ae11f294ffe2",
  "result": {
    "markdown": "# Using Functions and Libraries {#sec-calculator}\n\nIn addition to variables, **functions** are extremely important in programming. \nFunctions allow you to repeat a series of steps using different information and get the result.\nIn a way, a function is to a variable as a verb is to a noun - functions are a concise way of performing an action. \n\n## {{< fa bullseye >}} Objectives\n\n- Understand how functions are used in R and python\n- Understand how to install packages in R and python\n- Understand how to load packages in R and python\n- Use pipes to restructure code so that it is more readable\n\n\n## Mathematical Operators\nLet's first start with a special class of functions that you're probably familiar with from your math classes - mathematical operators. \n\nHere are a few of the most important ones:\n\n| Operation        | R symbol | Python symbol |\n|------------------|----------|---------------|\n| Addition         | `+`      | `+`           |\n| Subtraction      | `-`      | `-`           |\n| Multiplication   | `*`      | `*`           |\n| Division         | `/`      | `/`           |\n| Integer Division | `%/%`    | `//`          |\n| Modular Division | `%%`     | `%`           |\n| Exponentiation   | `^`      | `**`          |\n\nThese operands are all for scalar operations (operations on a single number) - vectorized versions, such as matrix multiplication, are somewhat more complicated (and different between R and python).\n\n::: callout-caution\n### Example: Integer and Modular Division\n\nInteger division is the whole number answer to A/B, and modular division is the fractional remainder when A/B.\n\nLet's demonstrate with the problem 14/3, which evaluates to 4.6666667 when division is used, but has integer part 4 and remainder 2.\n\n::: panel-tabset\n### R {.unnumbered}\n\n`14 %/% 3` in R would be 4, and `14 %% 3` in R would be 2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n14 %/% 3\n## [1] 4\n14 %% 3\n## [1] 2\n```\n:::\n\n\n### Python {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n14 // 3\n## 4\n14 % 3\n## 2\n```\n:::\n\n:::\n\n:::\n\n## Order of Operations\n\nBoth R and Python operate under the same mathematical rules of precedence that you learned in school. You may have learned the acronym PEMDAS, which stands for Parentheses, Exponents, Multiplication/Division, and Addition/Subtraction. That is, when examining a set of mathematical operations, we evaluate parentheses first, then exponents, and then we do multiplication/division, and finally, we add and subtract.\n\n::: panel-tabset\n### R {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(1+1)^(5-2) \n## [1] 8\n1 + 2^3 * 4 \n## [1] 33\n3*1^3 \n## [1] 3\n```\n:::\n\n\n### Python {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(1+1)**(5-2)\n## 8\n1 + 2**3*4\n## 33\n3*1**3\n## 3\n```\n:::\n\n:::\n\n## Simple String Operations\n\nPython has some additional operators that work on strings. \nIn R, you will have to use functions to perform these operations, as R does not have string operators.\n\n::: callout-demo\n::: panel-tabset\n### Python {.unnumbered}\n\nIn Python, `+` will **concatenate** (stick together) two strings.\nMultiplying a string by an integer will repeat the string the specified number of times.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\"first \" + \"second\"\n## 'first second'\n\"hello \" * 3\n## 'hello hello hello '\n```\n:::\n\n\n### R {.unnumbered}\n\nIn R, to concatenate things, we need to use functions: `paste` or `paste0`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(\"first\", \"second\", sep = \" \")\n## [1] \"first second\"\npaste(\"first\", \"second\", collapse = \" \")\n## [1] \"first second\"\npaste(c(\"first\", \"second\"), sep = \" \") # sep only works w/ 2 objects passed in\n## [1] \"first\"  \"second\"\npaste(c(\"first\", \"second\"), collapse = \" \") # collapse works on vectors\n## [1] \"first second\"\n\npaste(c(\"a\", \"b\", \"c\", \"d\"), \n      c(\"first\", \"second\", \"third\", \"fourth\"), \n      sep = \"-\", collapse = \" \")\n## [1] \"a-first b-second c-third d-fourth\"\n# sep is used to collapse parameters, then collapse is used to collapse vectors\n\npaste0(c(\"a\", \"b\", \"c\"))\n## [1] \"a\" \"b\" \"c\"\npaste0(\"a\", \"b\", \"c\") # equivalent to paste(..., sep = \"\")\n## [1] \"abc\"\n```\n:::\n\n\nYou don't need to understand the details of this code at this point in the class, but it is useful to know how to combine strings in both languages.\n:::\n:::\n\n## Using Functions\n\n**Functions** are sets of instructions that take **arguments** and **return** values. Strictly speaking, mathematical operators (like those above) are a special type of functions -- but we aren't going to get into that now.\n\nWe're also not going to talk about how to create our own functions just yet. Instead, I'm going to show you how to *use* functions.\n\n::: callout-warning\n### Cheat Sheets!\n\nIt may be helpful at this point to print out the [R reference card](../files/Short-refcard.pdf)[^01-prog-intro-3] and the [Python reference card](../files/Python3_reference_cheat_sheet.pdf)[^01-prog-intro-4]. These cheat sheets contain useful functions for a variety of tasks in each language.\n\n:::\n\n[^01-prog-intro-3]: From https://cran.r-project.org/doc/contrib/Short-refcard.pdf\n\n[^01-prog-intro-4]: From http://sixthresearcher.com/wp-content/uploads/2016/12/Python3_reference_cheat_sheet.pdf\n\n**Methods** are a special type of function that operate on a specific variable type. In Python, methods are applied using the syntax `variable.method_name()`. So, you can get the length of a string variable `my_string` using `my_string.length()`.\n\nR has methods too, but they are invoked differently. In R, you would get the length of a string variable using `length(my_string)`.\n\nRight now, it is not really necessary to know too much more about functions than this: you can invoke a function by passing in arguments, and the function will do a task and return the value.\n\n::: callout-tip\n### Your Turn {.unnumbered .tryitout}\n\n::: panel-tabset\n#### Problem\n\nTry out some of the functions mentioned on the R and Python cheatsheets.\n\nCan you figure out how to define a list or vector of numbers? If so, can you use a function to calculate the maximum value?\n\nCan you find the R functions that will allow you to repeat a string variable multiple times or concatenate two strings? Can you do this task in Python?\n\n#### R Solution\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a vector of numbers\nx <- c(1, 2, 3, 4, 5)\n\n# Calculate the maximum\nmax(x)\n## [1] 5\n\n# function to repeat a variable multiple times\nrep(\"test\", 3)\n## [1] \"test\" \"test\" \"test\"\n# Concatenate strings, using \"ing... \" as the separator\npaste(rep(\"test\", 3), collapse = \"ing... \")\n## [1] \"testing... testing... test\"\n```\n:::\n\n\n#### Python Solution\n\n::: {.cell}\n\n```{.python .cell-code}\n# Define a list of numbers\nx = [1, 2, 3, 4, 5]\n\n# Calculate the maximum\nmax(x)\n\n# Repeat a string multiple times\n## 5\nx = (\"test\", )*3 # String multiplication \n                 # have to use a tuple () to get separate items\n# Then use 'yyy'.join(x) to paste items of x together with yyy as separators\n'ing... '.join(x)\n## 'testing... testing... test'\n```\n:::\n\n\n:::\n:::\n\n## Overpowerd Calculators\n\nNow that you're familiar with how to use functions, if not how to define them, you are capable of using R or python as a very fancy calculator. Obviously, both languages can do many more interesting things, which we'll get to, but let's see if we can make R and Python do some very basic stuff that hopefully isn't too foreign to you.\n\n::: callout-caution\n### Example: Triangle Side Length\n\n![A right triangle with sides a, b, and hypotenuse c labeled.](../images/gen-prog/right-triangle.png)\n\nConsider this triangle. I've measured the sides in an image editor and determined that $a = 212$ pixels, $b = 345$ pixels, and $c = 406$ pixels. I suspect, however, that my measurements aren't quite right - for one thing, I tried to measure in the center of the line, but it wasn't easy on the diagonal.\n\nLet's assume that my measurements for $a$ and $b$ are accurate and calculate how far off my estimate was for side $c$.\n\n::: panel-tabset\n#### R\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define variables for the 3 sides of the triangle\na <- 212\nb <- 345\nc_meas <- 406\nc_actual <- sqrt(a^2 + b^2)\n\n# Calculate difference between measured and actual\n# relative to actual \n# and make it a percentage\npct_error <- (c_meas - c_actual)/c_actual * 100\npct_error\n## [1] 0.2640307\n```\n:::\n\n\n#### Python\n\n::: {.cell}\n\n```{.python .cell-code}\n# To get the sqrt function, we have to import the math package\nimport math\n\n# Define variables for the 3 sides of the triangle\na = 212\nb = 345\nc_meas = 406\nc_actual = math.sqrt(a**2 + b**2)\n\n# Calculate difference between measured and actual\n# relative to actual \n# and make it a percentage\npct_error = (c_meas - c_actual)/c_actual * 100\npct_error\n## 0.264030681414134\n```\n:::\n\n:::\n\nInteresting, I wasn't as inaccurate as I thought!\n:::\n\n::: callout-tip\n### Your Turn\n\nOf course, if you remember trigonometry, we don't have to work with right triangles. \nLet's see if we can use trigonometric functions to do the same task with an oblique triangle.\n\n::: panel-tabset\n#### Problem\n\nJust in case you've forgotten your Trig, the Law of Cosines says that $$c^2 = a^2 + b^2 - 2 a b \\cos(C),$$ where $C$ is the angle between sides $a$ and $b$.\n\n![An oblique triangle with sides labeled a, b, and c, and angles labeled as A, B, C with capital letter opposite the lowercase side.](../images/gen-prog/not-right-triangle.png)\n\nI measure side $a = 291$ pixels, side $b = 414$ pixels, and the angle between $a$ and $b$ to be $67.6^\\circ$. What will I likely get for the length of side $c$ in pixels?\n\nRemember to check whether R and python compute trig functions using radians or degrees! As a reminder, $\\pi$ radians = $180^\\circ$.\n\n#### R solution\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define variables for the 3 sides of the triangle\na <- 291\nb <- 414\nc_angle <- 67.6\nc_actual <- sqrt(a^2 + b^2 - 2*a*b*cos(c_angle/180*pi))\nc_actual\n## [1] 405.2886\n```\n:::\n\n\nI measured the length of side $c$ as 407 pixels.\n\n#### Python solution\n\n::: {.cell}\n\n```{.python .cell-code}\n# To get the sqrt and cos functions, we have to import the math package\nimport math\n\n# Define variables for the 3 sides of the triangle\na = 291\nb = 414\nc_angle = 67.6\nc_actual = math.sqrt(a**2 + b**2 - 2*a*b*math.cos(c_angle/180*math.pi))\nc_actual\n## 405.28860699402117\n```\n:::\n\n\nI measured the length of side $c$ as 407 pixels.\n\n:::\n:::\n\nCongratulations, if you used a TI-83 in high school to do this sort of stuff, you're now just about as proficient with R and python as you were with that!\n\n## Pipes {.unnumbered}\n\nPipes are useful items for moving things from one place to another. In programming, and in particular, in data programming, pipes are operators that let us move data around. \nIn R, we have two primary pipes that are similar (you may see both used if you google for code online). \nAny R version after 4.1 has a built-in pipe, `|>`; the `tidyverse` libraries use a pipe from the `magrittr` package, `%>%`.\n\nFor right now, it's ok to think of the two pipes as essentially the same (but you can read about the differences @machlisUseNewPipe2021).\n\nFundamentally, a pipe allows you to take a function `b()` and apply it to `x`, like `b(x)`, but write it as `x |> b()` or `x %>% b()`. \nThis is particularly useful in cases where there are multiple sequential analysis steps, because where in regular notation you have to read the functions from the inside out to understand the sequential steps, with pipes, you have a clear step-by-step list of the order of operations.\n\nIn Python, there is a `pipe` function in the Pandas library that works using `.pipe(function)` notation @shadowtalkerAnswerFunctionalPipes2015. \nFrom what I've seen reading code online, however, pipes are less commonly used in Python code than they are in R code. \nThat's ok - languages have different conventions, and it is usually best to adopt the convention of the language you're working in so that your code can be read, run, and maintained by others more easily.\n\n::: callout-tip\n### Try it out\n::: panel-tabset\n#### Problem\n\nGenerate 100 draws from a standard normal distribution and calculate the mean. \n\nIn R, simulate from a normal distribution with `rnorm`. \nIn python, use `np.random.normal` - you'll have to `import numpy as np` first.\n\n\nUse 3 approaches:\n1. Store the data in a variable, then calculate the mean of the variable\n2. Calculate the mean of the data by nesting the two functions (e.g. `mean(generate_normal(100))` in pseudocode)\n3. Calculate the mean of the data using the pipe (e.g. `generate_normal(100) |> mean()`)\n\n**Consider**: What are the advantages and disadvantages of each approach? Would your answer change if there were more steps/functions required to get to the right answer?\n\n\n#### R solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- rnorm(100)\nmean(data)\n## [1] 0.1823495\n\nmean(rnorm(100))\n## [1] 0.0113624\n\nlibrary(magrittr) # load the pipe %>%\n\nrnorm(100) %>%\n  mean()\n## [1] 0.1448435\n\nrnorm(100) |> mean()\n## [1] 0.06372087\n```\n:::\n\n\n#### Python solution\nIn python, task 3 isn't really possible, because of the way Python function chaining works, but task 2 is basically the equivalent.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nimport pandas as pd\n\nnums = pd.Series(np.random.normal(size = 100))\nnums.mean()\n## -0.05591907762090562\nnp.random.normal(size=100).mean()\n## 0.0815823387803748\n```\n:::\n\n\nThe conclusion here is that it's far easier to not use the pipe in python because the `.function` notation that python uses mimics the step-by-step approach of pipes in R even without using the actual pipe function. \nWhen you use data frames instead of Series, you *might* start using the pipe, but only in some circumstances - with user-defined functions, instead of **methods**. \nMethods are functions that are attached to a data type (technically, a class) and only work if they are defined for that class - for instance, `.mean()` is defined for both Pandas series and numpy arrays.\n\n:::\n:::\n\n## Libraries\n\n\n\n<!-- ## References  {#sec-using-functions-refs} -->\n\n",
    "supporting": [
      "02-prog-functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}