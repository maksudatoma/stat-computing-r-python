{
  "hash": "9404449a5f518be683113f96ae9e6a17",
  "result": {
    "markdown": "# Data Structures {#sec-data-struct}\n<!-- Vectors, Matrices, and Numpy arrays. Logical indexing. -->\n\n<!-- Lego pictures made with https://www.mecabricks.com/en/workshop -->\n\nThis chapter introduces some of the most important structures for storing and working with data: vectors, matrices, lists, and data frames. \n\n## {{< fa bullseye >}} Objectives\n\n- Understand the differences between lists, vectors, data frames, matrices, and arrays in R and python\n- Be able to use location-based indexing in R or python to pull out subsets of a complex data object\n\n\n\n## Data Structures Overview\n\nIn @sec-basic-var-types, we discussed 4 different data types: strings/characters, numeric/double/floats, integers, and logical/booleans. As you might imagine, things are about to get more complicated.\n\nData **structures** are more complex arrangements of information, but they are still (usually) created using the same data types we have previously discussed. \n\n|             | Homogeneous   | Heterogeneous |\n|-------------|---------------|---------------|\n| 1D          | vector        | list          |\n| 2D          | matrix        | data frame    |\n| N-D         | array         |               |\n\n::: callout-warning\nThose of you who have taken programming classes that were more computer science focused will realize that I am leaving out a lot of information about lower-level structures like pointers. \nI'm making a deliberate choice to gloss over most of those details in this chapter, because it's already hard enough to learn 2 languages worth of data structures at a time.\nIn addition, R doesn't have pointers [No Pointers in R, @matloffArtProgrammingTour2011], so leaving out this material in python streamlines teaching both two languages, at the cost of overly simplifying some python concepts. \nIf you want to read more about the Python concepts I'm leaving out, check out @frippAnswerPythonPandas2016.\n:::\n\n\n## Lists\n\nA **list** is a one-dimensional column of heterogeneous data - the things stored in a list can be of different types.\n\n![A lego list: the bricks are all different types and colors, but they are still part of the same data structure.](../images/gen-prog/lego-list.png)\n\n::: panel-tabset\n### R {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(\"a\", 3, FALSE)\nx\n## [[1]]\n## [1] \"a\"\n## \n## [[2]]\n## [1] 3\n## \n## [[3]]\n## [1] FALSE\n```\n:::\n\n\n### Python {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = [\"a\", 3, False]\nx\n## ['a', 3, False]\n```\n:::\n\n:::\n\nThe most important thing to know about lists, for the moment, is how to pull things out of the list. We call that process **indexing**.\n\n### Indexing\n\nEvery element in a list has an **index** (a location, indicated by an integer position)[^05-vectors-1].\n\n[^05-vectors-1]: Throughout this section (and other sections), lego pictures are rendered using https://www.mecabricks.com/en/workshop. It's a pretty nice tool for building stuff online!\n\n::: panel-tabset\n#### R concept {.unnumbered}\n\nIn R, we count from 1.\n\n![An R-indexed lego list, counting from 1 to 5](../images/gen-prog/list-indexing-r.png)\n\n#### R code {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(\"a\", 3, FALSE)\n\nx[1] # This returns a list\n## [[1]]\n## [1] \"a\"\nx[1:2] # This returns multiple elements in the list\n## [[1]]\n## [1] \"a\"\n## \n## [[2]]\n## [1] 3\n\nx[[1]] # This returns the item\n## [1] \"a\"\nx[[1:2]] # This doesn't work - you can only use [[]] with a single index\n## Error in x[[1:2]]: subscript out of bounds\n```\n:::\n\n\nIn R, list indexing with `[]` will return a list with the specified elements.\n\nTo actually retrieve the item in the list, use `[[]]`. The only downside to `[[]]` is that you can only access one thing at a time.\n\n#### Python concept {.unnumbered}\n\nIn Python, we count from 0.\n\n![A python-indexed lego list, counting from 0 to 4](../images/gen-prog/list-indexing-py.png)\n\n#### Python code {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = [\"a\", 3, False]\n\nx[0]\n## 'a'\nx[1]\n## 3\nx[0:2]\n## ['a', 3]\n```\n:::\n\n\nIn Python, we can use single brackets to get an object or a list back out, but we have to know how **slices** work. Essentially, in Python, `0:2` indicates that we want objects 0 and 1, but want to stop at 2 (not including 2). If you use a slice, Python will return a list; if you use a single index, python just returns the value in that location in the list.\n:::\n\nWe'll talk more about indexing as it relates to vectors, but indexing is a general concept that applies to just about any multi-value object.\n\n## Vectors\n\nA **vector** is a one-dimensional column of homogeneous data. \n**Homogeneous** means that every element in a vector has the same data type.\n\nWe can have vectors of any data type and length we want: \n\n![vectors of different data types](../images/gen-prog/lego-set-of-vectors.png){fig-alt=\"A picture of several stacks of lego bricks. First, there is a set of green-hued 1x1 bricks labeled `int`. Next, there is a set of red-hued 1x1 bricks labeled `lgl`, or logical. Then, there is a set of blue-hued 1x2 bricks labeled `float` and finally, a set of 1x3 purple-hued bricks labeled string. Each set of colored bricks has a different length.\"}\n\n\n### Indexing by Location {#sec-indexing}\n\nEach element in a vector has an **index** - an integer telling you what the item's position within the vector is. I'm going to demonstrate indices with the string vector\n\n| R                                                                         | Python                                                                              |\n|----------------------------------|--------------------------------------|\n| 1-indexed language                                                        | 0-indexed language                                                                  |\n| Count elements as 1, 2, 3, 4, ..., N                                      | Count elements as 0, 1, 2, 3, , ..., N-1                                            |\n| ![R lego vector, labeled with numbers 1-12](../images/gen-prog/lego-1x3-vector-R.png) | ![Python lego vector, labeled with numbers 0-11](../images/gen-prog/lego-1x3-vector-python.png) |\n\n::: panel-tabset\n#### R {.unnumbered}\n\nIn R, we create vectors with the `c()` function, which stands for \"concatenate\" - basically, we stick a bunch of objects into a row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndigits_pi <- c(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5)\n\n# Access individual entries\ndigits_pi[1]\n## [1] 3\ndigits_pi[2]\n## [1] 1\ndigits_pi[3]\n## [1] 4\n\n# R is 1-indexed - a list of 11 things goes from 1 to 11\ndigits_pi[0]\n## numeric(0)\ndigits_pi[11]\n## [1] 5\n\n# Print out the vector\ndigits_pi\n##  [1] 3 1 4 1 5 9 2 6 5 3 5\n```\n:::\n\n\n#### Python Vectors {.unnumbered}\n\nIn python, we create vectors using the `array` function in the numpy module. \nTo add a python module, we use the syntax `import <name> as <nickname>`. \nMany modules have conventional (and very short) nicknames - for `numpy`, we will use `np` as the nickname. \nAny functions we reference in the `numpy` module will then be called using `np.fun_name()` so that python knows where to find them.[^05-vectors-2]\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n## Error: ModuleNotFoundError: No module named 'numpy'\ndigits_list = [3,1,4,1,5,9,2,6,5,3,5]\ndigits_pi = np.array(digits_list)\n\n# Access individual entries\n## Error: NameError: name 'np' is not defined\ndigits_pi[0]\n## Error: NameError: name 'digits_pi' is not defined\ndigits_pi[1]\n## Error: NameError: name 'digits_pi' is not defined\ndigits_pi[2]\n\n# Python is 0 indexed - a list of 11 things goes from 0 to 10\n## Error: NameError: name 'digits_pi' is not defined\ndigits_pi[0]\n## Error: NameError: name 'digits_pi' is not defined\ndigits_pi[11] \n\n# multiplication works on the whole vector at once\n## Error: NameError: name 'digits_pi' is not defined\ndigits_pi * 2\n\n# Print out the vector\n## Error: NameError: name 'digits_pi' is not defined\nprint(digits_pi)\n## Error: NameError: name 'digits_pi' is not defined\n```\n:::\n\n\n#### Python Series (Pandas)\n\nPython has multiple things that look like vectors, including the `pandas` library's Series structure. \nA **Series** is a one-dimensional array-like object containing a sequence of values and an associated array of labels (called its index).\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n## Error: ModuleNotFoundError: No module named 'pandas'\ndigits_pi = pd.Series([3,1,4,1,5,9,2,6,5,3,5])\n\n# Access individual entries\n## Error: NameError: name 'pd' is not defined\ndigits_pi[0]\n## Error: NameError: name 'digits_pi' is not defined\ndigits_pi[1]\n## Error: NameError: name 'digits_pi' is not defined\ndigits_pi[2]\n\n# Python is 0 indexed - a list of 11 things goes from 0 to 10\n## Error: NameError: name 'digits_pi' is not defined\ndigits_pi[0]\n## Error: NameError: name 'digits_pi' is not defined\ndigits_pi[11] \n\n# logical indexing works here too\n## Error: NameError: name 'digits_pi' is not defined\ndigits_pi[digits_pi > 3]\n# simple multiplication works in a vectorized manner\n# that is, the whole vector is multiplied at once\n## Error: NameError: name 'digits_pi' is not defined\ndigits_pi * 2\n\n# Print out the series\n## Error: NameError: name 'digits_pi' is not defined\nprint(digits_pi)\n## Error: NameError: name 'digits_pi' is not defined\n```\n:::\n\n\nThe Series object has a list of labels in the first printed column, and a list of values in the second. \nIf we want, we can specify the labels manually to use as e.g. plot labels later:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n## Error: ModuleNotFoundError: No module named 'pandas'\nweekdays = pd.Series(['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], index = ['S', 'M', 'T', 'W', 'R', 'F', 'Sat'])\n\n# access individual objs\n## Error: NameError: name 'pd' is not defined\nweekdays[0]\n## Error: NameError: name 'weekdays' is not defined\nweekdays[1]\n## Error: NameError: name 'weekdays' is not defined\nweekdays['S']\n## Error: NameError: name 'weekdays' is not defined\nweekdays['Sat']\n\n# access the index\n## Error: NameError: name 'weekdays' is not defined\nweekdays.index\n## Error: NameError: name 'weekdays' is not defined\nweekdays.index[6] = 'Z' # you can't assign things to the index to change it\n## Error: NameError: name 'weekdays' is not defined\nweekdays\n## Error: NameError: name 'weekdays' is not defined\n```\n:::\n\n:::\n\n[^05-vectors-2]: A similar system exists in R libraries, but R doesn't handle multiple libraries having the same function names well, which leads to all sorts of confusion. At least python is explicit about it.\n\nWe can pull out items in a vector by indexing, but we can also replace specific things as well:\n\n::: ex\n::: panel-tabset\n#### R {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfavorite_cats <- c(\"Grumpy\", \"Garfield\", \"Jorts\", \"Jean\")\n\nfavorite_cats\n## [1] \"Grumpy\"   \"Garfield\" \"Jorts\"    \"Jean\"\n\nfavorite_cats[2] <- \"Nyan Cat\"\n\nfavorite_cats\n## [1] \"Grumpy\"   \"Nyan Cat\" \"Jorts\"    \"Jean\"\n```\n:::\n\n\n#### Python {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfavorite_cats = [\"Grumpy\", \"Garfield\", \"Jorts\", \"Jean\"]\n\nfavorite_cats\n## ['Grumpy', 'Garfield', 'Jorts', 'Jean']\nfavorite_cats[1] = \"Nyan Cat\"\n\nfavorite_cats\n## ['Grumpy', 'Nyan Cat', 'Jorts', 'Jean']\n```\n:::\n\n:::\n\nIf you're curious about any of these cats, see the footnotes[^05-vectors-3].\n:::\n\n[^05-vectors-3]: [Grumpy cat](https://www.grumpycats.com/), [Garfield](https://www.garfield.com/), [Nyan cat](https://en.wikipedia.org/wiki/Nyan_Cat). Jorts and Jean: [The initial post](https://www.reddit.com/r/AmItheAsshole/comments/rfwgmc/aita_for_perpetuating_ethnic_stereotypes_about/) and the [update](https://www.reddit.com/user/throwawayorangecat/comments/rgi000/update_aita_for_perpetuating_stereotypes_about/) (both are worth a read because the story is hilarious). The cats also have a [Twitter account](https://twitter.com/JortsTheCat) where they promote workers rights.\n\n### Indexing with Logical Vectors\n\nAs you might imagine, we can create vectors of all sorts of different data types. \nOne particularly useful trick is to create a **logical vector** that goes along with a vector of another type to use as a **logical index**.\n\n![lego vectors - a pink/purple hued set of 1x3 bricks representing the data and a corresponding set of 1x1 grey and black bricks representing the logical index vector of the same length](../images/gen-prog/lego-logical-full.png)\n\nIf we let the black lego represent \"True\" and the grey lego represent \"False\", we can use the logical vector to pull out all values in the main vector.\n\n| Black = True, Grey = False                                                                                                                                                                                                                                                                             | Grey = True, Black = False                                                                                                                                                                                                                                                                            |\n|------------------------------------|------------------------------------|\n| ![a pink/purple hued set of 1x3 bricks representing a vector and a corresponding set of 1x1 black bricks representing the logical index vector of the same length. The grey bricks (and corresponding values of the previous vector) have been removed (filtered out).](../images/gen-prog/lego-logical-black.png) | ![a pink/purple hued set of 1x3 bricks representing a vector and a corresponding set of 1x1 grey bricks representing the logical index vector of the same length. The black bricks (and corresponding values of the previous vector) have been removed (filtered out).](../images/gen-prog/lego-logical-grey.png) |\n\nNote that for logical indexing to work properly, the logical index must be the same length as the vector we're indexing. \nThis constraint will return when we talk about data frames, but for now just keep in mind that logical indexing doesn't make sense when this constraint isn't true.\n\n::: panel-tabset\n### Indexing with logical vectors in R {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a character vector\nweekdays <- c(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\")\nweekend <- c(\"Sunday\", \"Saturday\")\n\n# Create logical vectors\nrelax_days <- c(1, 0, 0, 0, 0, 0, 1) # doing this the manual way\nrelax_days <- weekdays %in% weekend # This creates a logical vector \n                                    # with less manual construction\nrelax_days\n## [1]  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE\n\nschool_days <- !relax_days # FALSE if weekend, TRUE if not\nschool_days\n## [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n\n# Using logical vectors to index the character vector\nweekdays[school_days] # print out all school days\n## [1] \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"\n```\n:::\n\n\n### Indexing with logical vectors in python {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np;\n## Error: ModuleNotFoundError: No module named 'numpy'\nanimals = np.array([\"Cat\", \"Dog\", \"Snake\", \"Lizard\", \"Tarantula\", \"Hamster\", \"Gerbil\", \"Otter\"])\n\n# Define a logical vector\n## Error: NameError: name 'np' is not defined\ngood_pets = np.array([True, True, False, False, False, True, True, False])\n## Error: NameError: name 'np' is not defined\nbad_pets = np.invert(good_pets) # Invert the logical vector \n                                # so True -> False and False -> True\n## Error: NameError: name 'np' is not defined\nanimals[good_pets]\n## Error: NameError: name 'animals' is not defined\nanimals[bad_pets]\n## Error: NameError: name 'animals' is not defined\nanimals[~good_pets] # equivalent to using bad_pets\n## Error: NameError: name 'animals' is not defined\n```\n:::\n\n:::\n\n### Reviewing Types\n\nAs vectors are a collection of things of a single type, what happens if we try to make a vector with differently-typed things?\n\n::: panel-tabset\n#### R {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(2L, FALSE, 3.1415, \"animal\") # all converted to strings\n## [1] \"2\"      \"FALSE\"  \"3.1415\" \"animal\"\n\nc(2L, FALSE, 3.1415) # converted to numerics\n## [1] 2.0000 0.0000 3.1415\n\nc(2L, FALSE) # converted to integers\n## [1] 2 0\n```\n:::\n\n\n#### Python {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n## Error: ModuleNotFoundError: No module named 'numpy'\nnp.array([2, False, 3.1415, \"animal\"]) # all converted to strings\n## Error: NameError: name 'np' is not defined\nnp.array([2, False, 3.1415]) # converted to floats\n## Error: NameError: name 'np' is not defined\nnp.array([2, False]) # converted to integers\n## Error: NameError: name 'np' is not defined\n```\n:::\n\n:::\n\nAs a reminder, this is an example of **implicit** type conversion - R and python decide what type to use for you, going with the type that doesn't lose data but takes up as little space as possible.\n\n### Try it Out! {.unnumbered .tryitout}\n\n::: panel-tabset\n#### Problem {.unnumbered}\n\nCreate a vector of the integers from one to 30. Use logical indexing to pick out only the numbers which are multiples of 3.\n\n#### R Solution {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:30\nx [ x %% 3 == 0]\n##  [1]  3  6  9 12 15 18 21 24 27 30\n```\n:::\n\n\n#### Python Solution {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n## Error: ModuleNotFoundError: No module named 'numpy'\nx = np.array(range(1, 31)) # because python is 0 indexed\n## Error: NameError: name 'np' is not defined\nx[ x % 3 == 0]\n## Error: TypeError: unsupported operand type(s) for %: 'list' and 'int'\n```\n:::\n\n:::\n\n::: panel-tabset\n#### Challenge\n\nExtra challenge: Pick out numbers which are multiples of 2 or 3, but not multiples of 6!\n\n#### General Solution {.unnumbered}\n\nThis operation is **xor**, a.k.a. exclusive or. That is, X or Y, but not X AND Y.\n\nWe can write xor as `(X OR Y) & !(X AND Y)` -- or we can use a predefined function: `xor()` in R, `^` in python.\n\n#### R Solution {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:30\n\nx2 <- x %% 2 == 0 # multiples of 2\nx3 <- x %% 3 == 0 # multiples of 3\nx2xor3 <- xor(x2, x3)\nx2xor3_2 <- (x2 | x3) & !(x2 & x3)\nx[x2xor3]\n##  [1]  2  3  4  8  9 10 14 15 16 20 21 22 26 27 28\nx[x2xor3_2]\n##  [1]  2  3  4  8  9 10 14 15 16 20 21 22 26 27 28\n```\n:::\n\n\n#### Python Solution {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n## Error: ModuleNotFoundError: No module named 'numpy'\nx = np.array(range(1, 31))\n## Error: NameError: name 'np' is not defined\nx2 = x % 2 == 0 # multiples of 2\n## Error: TypeError: unsupported operand type(s) for %: 'list' and 'int'\nx3 = x % 3 == 0 # multiples of 3\n## Error: TypeError: unsupported operand type(s) for %: 'list' and 'int'\nx2xor3 = x2 ^ x3\n## Error: NameError: name 'x2' is not defined\nx[x2xor3]\n## Error: NameError: name 'x2xor3' is not defined\n```\n:::\n\n:::\n\n## Matrices\n\nA **matrix** is the next step after a vector - it's a set of values arranged in a two-dimensional, rectangular format.\n\n::: panel-tabset\n### Matrix (Lego) {.unnumbered}\n\n![lego depiction of a 3-row, 4-column matrix of 2x2 red-colored blocks](../images/gen-prog/lego-2x2-matrix.png)\n\n### R {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Minimal matrix in R: take a vector, \n# tell R how many rows you want\nmatrix(1:12, nrow = 3)\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9   12\n\nmatrix(1:12, ncol = 3) # or columns\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\n\n# by default, R will fill in column-by-column\n# the byrow parameter tells R to go row-by-row\nmatrix(1:12, nrow = 3, byrow = T)\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    2    3    4\n## [2,]    5    6    7    8\n## [3,]    9   10   11   12\n\n# We can also easily create square matrices \n# with a specific diagonal (this is useful for modeling)\ndiag(rep(1, times = 4))\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    0    0    0\n## [2,]    0    1    0    0\n## [3,]    0    0    1    0\n## [4,]    0    0    0    1\n```\n:::\n\n\n### Python {.unnumbered}\n\nIn python, matrices are just a special case of a class called `ndarray` - n-dimensional arrays.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n# Minimal ndarray in python by typing in the values in a structured format\n## Error: ModuleNotFoundError: No module named 'numpy'\nnp.array([[0,  1,  2],\n          [3,  4,  5],\n          [6,  7,  8],\n          [9, 10, 11]])\n# This syntax creates a list of the rows we want in our matrix\n\n# Matrix in python using a data vector and size parameters\n## Error: NameError: name 'np' is not defined\nnp.reshape(range(0,12), (3,4))\n## Error: NameError: name 'np' is not defined\nnp.reshape(range(0,12), (4,3))\n## Error: NameError: name 'np' is not defined\nnp.reshape(range(0,12), (3,4), order = 'F')\n## Error: NameError: name 'np' is not defined\n```\n:::\n\n\nIn python, we create 2-dimensional arrays (aka matrices) either by creating a list of rows to join together or by reshaping a 1-dimensional array. \nThe trick with reshaping the 1-dimensional array is the order argument: 'F' stands for \"Fortran-like\" and 'C' stands for \"C-like\"... so to go by column, you use 'F' and to go by row, you use 'C'. \nTotally intuitive, right?\n\n:::\n\nMost of the problems we're going to work on will not require much in the way of matrix or array operations. \nFor now, you need the following:\n\n-   Know that matrices exist and what they are (2-dimensional arrays of numbers)\n-   Understand how they are indexed (because it is extremely similar to data frames that we'll work with in the next chapter)\n-   Be aware that there are lots of functions that depend on matrix operations at their core (including linear regression)\n\nFor more on matrix operations and matrix calculations, see @sec-matrix-calcs.\n\n### Indexing in Matrices\n\nBoth R and python use \\[row, column\\] to index matrices. To extract the bottom-left element of a 3x4 matrix in R, we would use \\[3,1\\] to get to the third row and first column entry; in python, we would use \\[2,0\\] (remember that Python is 0-indexed).\n\nAs with vectors, you can replace elements in a matrix using assignment.\n\n::: panel-tabset\n#### R {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mat <- matrix(1:12, nrow = 3, byrow = T)\n\nmy_mat[3,1] <- 500\n\nmy_mat\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    2    3    4\n## [2,]    5    6    7    8\n## [3,]  500   10   11   12\n```\n:::\n\n\n#### Python {.unnumbered}\n\nRemember that zero-indexing!\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n## Error: ModuleNotFoundError: No module named 'numpy'\nmy_mat = np.reshape(range(1, 13), (3,4))\n## Error: NameError: name 'np' is not defined\nmy_mat[2,0] = 500\n## Error: NameError: name 'my_mat' is not defined\nmy_mat\n## Error: NameError: name 'my_mat' is not defined\n```\n:::\n\n:::\n\n### Matrix Operations\n\nThere are a number of matrix operations that we need to know for basic programming purposes:\n\n-   scalar multiplication \n$$c*\\textbf{X} = c * \\left[\\begin{array}{cc} x_{1,1} & x_{1, 2}\\\\x_{2,1} & x_{2,2}\\end{array}\\right] = \\left[\\begin{array}{cc} c*x_{1,1} & c*x_{1, 2}\\\\c*x_{2,1} & c*x_{2,2}\\end{array}\\right]$$\n-   transpose - flip the matrix across the left top -\\> right bottom diagonal. \n$$t(\\textbf{X}) = \\left[\\begin{array}{cc} x_{1,1} & x_{1, 2}\\\\x_{2,1} & x_{2,2}\\end{array}\\right]^T = \\left[\\begin{array}{cc} x_{1,1} & x_{2,1}\\\\x_{1,2} & x_{2,2}\\end{array}\\right]$$\n-   matrix multiplication (dot product) - If you haven't had this in Linear Algebra, here's a preview. [See @mathisfunHowMultiplyMatrices2021 for a better explanation]\n$$\\textbf{X}*\\textbf{Y} = \\left[\\begin{array}{cc} x_{1,1} & x_{1, 2}\\\\x_{2,1} & x_{2,2}\\end{array}\\right] * \\left[\\begin{array}{cc} y_{1,1} \\\\y_{2,1} \\end{array}\\right] = \\left[\\begin{array}{c}x_{1,1}*y_{1,1} + x_{1,2}*y_{2,1} \\\\x_{2, 1}*y_{1,1} + x_{2,2}*y_{2,1}\\end{array}\\right]$$ \nNote that matrix multiplication depends on having matrices of compatible dimensions. \nIf you have two matrices of dimension $(a \\times b)$ and $(c \\times d)$, then $b$ must be equal to $c$ for the multiplication to work, and your result will be $(a \\times d)$.\n\n::: panel-tabset\n#### R {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(c(1, 2, 3, 4), nrow = 2, byrow = T)\ny <- matrix(c(5, 6), nrow = 2)\n\n# Scalar multiplication\nx * 3\n##      [,1] [,2]\n## [1,]    3    6\n## [2,]    9   12\n3 * x\n##      [,1] [,2]\n## [1,]    3    6\n## [2,]    9   12\n\n# Transpose\nt(x)\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\nt(y)\n##      [,1] [,2]\n## [1,]    5    6\n\n# matrix multiplication (dot product)\nx %*% y\n##      [,1]\n## [1,]   17\n## [2,]   39\n```\n:::\n\n\n#### Python {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n## Error: ModuleNotFoundError: No module named 'numpy'\nx = np.array([[1,2],[3,4]])\n## Error: NameError: name 'np' is not defined\ny = np.array([[5],[6]])\n\n# scalar multiplication\n## Error: NameError: name 'np' is not defined\nx*3\n## ['a', 3, False, 'a', 3, False, 'a', 3, False]\n3*x\n\n# transpose\n## ['a', 3, False, 'a', 3, False, 'a', 3, False]\nx.T # shorthand\n## Error: AttributeError: 'list' object has no attribute 'T'\nx.transpose() # Long form\n\n# Matrix multiplication (dot product)\n## Error: AttributeError: 'list' object has no attribute 'transpose'\nnp.dot(x, y)\n## Error: NameError: name 'np' is not defined\n```\n:::\n\n:::\n\n## Arrays\n\nArrays are a generalized n-dimensional version of a vector: all elements have the same type, and they are indexed using square brackets in both R and python: `[dim1, dim2, dim3, ...]`\n\nI don't think you will need to create 3+ dimensional arrays in this class, but if you want to try it out, here is some code.\n\n::: panel-tabset\n### R {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\narray(1:8, dim = c(2,2,2))\n## , , 1\n## \n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n## \n## , , 2\n## \n##      [,1] [,2]\n## [1,]    5    7\n## [2,]    6    8\n```\n:::\n\n\nNote that displaying this requires 2 slices, since it's hard to display 3D information in a 2D terminal arrangement.\n\n### Python {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n## Error: ModuleNotFoundError: No module named 'numpy'\nnp.array([[[1,2],[3,4]],[[5,6], [7,8]]])\n## Error: NameError: name 'np' is not defined\n```\n:::\n\n:::\n\n\n\n## Data Frames\n\nIn the previous sections, we talked about homogeneous structures: arrangements of data, like vectors and matrices, where every entry in the larger structure has the same type. \nIn the rest of this chapter, we'll be talking about the root of most data science analysis projects: the data frame.\n\nLike an excel spreadsheet, data frames are arrangements of data in columns and rows.\n\nThis format has two main restrictions:\n\n-   Every entry in each column must have the same data type\n-   Every column must have the same number of rows\n\n![A lego data frame of 4 columns and 12 rows. Each column is a separate color hue (data type), with slight variations in the hue of each individual bricks.](../images/gen-prog/lego-data-frame.png)\n\nThe picture above shows a data frame of 4 columns, each with a different data type (brick size/hue). \nThe data frame has 12 rows. \nThis picture may look similar to one that we used to show logical indexing in the last chapter, and that is not a coincidence. \nYou can get everything from a data frame that you would get from a collection of 4 separate vectors... but there are advantages to keeping things in a data frame instead.\n\n\n::: callout-caution\n### Motivating Data Frames: Working with Multiple Vectors\n\nConsider for a moment https://worldpopulationreview.com/states, which lists the population of each state. \nYou can find this dataset in CSV form [here](https://raw.githubusercontent.com/srvanderplas/Stat151/main/data/population2022.csv).\n\nIn the previous sections, we learned how to make different vectors in R, numpy, and pandas.\nLet's see what happens when we work with the data above as a set of vectors/Series compared to what happens when we work with data frames.\n\n::: panel-tabset\n#### Python\n\n(I'm going to cheat and read this in using pandas functions we haven't learned yet to demonstrate why this stuff matters.)\n\n\n::: {.cell hash='03-data-struct_cache/html/read-state-pops_01a085f701c4305877b092ee5fc851b6'}\n\n```{.python .cell-code}\nimport pandas as pd\n## Error: ModuleNotFoundError: No module named 'pandas'\ndata = pd.read_html(\"https://worldpopulationreview.com/states\")[0]\n## Error: NameError: name 'pd' is not defined\nlist(data.columns) # get names\n\n# Create a few population series\n## Error: NameError: name 'data' is not defined\npopulation2022 = pd.Series(data['2022 Population'].values, index = data['State'].values)\n## Error: NameError: name 'pd' is not defined\npopulation2021 = pd.Series(data['2021 Population'].values, index = data['State'].values)\n## Error: NameError: name 'pd' is not defined\npopulation2010 = pd.Series(data['2010 Census'].values, index = data['State'].values)\n## Error: NameError: name 'pd' is not defined\n```\n:::\n\n\nSuppose that we want to sort each population vector by the population in that year.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n## Error: ModuleNotFoundError: No module named 'pandas'\ndata = pd.read_html(\"https://worldpopulationreview.com/states\")[0]\n## Error: NameError: name 'pd' is not defined\npopulation2022 = pd.Series(data['2022 Population'].values, index = data['State'].values).sort_values()\n## Error: NameError: name 'pd' is not defined\npopulation2021 = pd.Series(data['2021 Population'].values, index = data['State'].values).sort_values()\n## Error: NameError: name 'pd' is not defined\npopulation2010 = pd.Series(data['2010 Census'].values, index = data['State'].values).sort_values()\n## Error: NameError: name 'pd' is not defined\npopulation2022.head()\n## Error: NameError: name 'population2022' is not defined\npopulation2021.head()\n## Error: NameError: name 'population2021' is not defined\npopulation2010.head()\n## Error: NameError: name 'population2010' is not defined\n```\n:::\n\n\nThe only problem is that by doing this, we've now lost the ordering that matched across all 3 vectors. \nPandas Series are great for this, because they use labels that allow us to reconstitute which value corresponds to which label, but in R or even in numpy arrays, vectors don't inherently come with labels. \nIn these situations, sorting by one value can actually destroy the connection between two vectors!\n\n#### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.csv(\"https://raw.githubusercontent.com/srvanderplas/Stat151/main/data/population2022.csv\")\n\n# Use vectors instead of the data frame\nstate <- df$State\npop2022 <- df$Pop\npop2021 <- df$Pop2021\npop2010 <- df$Pop2010\n\n# Create a vector to index population in 2022 in order\norder2022 <- order(pop2022)\n\n# To keep variables together, we have to do things like this:\nhead(state[order2022])\n## [1] \"Wyoming\"              \"Vermont\"              \"District of Columbia\"\n## [4] \"Alaska\"               \"North Dakota\"         \"South Dakota\"\nhead(pop2022[order2022])\n## [1] 582233 622882 718355 720763 774008 902542\n\n# It makes more sense just to reorder the whole data frame:\nhead(df[order2022,])\n##    rank                State    Pop  Growth Pop2021 Pop2010 growthSince2010\n## 52   52              Wyoming 582233  0.0020  581075  564487          0.0314\n## 51   51              Vermont 622882 -0.0006  623251  625879         -0.0048\n## 50   50 District of Columbia 718355  0.0059  714153  605226          0.1869\n## 49   49               Alaska 720763 -0.0050  724357  713910          0.0096\n## 48   48         North Dakota 774008  0.0052  770026  674715          0.1472\n## 47   47         South Dakota 902542  0.0066  896581  816166          0.1058\n##    Percent    density\n## 52  0.0017     5.9967\n## 51  0.0019    67.5797\n## 50  0.0021 11776.3115\n## 49  0.0021     1.2631\n## 48  0.0023    11.2173\n## 47  0.0027    11.9052\n```\n:::\n\n\n:::\n\n:::\n\nThe primary advantage to data frames is that rows of data are kept together. \nSince we often think of a row of data as a single observation in a sample, this is an extremely important feature that makes data frames a huge improvement on a collection of vectors of the same length: it's much harder for observations in a single row to get shuffled around and mismatched!\n\n### Data Frame Basics\n\nIn R, data frames are built in as type `data.frame`, though there are packages that provide other implementations of data frames that have additional features, such as the `tibble` package used in many other common packages. \nWe will cover functions from both base R and the `tibble` package in this chapter.\n\nIn Python, we will use the `pandas` library, which is conventionally abbreviated `pd`. So before you use any data frames in python, you will need to add the following line to your code: `import pandas as pd`.\n\n::: callout-demo\n#### Examining Data Frames\n::: panel-tabset\n\n##### R {- .unnumbered}\n\nWhen you examine the structure of a data frame, as shown below, you get each column shown in a row, with its type and the first few values in the column. The `head(n)` command shows the first $n$ rows of a data frame (enough to see what's there, not enough to overflow your screen).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(mtcars) # Load the data -- included in base R\nhead(mtcars) # Look at the first 6 rows\n##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb\n## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\nstr(mtcars) # Examine the structure of the object\n## 'data.frame':\t32 obs. of  11 variables:\n##  $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n##  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n##  $ disp: num  160 160 108 258 360 ...\n##  $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n##  $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n##  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n##  $ qsec: num  16.5 17 18.6 19.4 17 ...\n##  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n##  $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n##  $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n##  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n```\n:::\n\n\nYou can change column values or add new columns easily using assignment. \nThe `summary()` function can be used on specific columns to perform summary operations (a 5-number summary useful for making e.g. boxplots is provided by default).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$gpm <- 1/mtcars$mpg # gpm is sometimes used to assess efficiency\n\nsummary(mtcars$gpm)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n## 0.02950 0.04386 0.05208 0.05423 0.06483 0.09615\nsummary(mtcars$mpg)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   10.40   15.43   19.20   20.09   22.80   33.90\n```\n:::\n\n\nOften, it is useful to know the dimensions of a data frame. \nThe number of rows can be obtained by using `nrow(df)` and similarly, the columns can be obtained using `ncol(df)` (or, get both with `dim()`). \nThere is also an easy way to get a summary of each column in the data frame, using `summary()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(mtcars)\n##       mpg             cyl             disp             hp       \n##  Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0  \n##  1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5  \n##  Median :19.20   Median :6.000   Median :196.3   Median :123.0  \n##  Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7  \n##  3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0  \n##  Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0  \n##       drat             wt             qsec             vs        \n##  Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :0.0000  \n##  1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:0.0000  \n##  Median :3.695   Median :3.325   Median :17.71   Median :0.0000  \n##  Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :0.4375  \n##  3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:1.0000  \n##  Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :1.0000  \n##        am              gear            carb            gpm         \n##  Min.   :0.0000   Min.   :3.000   Min.   :1.000   Min.   :0.02950  \n##  1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.000   1st Qu.:0.04386  \n##  Median :0.0000   Median :4.000   Median :2.000   Median :0.05208  \n##  Mean   :0.4062   Mean   :3.688   Mean   :2.812   Mean   :0.05423  \n##  3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000   3rd Qu.:0.06483  \n##  Max.   :1.0000   Max.   :5.000   Max.   :8.000   Max.   :0.09615\ndim(mtcars)\n## [1] 32 12\nnrow(mtcars)\n## [1] 32\nncol(mtcars)\n## [1] 12\n```\n:::\n\n\nMissing variables in an R data frame are indicated with `NA`.\n\n##### Python {- .unnumbered}\n\nWhen you examine the structure of a data frame, as shown below, you get each column shown in a row, with its type and the first few values in the column. \nThe `df.head(n)` command shows the first $n$ rows of a data frame (enough to see what's there, not enough to overflow your screen).\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmtcars = pd.read_csv(\"https://vincentarelbundock.github.io/Rdatasets/csv/datasets/mtcars.csv\")\n## Error: NameError: name 'pd' is not defined\nmtcars.head(5)\n## Error: NameError: name 'mtcars' is not defined\nmtcars.info()\n## Error: NameError: name 'mtcars' is not defined\n```\n:::\n\n\nYou can change column values or add new columns easily using assignment. \nIt's also easy to access specific columns to perform summary operations. \nYou can access a column named xyz using `df.xyz` or using `df[\"xyz\"]`. \nTo create a new column, you must use `df[\"xyz\"]`.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmtcars[\"gpm\"] = 1/mtcars.mpg # gpm is sometimes used to assess efficiency\n## Error: NameError: name 'mtcars' is not defined\nmtcars.gpm.describe()\n## Error: NameError: name 'mtcars' is not defined\nmtcars.mpg.describe()\n## Error: NameError: name 'mtcars' is not defined\n```\n:::\n\n\nOften, it is useful to know the dimensions of a data frame. \nThe dimensions of a data frame (rows x columns) can be accessed using `df.shape`. \nThere is also an easy way to get a summary of each column in the data frame, using `df.describe()`.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmtcars.describe()\n## Error: NameError: name 'mtcars' is not defined\nmtcars.shape\n## Error: NameError: name 'mtcars' is not defined\n```\n:::\n\n\nMissing variables in a pandas data frame are indicated with `nan` or `NULL`.\n\n\n:::\n:::\n\n\n:::{.callout-tip}\n#### Try it out {.unnumbered}\n\n::: panel-tabset\n\n##### Setup {- .unnumbered}\n\nThe dataset `state.x77` contains information on US state statistics in the 1970s. By default, it is a matrix, but we can easily convert it to a data frame, as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(state)\nstate_facts <- data.frame(state.x77)\nstate_facts <- cbind(state = row.names(state_facts), state_facts, stringsAsFactors = F) \n# State names were stored as row labels\n# Store them in a variable instead, and add it to the data frame\n\nrow.names(state_facts) <- NULL # get rid of row names\n\nhead(state_facts)\n##        state Population Income Illiteracy Life.Exp Murder HS.Grad Frost   Area\n## 1    Alabama       3615   3624        2.1    69.05   15.1    41.3    20  50708\n## 2     Alaska        365   6315        1.5    69.31   11.3    66.7   152 566432\n## 3    Arizona       2212   4530        1.8    70.55    7.8    58.1    15 113417\n## 4   Arkansas       2110   3378        1.9    70.66   10.1    39.9    65  51945\n## 5 California      21198   5114        1.1    71.71   10.3    62.6    20 156361\n## 6   Colorado       2541   4884        0.7    72.06    6.8    63.9   166 103766\n\n# Write data out so that we can read it in using Python\nwrite.csv(state_facts, file = \"data/state_facts.csv\", row.names = F)\n## Error in file(file, ifelse(append, \"a\", \"w\")): cannot open the connection\n```\n:::\n\n\nWe can write out the built in R data and read it in using `pd.read_csv`, which creates a DataFrame in pandas.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n## Error: ModuleNotFoundError: No module named 'pandas'\nstate_facts = pd.read_csv(\"https://raw.githubusercontent.com/srvanderplas/unl-stat850/main/data/state_facts.csv\")\n## Error: NameError: name 'pd' is not defined\n```\n:::\n\n\n\n##### Problem {- .unnumbered}\n\n1. How many rows and columns does it have? Can you find different ways to get that information?\n\n2. The `Illiteracy` column contains the percent of the population of each state that is illiterate. Calculate the number of people in each state who are illiterate, and store that in a new column called `TotalNumIlliterate`. Note: `Population` contains the population in thousands.\n\n3. Calculate the average population density of each state (population per square mile) and store it in a new column `PopDensity`. Using the R reference card, can you find functions that you can combine to get the state with the minimum population density?\n\n##### R Solution {- .unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 3 ways to get rows and columns\nstr(state_facts)\n## 'data.frame':\t50 obs. of  9 variables:\n##  $ state     : chr  \"Alabama\" \"Alaska\" \"Arizona\" \"Arkansas\" ...\n##  $ Population: num  3615 365 2212 2110 21198 ...\n##  $ Income    : num  3624 6315 4530 3378 5114 ...\n##  $ Illiteracy: num  2.1 1.5 1.8 1.9 1.1 0.7 1.1 0.9 1.3 2 ...\n##  $ Life.Exp  : num  69 69.3 70.5 70.7 71.7 ...\n##  $ Murder    : num  15.1 11.3 7.8 10.1 10.3 6.8 3.1 6.2 10.7 13.9 ...\n##  $ HS.Grad   : num  41.3 66.7 58.1 39.9 62.6 63.9 56 54.6 52.6 40.6 ...\n##  $ Frost     : num  20 152 15 65 20 166 139 103 11 60 ...\n##  $ Area      : num  50708 566432 113417 51945 156361 ...\ndim(state_facts)\n## [1] 50  9\nnrow(state_facts)\n## [1] 50\nncol(state_facts)\n## [1] 9\n\n# Illiteracy\nstate_facts$TotalNumIlliterate <- state_facts$Population * 1e3 * (state_facts$Illiteracy/100) \n\n# Population Density\nstate_facts$PopDensity <- state_facts$Population * 1e3/state_facts$Area \n# in people per square mile\n\n# minimum population\nstate_facts$state[which.min(state_facts$PopDensity)]\n## [1] \"Alaska\"\n```\n:::\n\n\n\n##### Python Solution {- .unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Ways to get rows and columns\nstate_facts.shape\n## Error: NameError: name 'state_facts' is not defined\nstate_facts.index.size # rows\n## Error: NameError: name 'state_facts' is not defined\nstate_facts.columns.size # columns\n## Error: NameError: name 'state_facts' is not defined\nstate_facts.info() # columns + rows + missing counts + data types\n\n# Illiteracy\n## Error: NameError: name 'state_facts' is not defined\nstate_facts[\"TotalNumIlliterate\"] = state_facts[\"Population\"] * 1e3 * state_facts[\"Illiteracy\"]/100\n\n# Population Density\n## Error: NameError: name 'state_facts' is not defined\nstate_facts[\"PopDensity\"] = state_facts[\"Population\"] * 1e3/state_facts[\"Area\"] \n# in people per square mile\n\n# minimum population\n## Error: NameError: name 'state_facts' is not defined\nmin_dens = state_facts[\"PopDensity\"].min()\n# Get location of minimum population\n## Error: NameError: name 'state_facts' is not defined\nloc_min_dens = state_facts.PopDensity.isin([min_dens])\n# Pull out matching state\n## Error: NameError: name 'state_facts' is not defined\nstate_facts.state[loc_min_dens]\n## Error: NameError: name 'state_facts' is not defined\n```\n:::\n\n\n:::\n:::\n\n### Creating Data Frames\n\nIt is possible to create data frames from scratch by building them out of simpler components, such as lists of vectors or dicts of Series. \nThis tends to be useful for small data sets, but it is more common to read data in from e.g. CSV files, which I've used several times already but haven't yet shown you how to do (see @sec-data-input for the full how-to).\n\n::: callout-demo\n#### Data Frames from Scratch\n\n::: panel-tabset\n\n##### R {- .unnumbered}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmath_and_lsd <- data.frame(\n  lsd_conc = c(1.17, 2.97, 3.26, 4.69, 5.83, 6.00, 6.41),\n  test_score = c(78.93, 58.20, 67.47, 37.47, 45.65, 32.92, 29.97))\nmath_and_lsd\n##   lsd_conc test_score\n## 1     1.17      78.93\n## 2     2.97      58.20\n## 3     3.26      67.47\n## 4     4.69      37.47\n## 5     5.83      45.65\n## 6     6.00      32.92\n## 7     6.41      29.97\n\n# add a column - character vector\nmath_and_lsd$subjective <- c(\"finally coming back\", \"getting better\", \"it's totally better\", \"really tripping out\", \"is it over?\", \"whoa, man\", \"I can taste color, but I can't do math\")\n\nmath_and_lsd\n##   lsd_conc test_score                             subjective\n## 1     1.17      78.93                    finally coming back\n## 2     2.97      58.20                         getting better\n## 3     3.26      67.47                    it's totally better\n## 4     4.69      37.47                    really tripping out\n## 5     5.83      45.65                            is it over?\n## 6     6.00      32.92                              whoa, man\n## 7     6.41      29.97 I can taste color, but I can't do math\n```\n:::\n\n\n\n##### Python {- .unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmath_and_lsd = pd.DataFrame({\n  \"lsd_conc\": [1.17, 2.97, 3.26, 4.69, 5.83, 6.00, 6.41],\n  \"test_score\": [78.93, 58.20, 67.47, 37.47, 45.65, 32.92, 29.97]})\n## Error: NameError: name 'pd' is not defined\nmath_and_lsd\n\n# add a column - character vector\n## Error: NameError: name 'math_and_lsd' is not defined\nmath_and_lsd[\"subjective\"] = [\"finally coming back\", \"getting better\", \"it's totally better\", \"really tripping out\", \"is it over?\", \"whoa, man\", \"I can taste color, but I can't do math\"]\n## Error: NameError: name 'math_and_lsd' is not defined\nmath_and_lsd\n## Error: NameError: name 'math_and_lsd' is not defined\n```\n:::\n\n\n:::\n\n:::\n\nWhile it's not *so* hard to create data frames from scratch for small data sets, it's very tedious if you have a lot of data (or if you can't type accurately). \nAn easier way to create a data frame (rather than typing the whole thing in) is to read in data from somewhere else - a file, a table on a webpage, etc. \nWe're not going to go into the finer points of this (you'll get into that in @sec-data-input), but it is useful to know how to read neatly formatted data.\n\nOne source of (relatively neat) data is the [TidyTuesday github repository](https://github.com/rfordatascience/tidytuesday)^[Tidy Tuesday is a collaborative project where the R community gets together and explores a dataset, cleaning it, visualizing it, and generally working to collectively hone R skills together. You can find some very nice YouTube livestreams, as well as lots of examples using the [#tidytuesday twitter tag](https://twitter.com/search?q=%23tidytuesday).]\n\n::: callout-demo\n#### Reading in Data\n\n::: panel-tabset\n##### Base R\nIn Base R, we can read the data in using the `read.csv` function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nairmen <- read.csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-02-08/airmen.csv')\nhead(airmen)\n##                    name last_name    first_name      graduation_date\n## 1   Adams, John H., Jr.     Adams  John H., Jr. 1945-04-15T00:00:00Z\n## 2           Adams, Paul     Adams          Paul 1943-04-29T00:00:00Z\n## 3 Adkins, Rutherford H.    Adkins Rutherford H. 1944-10-16T00:00:00Z\n## 4    Adkins, Winston A.    Adkins    Winston A. 1944-02-08T00:00:00Z\n## 5 Alexander, Halbert L. Alexander    Halbert L. 1944-11-20T00:00:00Z\n## 6  Alexander, Harvey R. Alexander     Harvey R. 1944-04-15T00:00:00Z\n##   rank_at_graduation     class graduated_from    pilot_type\n## 1             2nd Lt   SE-45-B           TAAF Single engine\n## 2             2nd Lt   SE-43-D           TAAF Single engine\n## 3             2nd Lt SE-44-I-1           TAAF Single engine\n## 4             2nd Lt   TE-44-B           TAAF   Twin engine\n## 5             2nd Lt   SE-44-I           TAAF Single engine\n## 6             2nd Lt   TE-44-D           TAAF   Twin engine\n##   military_hometown_of_record state aerial_victory_credits\n## 1                 Kansas City    KS                   <NA>\n## 2                  Greenville    SC                   <NA>\n## 3                  Alexandria    VA                   <NA>\n## 4                     Chicago    IL                   <NA>\n## 5                  Georgetown    IL                   <NA>\n## 6                  Georgetown    IL                   <NA>\n##   number_of_aerial_victory_credits reported_lost reported_lost_date\n## 1                                0          <NA>               <NA>\n## 2                                0          <NA>               <NA>\n## 3                                0          <NA>               <NA>\n## 4                                0          <NA>               <NA>\n## 5                                0          <NA>               <NA>\n## 6                                0          <NA>               <NA>\n##   reported_lost_location                                   web_profile\n## 1                   <NA>     https://cafriseabove.org/john-h-adams-jr/\n## 2                   <NA>          https://cafriseabove.org/paul-adams/\n## 3                   <NA> https://cafriseabove.org/rutherford-h-adkins/\n## 4                   <NA>                                          <NA>\n## 5                   <NA> https://cafriseabove.org/halbert-l-alexander/\n## 6                   <NA>  https://cafriseabove.org/harvey-r-alexander/\n```\n:::\n\n\n##### `readR` package\nIf we want instead to create a tibble, we can use the `readr` package's `read_csv` function, which is a bit more robust and has a few additional features.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nairmen <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-02-08/airmen.csv')\nhead(airmen)\n## # A tibble: 6 × 16\n##   name         last_name first_name graduation_date     rank_at_graduation class\n##   <chr>        <chr>     <chr>      <dttm>              <chr>              <chr>\n## 1 Adams, John… Adams     John H., … 1945-04-15 00:00:00 2nd Lt             SE-4…\n## 2 Adams, Paul  Adams     Paul       1943-04-29 00:00:00 2nd Lt             SE-4…\n## 3 Adkins, Rut… Adkins    Rutherfor… 1944-10-16 00:00:00 2nd Lt             SE-4…\n## 4 Adkins, Win… Adkins    Winston A. 1944-02-08 00:00:00 2nd Lt             TE-4…\n## 5 Alexander, … Alexander Halbert L. 1944-11-20 00:00:00 2nd Lt             SE-4…\n## 6 Alexander, … Alexander Harvey R.  1944-04-15 00:00:00 2nd Lt             TE-4…\n## # ℹ 10 more variables: graduated_from <chr>, pilot_type <chr>,\n## #   military_hometown_of_record <chr>, state <chr>,\n## #   aerial_victory_credits <chr>, number_of_aerial_victory_credits <dbl>,\n## #   reported_lost <chr>, reported_lost_date <dttm>,\n## #   reported_lost_location <chr>, web_profile <chr>\n```\n:::\n\n\n##### Pandas\nIn `pandas`, we can read the csv using `pd.read_csv`\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n## Error: ModuleNotFoundError: No module named 'pandas'\nairmen = pd.read_csv(\"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-02-08/airmen.csv\")\n## Error: NameError: name 'pd' is not defined\nairmen.head()\n## Error: NameError: name 'airmen' is not defined\n```\n:::\n\n\n:::\n:::\n\n### Working with Data Frames\n\nOften, we want to know what a data frame contains. \nR and pandas both have easy summary methods for data frames.\n\n::: callout-demo\n#### Data Frame Summaries\n\nNotice that the type of summary depends on the data type.\n\n::: panel-tabset\n##### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(airmen)\n##      name            last_name          first_name       \n##  Length:1006        Length:1006        Length:1006       \n##  Class :character   Class :character   Class :character  \n##  Mode  :character   Mode  :character   Mode  :character  \n##                                                          \n##                                                          \n##                                                          \n##                                                          \n##  graduation_date                   rank_at_graduation    class          \n##  Min.   :1942-03-06 00:00:00.000   Length:1006        Length:1006       \n##  1st Qu.:1943-10-22 00:00:00.000   Class :character   Class :character  \n##  Median :1944-05-23 00:00:00.000   Mode  :character   Mode  :character  \n##  Mean   :1944-07-02 13:18:52.462                                        \n##  3rd Qu.:1945-04-15 00:00:00.000                                        \n##  Max.   :1948-10-12 00:00:00.000                                        \n##  NA's   :11                                                             \n##  graduated_from      pilot_type        military_hometown_of_record\n##  Length:1006        Length:1006        Length:1006                \n##  Class :character   Class :character   Class :character           \n##  Mode  :character   Mode  :character   Mode  :character           \n##                                                                   \n##                                                                   \n##                                                                   \n##                                                                   \n##     state           aerial_victory_credits number_of_aerial_victory_credits\n##  Length:1006        Length:1006            Min.   :0.0000                  \n##  Class :character   Class :character       1st Qu.:0.0000                  \n##  Mode  :character   Mode  :character       Median :0.0000                  \n##                                            Mean   :0.1118                  \n##                                            3rd Qu.:0.0000                  \n##                                            Max.   :4.0000                  \n##                                                                            \n##  reported_lost      reported_lost_date   reported_lost_location\n##  Length:1006        Min.   :1943-07-02   Length:1006           \n##  Class :character   1st Qu.:1943-07-02   Class :character      \n##  Mode  :character   Median :1943-07-02   Mode  :character      \n##                     Mean   :1943-07-02                         \n##                     3rd Qu.:1943-07-02                         \n##                     Max.   :1943-07-02                         \n##                     NA's   :1004                               \n##  web_profile       \n##  Length:1006       \n##  Class :character  \n##  Mode  :character  \n##                    \n##                    \n##                    \n## \n\nlibrary(skimr) # Fancier summaries\nskim(airmen)\n```\n\n::: {.cell-output-display}\nTable: Data summary\n\n|                         |       |\n|:------------------------|:------|\n|Name                     |airmen |\n|Number of rows           |1006   |\n|Number of columns        |16     |\n|_______________________  |       |\n|Column type frequency:   |       |\n|character                |13     |\n|numeric                  |1      |\n|POSIXct                  |2      |\n|________________________ |       |\n|Group variables          |None   |\n\n\n**Variable type: character**\n\n|skim_variable               | n_missing| complete_rate| min| max| empty| n_unique| whitespace|\n|:---------------------------|---------:|-------------:|---:|---:|-----:|--------:|----------:|\n|name                        |         0|          1.00|   9|  28|     0|     1003|          0|\n|last_name                   |         0|          1.00|   3|  12|     0|      617|          0|\n|first_name                  |         0|          1.00|   3|  17|     0|      804|          0|\n|rank_at_graduation          |         5|          1.00|   3|  14|     0|        7|          0|\n|class                       |        20|          0.98|   3|   9|     0|       72|          0|\n|graduated_from              |         0|          1.00|   4|  23|     0|        4|          0|\n|pilot_type                  |         0|          1.00|  11|  13|     0|        5|          0|\n|military_hometown_of_record |         9|          0.99|   3|  19|     0|      366|          0|\n|state                       |        11|          0.99|   2|   5|     0|       48|          0|\n|aerial_victory_credits      |       934|          0.07|  31| 137|     0|       50|          0|\n|reported_lost               |      1004|          0.00|   1|   1|     0|        1|          0|\n|reported_lost_location      |      1004|          0.00|  23|  23|     0|        1|          0|\n|web_profile                 |       813|          0.19|  34|  95|     0|      190|          0|\n\n\n**Variable type: numeric**\n\n|skim_variable                    | n_missing| complete_rate| mean|   sd| p0| p25| p50| p75| p100|hist  |\n|:--------------------------------|---------:|-------------:|----:|----:|--:|---:|---:|---:|----:|:-----|\n|number_of_aerial_victory_credits |         0|             1| 0.11| 0.46|  0|   0|   0|   0|    4|▇▁▁▁▁ |\n\n\n**Variable type: POSIXct**\n\n|skim_variable      | n_missing| complete_rate|min        |max        |median     | n_unique|\n|:------------------|---------:|-------------:|:----------|:----------|:----------|--------:|\n|graduation_date    |        11|          0.99|1942-03-06 |1948-10-12 |1944-05-23 |       52|\n|reported_lost_date |      1004|          0.00|1943-07-02 |1943-07-02 |1943-07-02 |        1|\n:::\n:::\n\n\n##### Python\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# All variables - strings are summarized with NaNs\nairmen.describe(include = 'all')\n\n# Only summarize numeric variables\n## Error: NameError: name 'airmen' is not defined\nairmen.describe(include = [np.number])\n\n# Only summarize string variables (objects)\n## Error: NameError: name 'airmen' is not defined\nairmen.describe(include = ['O'])\n\n# Get counts of how many NAs in each column\n## Error: NameError: name 'airmen' is not defined\nairmen.info(show_counts=True)\n## Error: NameError: name 'airmen' is not defined\n```\n:::\n\n\nIn pandas, you will typically want to separate out .describe() calls for numeric and non-numeric columns. Another handy function in pandas is .info(), which you can use to show the number of non-NA values. This is particularly useful in sparse datasets where there may be a LOT of missing values and you may want to find out which columns have useful information for more than just a few rows.\n:::\n:::\n\n\n## References  {#sec-data-struct-refs}\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}